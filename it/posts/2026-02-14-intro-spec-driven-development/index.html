<!doctype html><html lang=it dir=ltr><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>La transizione Sviluppatore --> Progettista | Cdani's Blog</title><meta name=keywords content="GenAI,Agents,Coding"><meta name=description content="Intro Qualche mese fa ho dovuto mettere mano a un&rsquo;applicazione complessa su AWS: frontend React su Amplify, diverse Lambda, Bedrock con AgentCore, Knowledge Bases e Prompt Management. Avevo fretta, e la tentazione era fortissima: aprire Claude Code, buttargli dentro un prompt generico e sperare che &ldquo;capisse&rdquo;. Invece ho fatto una cosa diversa ‚Äî ho scritto specifiche, le ho revisionate, ci ho perso una giornata intera ‚Äî e quel giorno mi √® sembrato di non aver combinato nulla."><meta name=author content="Me"><link rel=canonical href=https://c-daniele.github.io/it/posts/2026-02-14-intro-spec-driven-development/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.3598bbf45621a4ad34d093926efeb15d6df27175e085d2f069483f14ad39d7fa.css integrity="sha256-NZi79FYhpK000JOSbv6xXW3ycXXghdLwaUg/FK051/o=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://c-daniele.github.io/logo_cd_v3.svg><link rel=icon type=image/png sizes=16x16 href=https://c-daniele.github.io/logo_cd_v3.svg><link rel=icon type=image/png sizes=32x32 href=https://c-daniele.github.io/logo_cd_v3.svg><link rel=apple-touch-icon href=https://c-daniele.github.io/logo_cd_v3.svg><link rel=mask-icon href=https://c-daniele.github.io/logo_cd_v3.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=it href=https://c-daniele.github.io/it/posts/2026-02-14-intro-spec-driven-development/><link rel=alternate hreflang=en href=https://c-daniele.github.io/en/posts/2026-02-14-intro-spec-driven-development/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0,theme:"default",securityLevel:"loose"})</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-8NZQZ3Z1RN"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-8NZQZ3Z1RN",{anonymize_ip:!1})}</script><meta property="og:title" content="La transizione Sviluppatore --> Progettista"><meta property="og:description" content="Intro Qualche mese fa ho dovuto mettere mano a un&rsquo;applicazione complessa su AWS: frontend React su Amplify, diverse Lambda, Bedrock con AgentCore, Knowledge Bases e Prompt Management. Avevo fretta, e la tentazione era fortissima: aprire Claude Code, buttargli dentro un prompt generico e sperare che &ldquo;capisse&rdquo;. Invece ho fatto una cosa diversa ‚Äî ho scritto specifiche, le ho revisionate, ci ho perso una giornata intera ‚Äî e quel giorno mi √® sembrato di non aver combinato nulla."><meta property="og:type" content="article"><meta property="og:url" content="https://c-daniele.github.io/it/posts/2026-02-14-intro-spec-driven-development/"><meta property="og:image" content="https://c-daniele.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-14T00:00:00+02:00"><meta property="article:modified_time" content="2026-02-14T00:00:00+02:00"><meta property="og:site_name" content="Cdani's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://c-daniele.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="La transizione Sviluppatore --> Progettista"><meta name=twitter:description content="Intro Qualche mese fa ho dovuto mettere mano a un&rsquo;applicazione complessa su AWS: frontend React su Amplify, diverse Lambda, Bedrock con AgentCore, Knowledge Bases e Prompt Management. Avevo fretta, e la tentazione era fortissima: aprire Claude Code, buttargli dentro un prompt generico e sperare che &ldquo;capisse&rdquo;. Invece ho fatto una cosa diversa ‚Äî ho scritto specifiche, le ho revisionate, ci ho perso una giornata intera ‚Äî e quel giorno mi √® sembrato di non aver combinato nulla."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"La transizione Sviluppatore --\u003e Progettista","item":"https://c-daniele.github.io/it/posts/2026-02-14-intro-spec-driven-development/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"La transizione Sviluppatore --\u003e Progettista","name":"La transizione Sviluppatore --\u003e Progettista","description":"Intro Qualche mese fa ho dovuto mettere mano a un\u0026rsquo;applicazione complessa su AWS: frontend React su Amplify, diverse Lambda, Bedrock con AgentCore, Knowledge Bases e Prompt Management. Avevo fretta, e la tentazione era fortissima: aprire Claude Code, buttargli dentro un prompt generico e sperare che \u0026ldquo;capisse\u0026rdquo;. Invece ho fatto una cosa diversa ‚Äî ho scritto specifiche, le ho revisionate, ci ho perso una giornata intera ‚Äî e quel giorno mi √® sembrato di non aver combinato nulla.","keywords":["GenAI","Agents","Coding"],"articleBody":"Intro Qualche mese fa ho dovuto mettere mano a un‚Äôapplicazione complessa su AWS: frontend React su Amplify, diverse Lambda, Bedrock con AgentCore, Knowledge Bases e Prompt Management. Avevo fretta, e la tentazione era fortissima: aprire Claude Code, buttargli dentro un prompt generico e sperare che ‚Äúcapisse‚Äù. Invece ho fatto una cosa diversa ‚Äî ho scritto specifiche, le ho revisionate, ci ho perso una giornata intera ‚Äî e quel giorno mi √® sembrato di non aver combinato nulla. Due giorni dopo avevo un‚Äôapplicazione funzionante. Se avessi improvvisato, starei probabilmente ancora debuggando.\nQuesta esperienza mi ha cambiato prospettiva su cosa significhi davvero usare l‚ÄôAI per sviluppare software. Non si tratta di ‚Äúvibe coding‚Äù ‚Äî scrivere un prompt vago e sperare nel meglio ‚Äî ma di qualcosa di molto pi√π strutturato, e paradossalmente pi√π faticoso. Ma prima di entrare nel merito, guardiamoci intorno: i segnali di una trasformazione radicale sono gi√† ovunque.\nLo scorso dicembre, Boris Cherny, ingegnere di Anthropic e creatore di Claude Code (praticamente il prodotto di punta dell‚Äôazienda), ha dichiarato che nei 30 giorni precedenti il 100% delle attivit√† sul repository di Claude Code sono state fatte da Claude Code stesso Il forte rallentamento in borsa di alcune societ√† SaaS fa pensare che il mercato abbia gi√† prezzato la propensione delle aziende a svilupparsi il software in casa piuttosto che comprarlo dai classici big Spotify ha dichiarato che da dicembre 2025 i loro migliori sviluppatori non scrivono pi√π una riga di codice: inviano istruzioni via Slack al loro sistema interno ‚ÄúHonk‚Äù (basato su Claude Code), che implementa le modifiche, mentre gli ingegneri si occupano di revisione e architettura Per affrontare questa discussione, per√≤, dobbiamo lasciarci alle spalle l‚Äôhype del ‚ÄúVibe Coding‚Äù e capire fin da subito che stiamo parlando di un modo diverso di concepire la professione dello sviluppatore e la catena di montaggio del software. Questo modo richiede metodo e disciplina e potrebbe addirittura essere indigesto per alcuni, perch√© rischia di comprimere certe fasi ‚Äúcreative‚Äù del lavoro, che talvolta possono essere le pi√π gratificanti.\nLo sviluppatore √® una professione morta? Secondo molti analisti parliamo di una ‚Äútrasformazione‚Äù, quindi in un certo senso la risposta √® negativa. Tuttavia, io penso che la trasformazione sar√† talmente radicale che nel giro di 5 o 10 anni nessuno di noi vedr√† pi√π un annuncio di lavoro che parla semplicemente di ‚ÄúSviluppatore‚Äù. Lo sviluppatore del software di domani richiede expertise molto variegate (architetture, reti, processi, linguaggi, dati, ‚Ä¶). Non so come si chiamer√† colui il quale far√† questo lavoro in futuro, ma per semplicit√† io lo chiamer√≤ il ‚ÄúPROGETTISTA‚Äù.\nLo stesso concetto di Progettista, lo si sta applicando anche ad altri ambiti meno ortodossi, come ad esempio la scrittura o il giornalismo. Per fare un esempio estremo, qualche mese fa Luciano Floridi, uno dei massimi esponenti della filosofia dell‚Äôinformazione e del Digitale, ha pubblicato un libro intitolato Distant Writing: Literary Production in the Age of Artificial Intelligence., in cui Floridi realizza un suo ambizioso progetto di intrecciare storie di personaggi secondari (minori ma nominati) dei romanzi classici inglesi, da Jane Austen a Virginia Woolf, in brevi storie (1500-2000 parole ciascuna) dove si incontrano in catene narrative plausibili per epoca, luogo e status sociale. Nelle interviste che ha rilasciato, Floridi ha dichiarato di aver sostanzialmente ‚Äúprogettato‚Äù il libro e di averlo nel casetto gi√† da molti anni, ma di essere riuscito a realizzarlo solo tramite l‚Äôuso di LLM per espandere e scrivere le singole storie, e per fare in modo che i personaggi si incontrassero in modo coerente con le loro caratteristiche e con la trama complessiva.\nPrerequisiti Per prepararsi a questa trasformazione io vedo principalmente 2 prerequisiti, uno tecnico e uno mentale. Nessuno dei due √® facoltativo: senza le skills giuste non si producono specifiche di qualit√†; senza il mindset giusto non si ha la pazienza di scriverle.\nSkills Le specifiche software esistono da sempre, non sono certo una novit√† del 2026. Tuttavia √® sorprendente notare come il mondo tech torni ad attenzionare l‚Äôimportanza di questo concetto dopo aver inventato il transformer, disboscato foreste e funestato i mercati azionari con potenziali bolle AI.\nLe tecniche di Spec-Driven Development si basano ovviamente sul concetto di ‚ÄúSpecifica‚Äù, che pu√≤ essere inteso a vari livelli di astrazione (es: user story, specifica tecnica, code template, ‚Ä¶). Il Progettista deve dunque saper leggere e scrivere le specifiche su tutto lo stack e deve avere un approccio metodico e rigoroso per industrializzare il lavoro.\nMa come faccio a scrivere specifiche per una soluzione con componenti frontend, backend, un message broker, diversi container, e la necessit√† di distribuirla su un hyperscaler piuttosto che su un altro?\nNel passato, dovevi sapere le basi dei calcolatori, le CPU, le memorie, la modellazione dati e le reti di telecomunicazioni. Adesso, bisogna alzare il livello di astrazione e allargare la prospettiva. Serve dunque conoscere le piattaforme dati, gli hyperscaler, i pattern di autenticazione, i modelli di deploy e la containerizzazione, le pipeline di automazione e la gestione del software su decine o potenzialmente centinaia di branch.\nPer poter evolvere da ‚ÄúSviluppatore‚Äù del 2020 a ‚ÄúProgettista‚Äù del 2026, serve dunque:\nconoscere le basi delle tecniche DevOps avere competenze di base di Solution Design e sapersi districare tra i pattern di sviluppo e deploy pi√π noti (microservizi, message brokers, containers, protocolli di trasporto e applicativi, Security, IaC, ‚Ä¶) avere forti competenze tecniche su un‚Äôarea specifica (es: frontend, data engineering, ‚Ä¶) conoscere le basi degli LLM, in particolare il ruolo del contesto e le tecniche di context engineering Mindset Per molte persone lo sviluppo √® una passione oltre che un lavoro, e lo dimostrano le numerosissime community di sviluppo Open Source. Dobbiamo abituarci all‚Äôidea che il lavoro del Progettista potrebbe essere molto meno divertente di quello dello Sviluppatore di oggi. Questo passaggio potrebbe essere uno sforzo non accettabile per tutti, ma √® molto probabile che sia proprio qui che si giocher√† la partita sulle competenze che verranno apprezzate dal mercato del lavoro: sar√† infatti fondamentale saper leggere e scrivere specifiche.\nBisogna inoltre combattere con l‚Äôimpulso di avere ‚Äútutto e subito‚Äù: non possiamo pensare di scrivere un prompt e avere il software pronto. Bisogna realmente applicare un certo livello di effort e utilizzare per davvero le skills che citavamo sopra. Come raccontavo nell‚Äôintroduzione, la giornata ‚Äúpersa‚Äù a scrivere specifiche mi ha risparmiato circa due settimane di lavoro. Ma la sensazione iniziale era esattamente quella: di perdere tempo. √à un investimento controintuitivo, e il mindset giusto consiste proprio nell‚Äôaccettarlo.\nConcetti di base Context window La maggior parte delle persone pensa: ‚Äúpi√π cose metto dentro il contesto, meglio √®‚Äù. √à un‚Äôidea che pu√≤ portare fuori strada, e capire il perch√© richiede un minimo di comprensione di come funzionano i modelli.\nGli LLM sono modelli autoregressivi basati sull‚Äôarchitettura Transformer. Il cuore di questa architettura √® il meccanismo di self-attention: per ogni token generato, il modello calcola un punteggio di ‚Äúattenzione‚Äù rispetto a tutti i token precedenti nel contesto. Questo ha due implicazioni pratiche importanti:\nComplessit√† quadratica: il costo computazionale dell‚Äôattenzione cresce come O(n¬≤) rispetto alla lunghezza del contesto. Raddoppiare il contesto quadruplica il costo. Questo non √® solo un problema di latenza e di costi (che pure sono rilevanti), ma degrada la qualit√† stessa dell‚Äôoutput.\n‚ÄúLost in the middle‚Äù: diversi studi (tra cui il noto paper di Liu et al., 2023) hanno dimostrato che gli LLM tendono a prestare maggiore attenzione alle informazioni che si trovano all‚Äôinizio e alla fine del contesto, ‚Äúdimenticando‚Äù quelle centrali. In pratica, se la specifica cruciale della tua API si trova a met√† di una conversazione da 80.000 token, il modello potrebbe semplicemente non tenerla in considerazione.\nSebbene l‚Äôinterfaccia degli LLM si presenti come una chat, dobbiamo sempre valutare ogni singola interazione come se fosse un task isolato, che si porta dietro una storia conversazionale che spesso √® inutile, inquina la context window e porta il modello fuori strada. Questo fenomeno si chiama Context Bloat.\nContext Engineering Il termine ‚ÄúContext Engineering‚Äù viene spesso confuso con il prompt engineering, ma sono concetti distinti. Il prompt engineering riguarda la formulazione della singola richiesta all‚ÄôLLM. Il Context Engineering √® qualcosa di pi√π ampio: √® il controllo sistematico di tutto ci√≤ che entra nella context window del modello ‚Äî system prompt, istruzioni persistenti (come il CLAUDE.md), risultati di tool, file di codice caricati, memoria delle interazioni precedenti, e solo in ultimo il prompt dell‚Äôutente.\nPensate al contesto come a un programma: ogni elemento che vi inserite √® un‚Äôistruzione che il modello eseguir√† (o tenter√† di eseguire). Pi√π istruzioni contraddittorie o irrilevanti inserite, pi√π il ‚Äúprogramma‚Äù diventa imprevedibile.\nCon questa prospettiva, le tecniche di SDD sono essenzialmente tecniche di Context Engineering: massimizzano l‚Äôefficacia della context window rendendo modulare lo sviluppo (SPEC ‚Üí PIANO ‚Üí CLARIFY ‚Üí IMPLEMENTATION) e soprattutto minimizzando il rumore. Ogni fase opera in un contesto pulito e dedicato, con solo le informazioni rilevanti per quel task specifico.\nDivide et impera Nell‚Äôambito dello sviluppo software, molti (anche molti sviluppatori di oggi) pensano che l‚ÄôLLM serva solo per scrivere il codice, mentre le tecniche di SDD si basano sull‚Äôassunto che il Progettista utilizzi l‚ÄôLLM su tutta la pipeline di lavoro del software.\nFase Obiettivo Utilizzo LLM Ideazione Esplorazione dello spazio delle soluzioni Per un determinato problema, esiste un numero potenzialmente infinito di soluzioni e gli LLM sono uno strumento formidabile per esplorarle Specifiche Definizione dettagliata dei requisiti utente Oltre a definire le specifiche di dettaglio, in questa fase vengono anche individuati eventuali gap e aree di ambiguit√† Disegno Avere una solida baseline su cui scrivere il codice senza ‚Äúimprovvisare‚Äù Ricerca, espansione, approfondimento e selezione delle componenti software da creare/modificare e del piano di sviluppo e della modalit√† di test Implementazione Tradurre il disegno in codice Scrittura del codice e dei test Test Verifica del software Esecuzione dei test e identificazione dei bug üí° Tip Per ogni fase, vale la pena valutare di volta in volta l‚ÄôLLM pi√π adatto. Ad esempio, al momento della scrittura Claude Opus 4.6 √® tra i pi√π performanti nel coding puro, ma modelli come le ultime versioni di ChatGPT, Gemini 3 o Kimi k2.5 possono essere pi√π efficaci e creativi nelle fasi di esplorazione delle soluzioni. Riutilizzare lo stesso contesto per un intero ciclo di sviluppo √® fortemente sconsigliato, anche se il modello supporta milioni di token. Il motivo √® il Context Bloat discusso sopra: le decisioni architetturali della fase di Piano, i dettagli delle user story della fase di Specifica, e il codice della fase di Implementazione competono tutti per l‚Äôattenzione del modello. Il risultato √® un degrado progressivo della qualit√† su tutte le fasi, non solo sull‚Äôultima. Cos‚Äô√® l‚ÄôSDD La Spec-Driven Development (SDD) √® un paradigma che tratta le specifiche come fonte primaria di verit√† di un sistema software. Il codice diventa un artefatto secondario, generato o verificato rispetto alla specifica. Invece del classico approccio ‚Äúscrivi il codice prima, documenta dopo‚Äù, l‚ÄôSDD inverte il flusso: si scrivono specifiche chiare e strutturate del comportamento atteso e poi si genera, implementa o verifica il codice rispetto ad esse.\nIn altre parole: la specifica √® il prodotto, il codice √® un sottoprodotto.\nQuesto concetto non √® nuovo in assoluto. L‚ÄôAPI-first development con OpenAPI, il BDD (Behavior-Driven Development) e i contract-driven testing esistono da anni. Ci√≤ che cambia oggi √® che gli LLM rendono possibile automatizzare l‚Äôintero flusso: dalla specifica al piano tecnico, dal piano ai task, dai task al codice, dal codice ai test. La specifica diventa un vero e proprio control plane che orchestra agenti AI e sviluppatori umani.\nUn recente paper su arXiv formalizza l‚ÄôSDD cos√¨: ‚ÄúLe specifiche sono la fonte di verit√†; il codice deriva da esse. La specifica √® la descrizione autoritativa che umani e macchine usano per comprendere, costruire e far evolvere il sistema.‚Äù\nI livelli dell‚ÄôSDD Non esiste un unico modo di applicare l‚ÄôSDD. Si possono identificare tre livelli di rigore:\nSpec-first: la specifica viene scritta prima dell‚Äôimplementazione e guida lo sviluppo iniziale. Ideale per nuovi servizi, API o feature con pi√π consumatori. Spec-anchored: specifica e codice evolvono insieme, mantenuti in sincronia tramite test e validazione. √à il livello pi√π pratico per la maggior parte dei team in produzione. Spec-as-source: gli umani editano solo le specifiche; il codice viene generato da esse. Adatto a domini altamente regolamentati o strutturati dove la tracciabilit√† dal requisito al codice deve essere rigorosa. La maggior parte dei team trover√† nello spec-anchored il giusto compromesso tra rigore e agilit√†.\nOverview dei principali framework L‚Äôecosistema di strumenti per l‚ÄôSDD si sta sviluppando rapidamente. Ecco i tre framework pi√π rilevanti:\nSpec Kit (GitHub) Spec Kit √® il toolkit open-source di GitHub per l‚ÄôSDD. Propone un workflow multi-fase (Specify ‚Üí Plan ‚Üí Tasks ‚Üí Implement) e genera artefatti Markdown versionati nel repository. √à compatibile con GitHub Copilot, Claude Code, Cursor e Gemini CLI. Approfondiremo Spec Kit nel prossimo capitolo.\nOpenSpec (Fission AI) OpenSpec √® un framework leggero e open-source (TypeScript) pensato per portare determinismo nello sviluppo AI. Le sue caratteristiche distintive:\nDelta Specs: cattura i cambiamenti incrementali nei requisiti, anzich√© riscrivere l‚Äôintera specifica Brownfield-first: progettato per evolvere codebase esistenti, non solo per progetti greenfield Nessuna API key o installazione complessa: le specifiche vivono nel repository accanto al codice Supporta oltre 20 strumenti, tra cui Claude Code, Cursor e GitHub Copilot BMAD Method Il BMAD Method (Breakthrough Method for Agile AI-Driven Development) √® un framework open-source pi√π ambizioso, con:\n21 agenti AI specializzati (Analyst, Product Manager, Architect, Developer, QA, Scrum Master, ‚Ä¶) ognuno con ruoli e responsabilit√† definiti 50+ workflow guidati per diversi tipi di progetto e fasi Architettura multi-agente: gli agenti collaborano dall‚Äôideazione all‚Äôimplementazione Compatibile con Claude Code, Cursor, Windsurf e altri IDE AI Ecco una guida rapida per orientarsi nella scelta:\nCriterio Spec Kit OpenSpec BMAD Complessit√† di setup Bassa (CLI + Markdown) Molto bassa (file nel repo) Media-alta (21 agenti da configurare) Ideale per Progetti greenfield con GitHub Evoluzione di codebase esistenti Progetti enterprise con team strutturati Curva di apprendimento ~1 ora ~30 minuti ~1 giorno Lock-in Basso (Markdown + Git) Nessuno (file nel repo) Medio (dipendenza dal framework) Supporto brownfield Limitato Eccellente (Delta Specs) Buono In generale: partite con Spec Kit se usate GitHub e volete un workflow strutturato ma leggero. Scegliete OpenSpec se dovete evolvere una codebase esistente senza stravolgere il workflow. Valutate BMAD solo se il vostro progetto richiede coordinamento multi-ruolo e avete il budget di tempo per configurare l‚Äôintera orchestra di agenti.\nDeep dive su Spec Kit Spec Kit merita un approfondimento perch√© rappresenta lo stato dell‚Äôarte dell‚ÄôSDD applicata ai coding agent ed √® sostenuto direttamente da GitHub e Microsoft.\nIl workflow di Spec Kit si articola in passi ben definiti, ognuno con un comando dedicato:\n1. Costituzione del progetto (/speckit.constitution)\nSi definiscono i principi non-negoziabili del progetto: standard di codifica, requisiti di test, regole di sicurezza, principi UX, target di performance. La constitution viene consultata automaticamente in ogni fase successiva come vincolo.\n2. Specifica funzionale (/speckit.specify)\nSi trasforma un‚Äôidea in una specifica funzionale strutturata: user story, requisiti funzionali, criteri di accettazione. Nessun dettaglio tecnico qui ‚Äî solo il cosa e il perch√©. Spec Kit crea automaticamente un branch Git dedicato alla feature.\n3. Chiarificazione (/speckit.clarify)\nL‚Äôagente AI pone domande strutturate per eliminare ambiguit√† dalla specifica: casi limite, vincoli, gestione degli errori, permessi. Questa fase √® fondamentale: una specifica ambigua produce codice ambiguo.\n4. Piano tecnico (/speckit.plan)\nLa specifica validata viene tradotta in un piano tecnico dettagliato: decisioni architetturali, modelli dati, API, integrazioni. Qui si sceglie lo stack, i pattern e le interfacce. Gli artefatti generati includono plan.md, data-model.md, e una cartella contracts/ con le specifiche API.\n5. Validazione (/speckit.checklist, /speckit.analyze)\nControllo di qualit√† e coerenza tra tutti gli artefatti prima di scrivere codice. Si verificano inconsistenze, gap e problemi di qualit√†.\n6. Scomposizione in task (/speckit.tasks)\nIl piano viene scomposto in unit√† di lavoro piccole e reviewable: ogni task ha input, output e criteri di successo espliciti legati alla specifica. I task sono ordinati per dipendenze e quelli parallelizzabili sono marcati.\n7. Implementazione (/speckit.implement)\nL‚Äôagente AI esegue i task, generando e modificando codice, test e configurazioni secondo il piano. Il codice viene prodotto in piccoli diff, facilmente reviewable.\nUn esempio pratico Immaginiamo di voler sviluppare una semplice API per la gestione di una libreria di libri. Ecco come si svolgerebbe il flusso con Spec Kit:\nFase 1 - Constitution:\n/speckit.constitution Il progetto segue un approccio API-first. Usiamo Python con FastAPI. Ogni endpoint deve avere test unitari. Sicurezza: autenticazione JWT. Database PostgreSQL con Alembic per le migrazioni. Fase 2 - Specify:\n/speckit.specify Costruire un'API REST per gestire una libreria di libri. Gli utenti possono cercare libri per titolo, autore o ISBN. Gli amministratori possono aggiungere, modificare e rimuovere libri. Ogni libro ha: titolo, autore, ISBN, anno di pubblicazione, genere. Include user story e criteri di accettazione. A questo punto Spec Kit genera un file spec.md strutturato con user story del tipo:\nCome utente, voglio cercare libri per titolo, cos√¨ da trovare rapidamente il libro che mi interessa Come amministratore, voglio aggiungere un nuovo libro al catalogo, specificando tutti i metadati Fase 3 - Clarify: L‚Äôagente chiede ad esempio: ‚ÄúCi sono limiti sul numero di risultati per pagina? Cosa succede se si tenta di inserire un ISBN duplicato? Quali campi sono obbligatori?‚Äù\nFase 4 - Plan: Viene generato un piano tecnico. Ecco un estratto realistico del plan.md generato:\n# Piano Tecnico - API Libreria ## Architettura - Framework: FastAPI con Pydantic v2 per validazione - Database: PostgreSQL 16 con SQLAlchemy 2.0 (async) - Migrazioni: Alembic con autogenerate - Auth: JWT (access token 15min + refresh token 7d) ## Modello Dati ### Book | Campo | Tipo | Vincoli | |-------------|-------------|---------------------------| | id | UUID | PK, auto-generato | | title | VARCHAR(255)| NOT NULL, INDEX | | author | VARCHAR(255)| NOT NULL, INDEX | | isbn | VARCHAR(13) | UNIQUE, NOT NULL | | year | INTEGER | CHECK (year \u003e= 1450) | | genre | VARCHAR(100)| NULL | | created_at | TIMESTAMP | DEFAULT now() | ## Endpoint REST - `GET /books?title=\u0026author=\u0026isbn=\u0026page=1\u0026size=20` ‚Üí 200 + paginazione - `GET /books/{id}` ‚Üí 200 | 404 - `POST /books` ‚Üí 201 | 400 (validazione) | 409 (ISBN duplicato) - `PUT /books/{id}` ‚Üí 200 | 404 - `DELETE /books/{id}` ‚Üí 204 | 404 - Tutti i metodi POST/PUT/DELETE richiedono header `Authorization: Bearer ` Notare il livello di dettaglio: tipi, vincoli, codici di risposta, regole di autenticazione. Non c‚Äô√® ambiguit√†, e l‚Äôagente AI che ricever√† questo piano non dovr√† ‚Äúindovinare‚Äù nulla.\nFase 5-6 - Checklist \u0026 Tasks: Vengono generati task come:\nCreare i modelli SQLAlchemy (Book, User) Configurare Alembic e creare la migrazione iniziale Implementare l‚Äôendpoint GET /books con filtri e paginazione Implementare l‚Äôendpoint POST /books con validazione Aggiungere autenticazione JWT Scrivere i test per ogni endpoint Ogni task ha input, output e criteri di successo espliciti. I task parallelizzabili sono marcati con [P], quelli sequenziali sono ordinati per dipendenze.\nFase 7 - Implement: L‚Äôagente esegue ogni task, producendo codice e test verificabili.\nIl punto chiave √® che ogni fase produce artefatti Markdown versionati nel repository, creando una tracciabilit√† completa dall‚Äôidea al codice. Se tra sei mesi qualcuno chiede ‚Äúperch√© questa API funziona cos√¨?‚Äù, la risposta √® nella specifica.\nCoding Agents L‚ÄôSDD √® la metodologia, ma per metterla in pratica servono gli strumenti giusti. I coding agent sono la componente operativa di questo nuovo paradigma: agenti AI che non si limitano al completamento automatico, ma pianificano task, modificano codebase, eseguono test e collaborano attraverso i workflow DevOps esistenti.\nCome funziona un coding agent (sotto il cofano) Prima di passare in rassegna gli strumenti, vale la pena capire cosa distingue un ‚Äúagente‚Äù da un semplice chatbot. Un coding agent opera secondo un loop agentico continuo, che in pseudo-codice si pu√≤ rappresentare cos√¨:\nwhile task is not complete: context = gather(specs, code, test_results, errors) plan = reason(context) # l'LLM decide cosa fare action = select_tool(plan) # scelta del tool: edit, bash, search... result = execute(action) # esecuzione reale nel filesystem/terminale feedback = verify(result) # test, lint, output del comando if feedback.has_errors: context.append(feedback) # l'errore diventa input per il prossimo ciclo Il meccanismo chiave √® il tool use (o function calling): l‚ÄôLLM non genera solo testo, ma emette chiamate strutturate a strumenti esterni ‚Äî editor di file, terminale bash, browser, API. Questo gli permette di interagire con il mondo reale: leggere un file, modificarlo, eseguire i test e reagire ai risultati.\nLa differenza fondamentale tra i vari agenti sul mercato sta in quali tool hanno a disposizione e in quale ambiente operano:\nAgenti con accesso diretto al filesystem (Claude Code, Cursor): operano sulla tua macchina, con accesso completo a terminale e file. Massima flessibilit√†, ma richiedono supervisione. Agenti in sandbox isolata (Devin, GitHub Copilot coding agent): operano in un ambiente cloud dedicato. Pi√π sicuri per l‚Äôautonomia completa, ma meno flessibili per workflow personalizzati. Il panorama dei coding agent si √® evoluto rapidamente e oggi possiamo distinguere diverse categorie:\nAgenti integrati nell‚Äôecosistema GitHub Copilot coding agent: lavora direttamente nel workflow delle Pull Request. Puoi assegnare una issue a @copilot e l‚Äôagente pianifica, modifica il codice, esegue i test e apre una PR autonomamente. √à il target nativo di Spec Kit. Amazon Q Developer: l‚Äôassistente AI di AWS, particolarmente forte per lo sviluppo cloud-native, IaC e le trasformazioni applicative (es. migrazione Java 8‚Üí17). Google Gemini Code Assist: forte integrazione con i servizi Google Cloud (BigQuery, Firebase, Apigee). Supportato esplicitamente da Spec Kit come target SDD. Agenti editor-first Cursor: un fork di VS Code nativamente AI-first. La modalit√† Agentic + Composer permette di pianificare task multi-step, modificare pi√π file, eseguire comandi nel terminale e iterare fino al superamento dei test. JetBrains AI Assistant \u0026 Junie: integrato in tutti gli IDE JetBrains, Junie offre programmazione agentica per implementare fix, refactoring e test. Piattaforme agente Claude Code / Claude Agent SDK: piattaforma di Anthropic basata sul principio ‚Äúdai all‚Äôagente un computer‚Äù. Claude Code ha accesso a terminale e file system e opera con un ciclo continuo: raccogli contesto ‚Üí agisci ‚Üí verifica ‚Üí ripeti. L‚ÄôAgent SDK permette di costruire agenti personalizzati. Devin (Cognition): agente completamente autonomo con il proprio ambiente di sviluppo integrato (shell, editor, browser). Ancora sperimentale e poco ‚Äúenterprise‚Äù Quale agente scegliere? Per un‚Äôazienda che vuole adottare l‚ÄôSDD oggi, un approccio pragmatico √®:\nGitHub Copilot o Amazon Q per il lavoro issue/PR-driven sui servizi core Gemini Code Assist per workflow SDD su analytics e integrazioni GCP Cursor o JetBrains nell‚ÄôIDE per implementazione ad alta fedelt√† dalle specifiche Claude Code / Agent SDK per pipeline SDD personalizzate dove gli strumenti standard sono troppo rigidi Il valore aggiunto dei file istruzione: CLAUDE.md Uno dei concetti pi√π potenti emersi con i coding agent √® quello dei file di istruzione persistente: file Markdown che l‚Äôagente legge automaticamente all‚Äôinizio di ogni sessione per comprendere il contesto del progetto. Ogni agente ha il suo formato (.github/copilot-instructions.md per Copilot, .cursorrules per Cursor, ecc.), ma il pi√π noto e maturo √® il CLAUDE.md di Claude Code.\nChe cos‚Äô√® CLAUDE.md CLAUDE.md √® un file di istruzione specifico per progetto che Claude Code legge automaticamente all‚Äôavvio in una directory. Il suo scopo √®:\nDare a Claude il contesto minimo che non pu√≤ inferire dal codice Codificare regole critiche e caveat che devono essere rispettati in ogni task Migliorare affidabilit√† e velocit√† evitando spiegazioni ripetute Va pensato come un system prompt curato con attenzione, non come una wiki. √à un contratto vivente tra la codebase e gli agenti AI.\nCome impostare un buon CLAUDE.md Le best practice, confermate sia dalla documentazione Anthropic che dalla esperienza empirica della Community, convergono su alcuni principi chiave. Questi principi non sono specifici di Claude Code ma derivano dalle caratteristiche generali degli LLM, di conseguenza valgono per qualsiasi assistente o coding Agent, anche se il formato specifico pu√≤ variare a seconda dello strumento.\n1. Less is more\nOgni riga aggiuntiva pu√≤ ridurre la qualit√† complessiva del rispetto delle istruzioni. Gli LLM possono seguire con alta fedelt√† solo un numero limitato di istruzioni distinte. Quando ce ne sono troppe, l‚Äôaderenza a tutte le regole degrada ‚Äî non vengono ignorate le ultime, peggiorano tutte.\n2. Alto segnale, basso rumore\nIncludere solo informazioni che sono:\nDifficili da inferire per Claude leggendo il codice Rilevanti per la grande maggioranza dei task quotidiani 3. La struttura minima efficace\nUn buon CLAUDE.md contiene tipicamente tre blocchi:\n# CLAUDE.md ## Progetto Questo √® un portale e-commerce Next.js + TypeScript che comunica con le nostre API interne di pagamento e catalogo. ## Comandi chiave - Installare dipendenze: `pnpm install` - Dev server: `pnpm dev` - Build: `pnpm build` - Test: `pnpm test` - Lint: `pnpm lint` ## Caveat IMPORTANTI - IMPORTANTE: Non modificare `prisma/schema.prisma` direttamente. Usare `pnpm db:migrate` e `pnpm db:generate`. - IMPORTANTE: L'endpoint `/api/webhooks/stripe` si aspetta il body raw della request. NON usare un body parser. - Le immagini in `public/` devono essere ottimizzate prima del commit; file \u003e 200KB faranno fallire la CI. 4. Non mettere regole di stile\nRegole come ‚Äúusa due spazi per l‚Äôindentazione‚Äù o ‚Äúusa single quotes‚Äù sono uno spreco di istruzioni: Claude le inferisce dal codice esistente, e comunque linter e formatter le gestiscono meglio.\n5. Disclosure progressiva\nPer informazioni dettagliate ma raramente necessarie, non appesantire il file principale. Piuttosto:\n## Documentazione aggiuntiva - Schema database e migrazioni: leggere `docs/schema.md` quando si modificano i modelli. Claude aprir√† docs/schema.md solo quando necessario, invece di caricarlo ad ogni task.\n6. Regole path-specific con .claude/rules/\nClaude Code supporta file di istruzione specifici per path:\n# .claude/rules/tests.md paths: [\"**/*.spec.ts\", \"**/*.test.ts\"] ## Regole di test - Usare Vitest, non Jest. - Usare gli helper in `test-utils/` per il rendering dei componenti. Questo file viene caricato solo quando Claude lavora su file di test, mantenendo il CLAUDE.md globale pi√π snello.\n7. Manutenzione continua\nTrattare CLAUDE.md come un documento vivente: aggiornarlo quando si nota che Claude ripete errori evitabili, rimuovere istruzioni obsolete, riordinare per importanza. Le regole pi√π importanti vanno sempre in cima al file.\nLimiti e rischi dell‚ÄôSDD Sarebbe disonesto presentare l‚ÄôSDD come una soluzione priva di criticit√†. Ci sono limiti concreti che √® bene conoscere prima di adottarla:\nNon-determinismo. Gli LLM non sono deterministici: la stessa specifica, data allo stesso modello in due momenti diversi, pu√≤ produrre codice strutturalmente diverso. Questo significa che l‚ÄôSDD non garantisce riproducibilit√†. La specifica riduce drasticamente la varianza rispetto a un prompt generico, ma non la elimina. Per questo i contract test e la validazione automatica sono indispensabili ‚Äî sono il ‚Äúguardrail deterministico‚Äù che compensa la natura probabilistica del modello. Allo stesso tempo, per√≤, vale la pena riflettere sul fatto che, in generale, lo stesso concetto vale anche per gli esseri umani: lo stesso sviluppatore, leggendo la stessa specifica in due momenti diversi, pu√≤ scrivere codice diverso. Garbage in, garbage out (spostato di livello). Se uso un LLM per generare le specifiche stesse, chi le valida? Il rischio √® di automatizzare la produzione di specifiche plausibili ma errate ‚Äî ad esempio, un modello dati che sembra ragionevole ma viola una regola di business non esplicitata. La revisione umana delle specifiche non √® opzionale: √® il punto di controllo critico dell‚Äôintero workflow. Scalabilit√†. L‚Äôesempio della libreria di libri funziona bene, ma cosa succede con un sistema distribuito di 200 microservizi? L‚ÄôSDD scala bene fino a quando le specifiche restano modularizzabili ‚Äî un servizio alla volta, una feature alla volta. Quando le dipendenze cross-service diventano troppo intricate, le specifiche rischiano di diventare esse stesse un problema di manutenzione. Non √® un motivo per non adottare l‚ÄôSDD, ma √® un motivo per non pensarla come una bacchetta magica. Costi. Un workflow SDD completo (specify ‚Üí clarify ‚Üí plan ‚Üí tasks ‚Üí implement) consuma significativamente pi√π token di un singolo prompt. Ogni fase √® una o pi√π chiamate all‚ÄôLLM, ognuna con il proprio contesto. Su modelli di punta come Claude Opus o GPT-4, un ciclo completo per una feature di media complessit√† pu√≤ costare tra i 5 e i 20 dollari in token. √à un investimento che si ripaga ampiamente in termini di tempo risparmiato, ma va pianificato ‚Äî soprattutto per team che lavorano su decine di feature in parallelo. Overhead per progetti semplici. Un workflow SDD completo per uno script di 50 righe √® over-engineering. L‚ÄôSDD d√† il meglio su feature con complessit√† medio-alta, dove le ambiguit√† sono il vero costo. Per task banali, un buon prompt diretto resta la scelta migliore. Tutti questi limiti sono tuttavia gestibili attraverso un approccio disciplinato e consapevole. In altre parole, un approccio naive in stile ‚Äúvibe-coding‚Äù pu√≤ andar bene per un piccolo prototipo, ma all‚Äôaumentare della complessit√† del progetto √® necessario applicare le tecniche di SDD sempre con maggior rigore per evitare di incorrere in questi problemi.\nConclusioni La Spec-Driven Development non √® una moda passeggera n√© un esercizio accademico.\nL‚ÄôSDD √® un approccio metodologico e disciplinato allo sviluppo del software tramite AI Agents, che sfrutta le capacit√† degli agenti su tutto lo stack di sviluppo, dalla esplorazione dello spazio delle soluzioni, alla scrittura di specifiche dettagliate, alla pianificazione tecnica, fino all‚Äôimplementazione e al testing.\nMa come abbiamo visto, non √® priva di limiti: il non-determinismo degli LLM, il rischio di specifiche errate, i costi in token e l‚Äôoverhead per progetti semplici sono tutti fattori da considerare. L‚ÄôSDD funziona meglio quando applicata con giudizio, non come dogma.\nPer chi lavora nello sviluppo software oggi, il messaggio √® chiaro:\nInvestite nelle competenze trasversali: architettura, DevOps, modelli dati, sicurezza. Il Progettista del futuro non √® chi scrive il codice pi√π veloce, ma chi scrive le specifiche pi√π precise. Adottate gradualmente: partite con l‚ÄôAPI-first e i contract test. Poi aggiungete un framework SDD come Spec Kit su una feature nuova. Misurate i risultati. Abbandonate il Vibe Coding: scrivere prompt vaghi e sperare nel meglio non scala. Investire una giornata in specifiche per risparmiare due settimane di lavoro non √® ‚Äúperdere tempo‚Äù ‚Äî √® il mestiere del Progettista. Preparatevi al cambio di mentalit√†: sar√† meno ‚Äúdivertente‚Äù nel senso tradizionale, ma la soddisfazione di orchestrare un sistema complesso attraverso specifiche che producono software funzionante √®, a suo modo, altrettanto appagante. Il futuro dello sviluppo software non √® scrivere codice. √à progettare sistemi e lasciare che il codice si scriva da solo ‚Äî ma sotto il controllo rigoroso di chi sa cosa vuole ottenere.\n","wordCount":"4999","inLanguage":"it","datePublished":"2026-02-14T00:00:00+02:00","dateModified":"2026-02-14T00:00:00+02:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://c-daniele.github.io/it/posts/2026-02-14-intro-spec-driven-development/"},"publisher":{"@type":"Organization","name":"Cdani's Blog","logo":{"@type":"ImageObject","url":"https://c-daniele.github.io/logo_cd_v3.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://c-daniele.github.io/it/ accesskey=h title="Home (Alt + H)"><img src=https://c-daniele.github.io/logo_cd_v3.svg alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://c-daniele.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://c-daniele.github.io/it/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://c-daniele.github.io/it/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://c-daniele.github.io/it/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://c-daniele.github.io/it/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://c-daniele.github.io/it/>Home</a></div><h1 class=post-title>La transizione Sviluppatore --> Progettista</h1><div class=post-meta><span title='2026-02-14 00:00:00 +0200 +0200'>febbraio 14, 2026</span>&nbsp;¬∑&nbsp;24 minuti&nbsp;¬∑&nbsp;4999 parole&nbsp;¬∑&nbsp;Me&nbsp;|&nbsp;Traduzioni:<ul class=i18n_list><li><a href=https://c-daniele.github.io/en/posts/2026-02-14-intro-spec-driven-development/>En</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Indice contenuti</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#lo-sviluppatore-√®-una-professione-morta>Lo sviluppatore √® una professione morta?</a></li><li><a href=#prerequisiti>Prerequisiti</a><ul><li><a href=#skills>Skills</a></li><li><a href=#mindset>Mindset</a></li></ul></li><li><a href=#concetti-di-base>Concetti di base</a><ul><li><a href=#context-window>Context window</a></li><li><a href=#context-engineering>Context Engineering</a></li><li><a href=#divide-et-impera>Divide et impera</a></li></ul></li><li><a href=#cos√®-lsdd>Cos&rsquo;√® l&rsquo;SDD</a><ul><li><a href=#i-livelli-dellsdd>I livelli dell&rsquo;SDD</a></li><li><a href=#overview-dei-principali-framework>Overview dei principali framework</a></li><li><a href=#deep-dive-su-spec-kit>Deep dive su Spec Kit</a></li><li><a href=#un-esempio-pratico>Un esempio pratico</a></li></ul></li><li><a href=#coding-agents>Coding Agents</a><ul><li><a href=#come-funziona-un-coding-agent-sotto-il-cofano>Come funziona un coding agent (sotto il cofano)</a></li><li><a href=#agenti-integrati-nellecosistema>Agenti integrati nell&rsquo;ecosistema</a></li><li><a href=#agenti-editor-first>Agenti editor-first</a></li><li><a href=#piattaforme-agente>Piattaforme agente</a></li><li><a href=#quale-agente-scegliere>Quale agente scegliere?</a></li><li><a href=#il-valore-aggiunto-dei-file-istruzione-claudemd>Il valore aggiunto dei file istruzione: CLAUDE.md</a></li><li><a href=#che-cos√®-claudemd>Che cos&rsquo;√® CLAUDE.md</a></li><li><a href=#come-impostare-un-buon-claudemd>Come impostare un buon CLAUDE.md</a></li></ul></li><li><a href=#limiti-e-rischi-dellsdd>Limiti e rischi dell&rsquo;SDD</a></li><li><a href=#conclusioni>Conclusioni</a></li></ul></nav></div></details></div><div class=post-content><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><p>Qualche mese fa ho dovuto mettere mano a un&rsquo;applicazione complessa su AWS: frontend React su Amplify, diverse Lambda, Bedrock con AgentCore, Knowledge Bases e Prompt Management. Avevo fretta, e la tentazione era fortissima: aprire Claude Code, buttargli dentro un prompt generico e sperare che &ldquo;capisse&rdquo;. Invece ho fatto una cosa diversa ‚Äî ho scritto specifiche, le ho revisionate, ci ho perso una giornata intera ‚Äî e quel giorno mi √® sembrato di non aver combinato nulla. Due giorni dopo avevo un&rsquo;applicazione funzionante. Se avessi improvvisato, starei probabilmente ancora debuggando.</p><p>Questa esperienza mi ha cambiato prospettiva su cosa significhi davvero usare l&rsquo;AI per sviluppare software. Non si tratta di &ldquo;vibe coding&rdquo; ‚Äî scrivere un prompt vago e sperare nel meglio ‚Äî ma di qualcosa di molto pi√π strutturato, e paradossalmente pi√π faticoso. Ma prima di entrare nel merito, guardiamoci intorno: i segnali di una trasformazione radicale sono gi√† ovunque.</p><ul><li>Lo scorso dicembre, Boris Cherny, ingegnere di Anthropic e creatore di Claude Code (praticamente il prodotto di punta dell&rsquo;azienda), <a href=https://x.com/bcherny/status/2004887829252317325>ha dichiarato</a> che nei 30 giorni precedenti il 100% delle attivit√† sul repository di Claude Code sono state fatte da Claude Code stesso</li><li>Il forte rallentamento in borsa di alcune societ√† SaaS fa pensare che <a href="https://www.bloomberg.com/news/articles/2026-02-04/what-s-behind-the-saaspocalypse-plunge-in-software-stocks?embedded-checkout=true">il mercato abbia gi√† prezzato</a> la propensione delle aziende a svilupparsi il software in casa piuttosto che comprarlo dai classici big</li><li>Spotify <a href=https://techcrunch.com/2026/02/12/spotify-says-its-best-developers-havent-written-a-line-of-code-since-december-thanks-to-ai/>ha dichiarato</a> che da dicembre 2025 i loro migliori sviluppatori non scrivono pi√π una riga di codice: inviano istruzioni via Slack al loro sistema interno &ldquo;Honk&rdquo; (basato su Claude Code), che implementa le modifiche, mentre gli ingegneri si occupano di revisione e architettura</li></ul><hr><p>Per affrontare questa discussione, per√≤, dobbiamo lasciarci alle spalle l&rsquo;hype del &ldquo;Vibe Coding&rdquo; e capire fin da subito che stiamo parlando di un modo diverso di concepire la professione dello sviluppatore e la catena di montaggio del software.
Questo modo richiede metodo e disciplina e potrebbe addirittura essere indigesto per alcuni, perch√© rischia di comprimere certe fasi &ldquo;creative&rdquo; del lavoro, che talvolta possono essere le pi√π gratificanti.</p><h2 id=lo-sviluppatore-√®-una-professione-morta>Lo sviluppatore √® una professione morta?<a hidden class=anchor aria-hidden=true href=#lo-sviluppatore-√®-una-professione-morta>#</a></h2><p>Secondo molti analisti parliamo di una &ldquo;<em>trasformazione</em>&rdquo;, quindi in un certo senso la risposta √® negativa. Tuttavia, io penso che la trasformazione sar√† talmente radicale che nel giro di 5 o 10 anni nessuno di noi vedr√† pi√π un annuncio di lavoro che parla semplicemente di &ldquo;Sviluppatore&rdquo;.
Lo sviluppatore del software di domani richiede expertise molto variegate (architetture, reti, processi, linguaggi, dati, &mldr;). Non so come si chiamer√† colui il quale far√† questo lavoro in futuro, ma per semplicit√† io lo chiamer√≤ il &ldquo;<strong>PROGETTISTA</strong>&rdquo;.</p><p>Lo stesso concetto di Progettista, lo si sta applicando anche ad altri ambiti meno ortodossi, come ad esempio la scrittura o il giornalismo.
Per fare un esempio estremo, qualche mese fa Luciano Floridi, uno dei massimi esponenti della filosofia dell&rsquo;informazione e del Digitale, ha pubblicato un libro intitolato <a href=https://www.rivista.ai/wp-content/uploads/2025/04/ssrn-5232088.pdf>Distant Writing: Literary Production in the Age of Artificial Intelligence.</a>, in cui Floridi realizza un suo ambizioso progetto di intrecciare storie di personaggi secondari (minori ma nominati) dei romanzi classici inglesi, da Jane Austen a Virginia Woolf, in brevi storie (1500-2000 parole ciascuna) dove si incontrano in catene narrative plausibili per epoca, luogo e status sociale.
Nelle interviste che ha rilasciato, Floridi ha dichiarato di aver sostanzialmente &ldquo;progettato&rdquo; il libro e di averlo nel casetto gi√† da molti anni, ma di essere riuscito a realizzarlo solo tramite l&rsquo;uso di LLM per espandere e scrivere le singole storie, e per fare in modo che i personaggi si incontrassero in modo coerente con le loro caratteristiche e con la trama complessiva.</p><h2 id=prerequisiti>Prerequisiti<a hidden class=anchor aria-hidden=true href=#prerequisiti>#</a></h2><p>Per prepararsi a questa trasformazione io vedo principalmente 2 prerequisiti, uno tecnico e uno mentale. Nessuno dei due √® facoltativo: senza le skills giuste non si producono specifiche di qualit√†; senza il mindset giusto non si ha la pazienza di scriverle.</p><h3 id=skills>Skills<a hidden class=anchor aria-hidden=true href=#skills>#</a></h3><p>Le specifiche software esistono da sempre, non sono certo una novit√† del 2026. Tuttavia √® sorprendente notare come il mondo tech torni ad attenzionare l&rsquo;importanza di questo concetto dopo aver inventato il transformer, disboscato foreste e funestato i mercati azionari con potenziali bolle AI.</p><p>Le tecniche di Spec-Driven Development si basano ovviamente sul concetto di &ldquo;Specifica&rdquo;, che pu√≤ essere inteso a vari livelli di astrazione (es: user story, specifica tecnica, code template, &mldr;).
Il Progettista deve dunque saper leggere e scrivere le specifiche su tutto lo stack e deve avere un approccio metodico e rigoroso per industrializzare il lavoro.</p><p>Ma come faccio a scrivere specifiche per una soluzione con componenti frontend, backend, un message broker, diversi container, e la necessit√† di distribuirla su un hyperscaler piuttosto che su un altro?</p><p>Nel passato, dovevi sapere le basi dei calcolatori, le CPU, le memorie, la modellazione dati e le reti di telecomunicazioni.
Adesso, bisogna alzare il livello di astrazione e allargare la prospettiva. Serve dunque conoscere le piattaforme dati, gli hyperscaler, i pattern di autenticazione, i modelli di deploy e la containerizzazione, le pipeline di automazione e la gestione del software su decine o potenzialmente centinaia di branch.</p><p>Per poter evolvere da &ldquo;Sviluppatore&rdquo; del 2020 a &ldquo;Progettista&rdquo; del 2026, serve dunque:</p><ul><li>conoscere le basi delle tecniche DevOps</li><li>avere competenze di base di Solution Design e sapersi districare tra i pattern di sviluppo e deploy pi√π noti (microservizi, message brokers, containers, protocolli di trasporto e applicativi, Security, IaC, &mldr;)</li><li>avere forti competenze tecniche su un&rsquo;area specifica (es: frontend, data engineering, &mldr;)</li><li>conoscere le basi degli LLM, in particolare il ruolo del contesto e le tecniche di context engineering</li></ul><h3 id=mindset>Mindset<a hidden class=anchor aria-hidden=true href=#mindset>#</a></h3><p>Per molte persone lo sviluppo √® una passione oltre che un lavoro, e lo dimostrano le numerosissime community di sviluppo Open Source.
Dobbiamo abituarci all&rsquo;idea che il lavoro del Progettista potrebbe essere molto meno divertente di quello dello Sviluppatore di oggi. Questo passaggio potrebbe essere uno sforzo non accettabile per tutti, ma √® molto probabile che sia proprio qui che si giocher√† la partita sulle competenze che verranno apprezzate dal mercato del lavoro: sar√† infatti fondamentale saper leggere e scrivere specifiche.</p><p>Bisogna inoltre combattere con l&rsquo;impulso di avere &ldquo;tutto e subito&rdquo;: non possiamo pensare di scrivere un prompt e avere il software pronto. Bisogna realmente applicare un certo livello di effort e utilizzare per davvero le skills che citavamo sopra. Come raccontavo nell&rsquo;introduzione, la giornata &ldquo;persa&rdquo; a scrivere specifiche mi ha risparmiato circa due settimane di lavoro. Ma la sensazione iniziale era esattamente quella: di perdere tempo. √à un investimento controintuitivo, e il mindset giusto consiste proprio nell&rsquo;accettarlo.</p><h2 id=concetti-di-base>Concetti di base<a hidden class=anchor aria-hidden=true href=#concetti-di-base>#</a></h2><h3 id=context-window>Context window<a hidden class=anchor aria-hidden=true href=#context-window>#</a></h3><p>La maggior parte delle persone pensa: &ldquo;pi√π cose metto dentro il contesto, meglio √®&rdquo;. √à un&rsquo;idea che pu√≤ portare fuori strada, e capire il perch√© richiede un minimo di comprensione di come funzionano i modelli.</p><p>Gli LLM sono modelli autoregressivi basati sull&rsquo;architettura Transformer. Il cuore di questa architettura √® il meccanismo di <strong>self-attention</strong>: per ogni token generato, il modello calcola un punteggio di &ldquo;attenzione&rdquo; rispetto a <em>tutti</em> i token precedenti nel contesto. Questo ha due implicazioni pratiche importanti:</p><ol><li><p><strong>Complessit√† quadratica</strong>: il costo computazionale dell&rsquo;attenzione cresce come O(n¬≤) rispetto alla lunghezza del contesto. Raddoppiare il contesto quadruplica il costo. Questo non √® solo un problema di latenza e di costi (che pure sono rilevanti), ma degrada la qualit√† stessa dell&rsquo;output.</p></li><li><p><strong>&ldquo;Lost in the middle&rdquo;</strong>: diversi studi (tra cui il noto paper di Liu et al., 2023) hanno dimostrato che gli LLM tendono a prestare maggiore attenzione alle informazioni che si trovano all&rsquo;inizio e alla fine del contesto, &ldquo;dimenticando&rdquo; quelle centrali. In pratica, se la specifica cruciale della tua API si trova a met√† di una conversazione da 80.000 token, il modello potrebbe semplicemente non tenerla in considerazione.</p></li></ol><p>Sebbene l&rsquo;interfaccia degli LLM si presenti come una chat, dobbiamo sempre valutare ogni singola interazione come se fosse un <strong>task isolato</strong>, che si porta dietro una storia conversazionale che spesso √® inutile, inquina la context window e porta il modello fuori strada. Questo fenomeno si chiama <em>Context Bloat</em>.</p><h3 id=context-engineering>Context Engineering<a hidden class=anchor aria-hidden=true href=#context-engineering>#</a></h3><p>Il termine &ldquo;Context Engineering&rdquo; viene spesso confuso con il prompt engineering, ma sono concetti distinti. Il prompt engineering riguarda la formulazione della singola richiesta all&rsquo;LLM. Il Context Engineering √® qualcosa di pi√π ampio: √® il controllo sistematico di <strong>tutto ci√≤ che entra nella context window</strong> del modello ‚Äî system prompt, istruzioni persistenti (come il <code>CLAUDE.md</code>), risultati di tool, file di codice caricati, memoria delle interazioni precedenti, e solo in ultimo il prompt dell&rsquo;utente.</p><p>Pensate al contesto come a un <strong>programma</strong>: ogni elemento che vi inserite √® un&rsquo;istruzione che il modello eseguir√† (o tenter√† di eseguire). Pi√π istruzioni contraddittorie o irrilevanti inserite, pi√π il &ldquo;programma&rdquo; diventa imprevedibile.</p><p>Con questa prospettiva, le tecniche di SDD sono essenzialmente tecniche di Context Engineering: massimizzano l&rsquo;efficacia della context window rendendo modulare lo sviluppo (SPEC ‚Üí PIANO ‚Üí CLARIFY ‚Üí IMPLEMENTATION) e soprattutto minimizzando il rumore. Ogni fase opera in un contesto pulito e dedicato, con solo le informazioni rilevanti per quel task specifico.</p><h3 id=divide-et-impera>Divide et impera<a hidden class=anchor aria-hidden=true href=#divide-et-impera>#</a></h3><p>Nell&rsquo;ambito dello sviluppo software, molti (anche molti <strong>sviluppatori</strong> di oggi) pensano che l&rsquo;LLM serva solo per scrivere il codice, mentre le tecniche di SDD si basano sull&rsquo;assunto che il Progettista utilizzi l&rsquo;LLM <strong>su tutta la pipeline</strong> di lavoro del software.</p><table><thead><tr><th>Fase</th><th>Obiettivo</th><th>Utilizzo LLM</th></tr></thead><tbody><tr><td>Ideazione</td><td>Esplorazione dello <strong>spazio delle soluzioni</strong></td><td>Per un determinato problema, esiste un numero potenzialmente infinito di soluzioni e gli LLM sono uno strumento formidabile per esplorarle</td></tr><tr><td>Specifiche</td><td>Definizione dettagliata dei requisiti utente</td><td>Oltre a definire le specifiche di dettaglio, in questa fase vengono anche individuati eventuali gap e aree di ambiguit√†</td></tr><tr><td>Disegno</td><td>Avere una solida baseline su cui scrivere il codice senza &ldquo;improvvisare&rdquo;</td><td>Ricerca, espansione, approfondimento e selezione delle componenti software da creare/modificare e del piano di sviluppo e della modalit√† di test</td></tr><tr><td>Implementazione</td><td>Tradurre il disegno in codice</td><td>Scrittura del codice e dei test</td></tr><tr><td>Test</td><td>Verifica del software</td><td>Esecuzione dei test e identificazione dei bug</td></tr></tbody></table><div class="callout callout-tip"><div class=callout-title>üí° Tip</div><div class=callout-content><ul><li>Per ogni fase, vale la pena valutare di volta in volta l&rsquo;LLM pi√π adatto. Ad esempio, al momento della scrittura Claude Opus 4.6 √® tra i pi√π performanti nel coding puro, ma modelli come le ultime versioni di ChatGPT, Gemini 3 o Kimi k2.5 possono essere pi√π efficaci e creativi nelle fasi di esplorazione delle soluzioni.</li><li>Riutilizzare lo stesso contesto per un intero ciclo di sviluppo √® fortemente sconsigliato, anche se il modello supporta milioni di token. Il motivo √® il Context Bloat discusso sopra: le decisioni architetturali della fase di Piano, i dettagli delle user story della fase di Specifica, e il codice della fase di Implementazione competono tutti per l&rsquo;attenzione del modello. Il risultato √® un degrado progressivo della qualit√† su <em>tutte</em> le fasi, non solo sull&rsquo;ultima.</li></ul></div></div><style>.callout{border-left:4px solid;padding:1rem;margin:1.5rem 0;border-radius:4px;background-color:var(--callout-bg)}.callout-title{font-weight:700;margin-bottom:.5rem}.callout-note{border-color:#0969da;background-color:#ddf4ff}.callout-tip{border-color:#1a7f37;background-color:#dcffe4}.callout-important{border-color:#8250df;background-color:#fbefff}.callout-warning{border-color:#9a6700;background-color:#fff8c5}.callout-caution{border-color:#cf222e;background-color:#ffebe9}[data-theme=dark] .callout-note,.dark .callout-note{background-color:#0969da1a;color:#e6edf3}[data-theme=dark] .callout-tip,.dark .callout-tip{background-color:#1a7f371a;color:#e6edf3}[data-theme=dark] .callout-important,.dark .callout-important{background-color:#8250df1a;color:#e6edf3}[data-theme=dark] .callout-warning,.dark .callout-warning{background-color:#9a67001a;color:#e6edf3}[data-theme=dark] .callout-caution,.dark .callout-caution{background-color:#cf222e1a;color:#e6edf3}</style><h2 id=cos√®-lsdd>Cos&rsquo;√® l&rsquo;SDD<a hidden class=anchor aria-hidden=true href=#cos√®-lsdd>#</a></h2><p>La <strong>Spec-Driven Development</strong> (SDD) √® un paradigma che tratta le <strong>specifiche come fonte primaria di verit√†</strong> di un sistema software. Il codice diventa un artefatto secondario, generato o verificato rispetto alla specifica. Invece del classico approccio &ldquo;scrivi il codice prima, documenta dopo&rdquo;, l&rsquo;SDD inverte il flusso: si scrivono specifiche chiare e strutturate del comportamento atteso e poi si genera, implementa o verifica il codice rispetto ad esse.</p><p>In altre parole: <strong>la specifica √® il prodotto, il codice √® un sottoprodotto</strong>.</p><p>Questo concetto non √® nuovo in assoluto. L&rsquo;API-first development con OpenAPI, il BDD (Behavior-Driven Development) e i contract-driven testing esistono da anni. Ci√≤ che cambia oggi √® che gli LLM rendono possibile <strong>automatizzare l&rsquo;intero flusso</strong>: dalla specifica al piano tecnico, dal piano ai task, dai task al codice, dal codice ai test. La specifica diventa un vero e proprio <em>control plane</em> che orchestra agenti AI e sviluppatori umani.</p><p>Un <a href=https://www.arxiv.org/pdf/2602.00180.pdf>recente paper su arXiv</a> formalizza l&rsquo;SDD cos√¨: <em>&ldquo;Le specifiche sono la fonte di verit√†; il codice deriva da esse. La specifica √® la descrizione autoritativa che umani e macchine usano per comprendere, costruire e far evolvere il sistema.&rdquo;</em></p><h3 id=i-livelli-dellsdd>I livelli dell&rsquo;SDD<a hidden class=anchor aria-hidden=true href=#i-livelli-dellsdd>#</a></h3><p>Non esiste un unico modo di applicare l&rsquo;SDD. Si possono identificare tre livelli di rigore:</p><ul><li><strong>Spec-first</strong>: la specifica viene scritta prima dell&rsquo;implementazione e guida lo sviluppo iniziale. Ideale per nuovi servizi, API o feature con pi√π consumatori.</li><li><strong>Spec-anchored</strong>: specifica e codice evolvono insieme, mantenuti in sincronia tramite test e validazione. √à il livello pi√π pratico per la maggior parte dei team in produzione.</li><li><strong>Spec-as-source</strong>: gli umani editano solo le specifiche; il codice viene generato da esse. Adatto a domini altamente regolamentati o strutturati dove la tracciabilit√† dal requisito al codice deve essere rigorosa.</li></ul><p>La maggior parte dei team trover√† nello <strong>spec-anchored</strong> il giusto compromesso tra rigore e agilit√†.</p><h3 id=overview-dei-principali-framework>Overview dei principali framework<a hidden class=anchor aria-hidden=true href=#overview-dei-principali-framework>#</a></h3><p>L&rsquo;ecosistema di strumenti per l&rsquo;SDD si sta sviluppando rapidamente. Ecco i tre framework pi√π rilevanti:</p><h4 id=spec-kit-github>Spec Kit (GitHub)<a hidden class=anchor aria-hidden=true href=#spec-kit-github>#</a></h4><p><a href=https://github.com/github/spec-kit>Spec Kit</a> √® il toolkit open-source di GitHub per l&rsquo;SDD. Propone un workflow multi-fase (<code>Specify ‚Üí Plan ‚Üí Tasks ‚Üí Implement</code>) e genera artefatti Markdown versionati nel repository. √à compatibile con GitHub Copilot, Claude Code, Cursor e Gemini CLI. Approfondiremo Spec Kit nel prossimo capitolo.</p><h4 id=openspec-fission-ai>OpenSpec (Fission AI)<a hidden class=anchor aria-hidden=true href=#openspec-fission-ai>#</a></h4><p><a href=https://openspec.pro/>OpenSpec</a> √® un framework leggero e open-source (TypeScript) pensato per portare determinismo nello sviluppo AI. Le sue caratteristiche distintive:</p><ul><li><strong>Delta Specs</strong>: cattura i cambiamenti incrementali nei requisiti, anzich√© riscrivere l&rsquo;intera specifica</li><li><strong>Brownfield-first</strong>: progettato per evolvere codebase esistenti, non solo per progetti greenfield</li><li><strong>Nessuna API key o installazione complessa</strong>: le specifiche vivono nel repository accanto al codice</li><li>Supporta oltre 20 strumenti, tra cui Claude Code, Cursor e GitHub Copilot</li></ul><h4 id=bmad-method>BMAD Method<a hidden class=anchor aria-hidden=true href=#bmad-method>#</a></h4><p>Il <a href=https://github.com/bmad-code-org/BMAD-METHOD>BMAD Method</a> (Breakthrough Method for Agile AI-Driven Development) √® un framework open-source pi√π ambizioso, con:</p><ul><li><strong>21 agenti AI specializzati</strong> (Analyst, Product Manager, Architect, Developer, QA, Scrum Master, &mldr;) ognuno con ruoli e responsabilit√† definiti</li><li><strong>50+ workflow guidati</strong> per diversi tipi di progetto e fasi</li><li><strong>Architettura multi-agente</strong>: gli agenti collaborano dall&rsquo;ideazione all&rsquo;implementazione</li><li>Compatibile con Claude Code, Cursor, Windsurf e altri IDE AI</li></ul><p>Ecco una guida rapida per orientarsi nella scelta:</p><table><thead><tr><th>Criterio</th><th>Spec Kit</th><th>OpenSpec</th><th>BMAD</th></tr></thead><tbody><tr><td>Complessit√† di setup</td><td>Bassa (CLI + Markdown)</td><td>Molto bassa (file nel repo)</td><td>Media-alta (21 agenti da configurare)</td></tr><tr><td>Ideale per</td><td>Progetti greenfield con GitHub</td><td>Evoluzione di codebase esistenti</td><td>Progetti enterprise con team strutturati</td></tr><tr><td>Curva di apprendimento</td><td>~1 ora</td><td>~30 minuti</td><td>~1 giorno</td></tr><tr><td>Lock-in</td><td>Basso (Markdown + Git)</td><td>Nessuno (file nel repo)</td><td>Medio (dipendenza dal framework)</td></tr><tr><td>Supporto brownfield</td><td>Limitato</td><td>Eccellente (Delta Specs)</td><td>Buono</td></tr></tbody></table><p>In generale: partite con <strong>Spec Kit</strong> se usate GitHub e volete un workflow strutturato ma leggero. Scegliete <strong>OpenSpec</strong> se dovete evolvere una codebase esistente senza stravolgere il workflow. Valutate <strong>BMAD</strong> solo se il vostro progetto richiede coordinamento multi-ruolo e avete il budget di tempo per configurare l&rsquo;intera orchestra di agenti.</p><h3 id=deep-dive-su-spec-kit>Deep dive su Spec Kit<a hidden class=anchor aria-hidden=true href=#deep-dive-su-spec-kit>#</a></h3><p>Spec Kit merita un approfondimento perch√© rappresenta lo stato dell&rsquo;arte dell&rsquo;SDD applicata ai coding agent ed √® sostenuto direttamente da GitHub e Microsoft.</p><p>Il workflow di Spec Kit si articola in passi ben definiti, ognuno con un comando dedicato:</p><p><strong>1. Costituzione del progetto (<code>/speckit.constitution</code>)</strong></p><p>Si definiscono i principi non-negoziabili del progetto: standard di codifica, requisiti di test, regole di sicurezza, principi UX, target di performance. La <em>constitution</em> viene consultata automaticamente in ogni fase successiva come vincolo.</p><p><strong>2. Specifica funzionale (<code>/speckit.specify</code>)</strong></p><p>Si trasforma un&rsquo;idea in una specifica funzionale strutturata: user story, requisiti funzionali, criteri di accettazione. Nessun dettaglio tecnico qui ‚Äî solo il <em>cosa</em> e il <em>perch√©</em>. Spec Kit crea automaticamente un branch Git dedicato alla feature.</p><p><strong>3. Chiarificazione (<code>/speckit.clarify</code>)</strong></p><p>L&rsquo;agente AI pone domande strutturate per eliminare ambiguit√† dalla specifica: casi limite, vincoli, gestione degli errori, permessi. Questa fase √® fondamentale: una specifica ambigua produce codice ambiguo.</p><p><strong>4. Piano tecnico (<code>/speckit.plan</code>)</strong></p><p>La specifica validata viene tradotta in un piano tecnico dettagliato: decisioni architetturali, modelli dati, API, integrazioni. Qui si sceglie lo stack, i pattern e le interfacce. Gli artefatti generati includono <code>plan.md</code>, <code>data-model.md</code>, e una cartella <code>contracts/</code> con le specifiche API.</p><p><strong>5. Validazione (<code>/speckit.checklist</code>, <code>/speckit.analyze</code>)</strong></p><p>Controllo di qualit√† e coerenza tra tutti gli artefatti prima di scrivere codice. Si verificano inconsistenze, gap e problemi di qualit√†.</p><p><strong>6. Scomposizione in task (<code>/speckit.tasks</code>)</strong></p><p>Il piano viene scomposto in unit√† di lavoro piccole e reviewable: ogni task ha input, output e criteri di successo espliciti legati alla specifica. I task sono ordinati per dipendenze e quelli parallelizzabili sono marcati.</p><p><strong>7. Implementazione (<code>/speckit.implement</code>)</strong></p><p>L&rsquo;agente AI esegue i task, generando e modificando codice, test e configurazioni secondo il piano. Il codice viene prodotto in piccoli diff, facilmente reviewable.</p><h3 id=un-esempio-pratico>Un esempio pratico<a hidden class=anchor aria-hidden=true href=#un-esempio-pratico>#</a></h3><p>Immaginiamo di voler sviluppare una semplice API per la gestione di una libreria di libri. Ecco come si svolgerebbe il flusso con Spec Kit:</p><p><strong>Fase 1 - Constitution:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>/speckit.constitution
</span></span><span class=line><span class=cl>Il progetto segue un approccio API-first. Usiamo Python con FastAPI.
</span></span><span class=line><span class=cl>Ogni endpoint deve avere test unitari. Sicurezza: autenticazione JWT.
</span></span><span class=line><span class=cl>Database PostgreSQL con Alembic per le migrazioni.
</span></span></code></pre></div><p><strong>Fase 2 - Specify:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>/speckit.specify
</span></span><span class=line><span class=cl>Costruire un&#39;API REST per gestire una libreria di libri.
</span></span><span class=line><span class=cl>Gli utenti possono cercare libri per titolo, autore o ISBN.
</span></span><span class=line><span class=cl>Gli amministratori possono aggiungere, modificare e rimuovere libri.
</span></span><span class=line><span class=cl>Ogni libro ha: titolo, autore, ISBN, anno di pubblicazione, genere.
</span></span><span class=line><span class=cl>Include user story e criteri di accettazione.
</span></span></code></pre></div><p>A questo punto Spec Kit genera un file <code>spec.md</code> strutturato con user story del tipo:</p><ul><li><em>Come utente, voglio cercare libri per titolo, cos√¨ da trovare rapidamente il libro che mi interessa</em></li><li><em>Come amministratore, voglio aggiungere un nuovo libro al catalogo, specificando tutti i metadati</em></li></ul><p><strong>Fase 3 - Clarify:</strong> L&rsquo;agente chiede ad esempio: &ldquo;Ci sono limiti sul numero di risultati per pagina? Cosa succede se si tenta di inserire un ISBN duplicato? Quali campi sono obbligatori?&rdquo;</p><p><strong>Fase 4 - Plan:</strong> Viene generato un piano tecnico. Ecco un estratto realistico del <code>plan.md</code> generato:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gh># Piano Tecnico - API Libreria
</span></span></span><span class=line><span class=cl><span class=gh></span>
</span></span><span class=line><span class=cl><span class=gu>## Architettura
</span></span></span><span class=line><span class=cl><span class=gu></span><span class=k>-</span> Framework: FastAPI con Pydantic v2 per validazione
</span></span><span class=line><span class=cl><span class=k>-</span> Database: PostgreSQL 16 con SQLAlchemy 2.0 (async)
</span></span><span class=line><span class=cl><span class=k>-</span> Migrazioni: Alembic con autogenerate
</span></span><span class=line><span class=cl><span class=k>-</span> Auth: JWT (access token 15min + refresh token 7d)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Modello Dati
</span></span></span><span class=line><span class=cl><span class=gu></span>
</span></span><span class=line><span class=cl><span class=gu>### Book
</span></span></span><span class=line><span class=cl><span class=gu></span>| Campo        | Tipo         | Vincoli                    |
</span></span><span class=line><span class=cl>|-------------|-------------|---------------------------|
</span></span><span class=line><span class=cl>| id          | UUID        | PK, auto-generato         |
</span></span><span class=line><span class=cl>| title       | VARCHAR(255)| NOT NULL, INDEX            |
</span></span><span class=line><span class=cl>| author      | VARCHAR(255)| NOT NULL, INDEX            |
</span></span><span class=line><span class=cl>| isbn        | VARCHAR(13) | UNIQUE, NOT NULL           |
</span></span><span class=line><span class=cl>| year        | INTEGER     | CHECK (year &gt;= 1450)       |
</span></span><span class=line><span class=cl>| genre       | VARCHAR(100)| NULL                       |
</span></span><span class=line><span class=cl>| created_at  | TIMESTAMP   | DEFAULT now()              |
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Endpoint REST
</span></span></span><span class=line><span class=cl><span class=gu></span><span class=k>-</span> <span class=sb>`GET /books?title=&amp;author=&amp;isbn=&amp;page=1&amp;size=20`</span> ‚Üí 200 + paginazione
</span></span><span class=line><span class=cl><span class=k>-</span> <span class=sb>`GET /books/{id}`</span> ‚Üí 200 | 404
</span></span><span class=line><span class=cl><span class=k>-</span> <span class=sb>`POST /books`</span> ‚Üí 201 | 400 (validazione) | 409 (ISBN duplicato)
</span></span><span class=line><span class=cl><span class=k>-</span> <span class=sb>`PUT /books/{id}`</span> ‚Üí 200 | 404
</span></span><span class=line><span class=cl><span class=k>-</span> <span class=sb>`DELETE /books/{id}`</span> ‚Üí 204 | 404
</span></span><span class=line><span class=cl><span class=k>-</span> Tutti i metodi POST/PUT/DELETE richiedono header <span class=sb>`Authorization: Bearer &lt;token&gt;`</span>
</span></span></code></pre></div><p>Notare il livello di dettaglio: tipi, vincoli, codici di risposta, regole di autenticazione. Non c&rsquo;√® ambiguit√†, e l&rsquo;agente AI che ricever√† questo piano non dovr√† &ldquo;indovinare&rdquo; nulla.</p><p><strong>Fase 5-6 - Checklist & Tasks:</strong> Vengono generati task come:</p><ol><li>Creare i modelli SQLAlchemy (Book, User)</li><li>Configurare Alembic e creare la migrazione iniziale</li><li>Implementare l&rsquo;endpoint <code>GET /books</code> con filtri e paginazione</li><li>Implementare l&rsquo;endpoint <code>POST /books</code> con validazione</li><li>Aggiungere autenticazione JWT</li><li>Scrivere i test per ogni endpoint</li></ol><p>Ogni task ha input, output e criteri di successo espliciti. I task parallelizzabili sono marcati con <code>[P]</code>, quelli sequenziali sono ordinati per dipendenze.</p><p><strong>Fase 7 - Implement:</strong> L&rsquo;agente esegue ogni task, producendo codice e test verificabili.</p><p>Il punto chiave √® che ogni fase produce artefatti Markdown versionati nel repository, creando una tracciabilit√† completa dall&rsquo;idea al codice. Se tra sei mesi qualcuno chiede &ldquo;perch√© questa API funziona cos√¨?&rdquo;, la risposta √® nella specifica.</p><h2 id=coding-agents>Coding Agents<a hidden class=anchor aria-hidden=true href=#coding-agents>#</a></h2><p>L&rsquo;SDD √® la metodologia, ma per metterla in pratica servono gli strumenti giusti. I <strong>coding agent</strong> sono la componente operativa di questo nuovo paradigma: agenti AI che non si limitano al completamento automatico, ma pianificano task, modificano codebase, eseguono test e collaborano attraverso i workflow DevOps esistenti.</p><h3 id=come-funziona-un-coding-agent-sotto-il-cofano>Come funziona un coding agent (sotto il cofano)<a hidden class=anchor aria-hidden=true href=#come-funziona-un-coding-agent-sotto-il-cofano>#</a></h3><p>Prima di passare in rassegna gli strumenti, vale la pena capire cosa distingue un &ldquo;agente&rdquo; da un semplice chatbot. Un coding agent opera secondo un <strong>loop agentico</strong> continuo, che in pseudo-codice si pu√≤ rappresentare cos√¨:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>while</span> <span class=n>task</span> <span class=ow>is</span> <span class=ow>not</span> <span class=n>complete</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>context</span>  <span class=o>=</span> <span class=n>gather</span><span class=p>(</span><span class=n>specs</span><span class=p>,</span> <span class=n>code</span><span class=p>,</span> <span class=n>test_results</span><span class=p>,</span> <span class=n>errors</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>plan</span>     <span class=o>=</span> <span class=n>reason</span><span class=p>(</span><span class=n>context</span><span class=p>)</span>           <span class=c1># l&#39;LLM decide cosa fare</span>
</span></span><span class=line><span class=cl>    <span class=n>action</span>   <span class=o>=</span> <span class=n>select_tool</span><span class=p>(</span><span class=n>plan</span><span class=p>)</span>         <span class=c1># scelta del tool: edit, bash, search...</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span>   <span class=o>=</span> <span class=n>execute</span><span class=p>(</span><span class=n>action</span><span class=p>)</span>           <span class=c1># esecuzione reale nel filesystem/terminale</span>
</span></span><span class=line><span class=cl>    <span class=n>feedback</span> <span class=o>=</span> <span class=n>verify</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>            <span class=c1># test, lint, output del comando</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>feedback</span><span class=o>.</span><span class=n>has_errors</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>context</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>feedback</span><span class=p>)</span>         <span class=c1># l&#39;errore diventa input per il prossimo ciclo</span>
</span></span></code></pre></div><p>Il meccanismo chiave √® il <strong>tool use</strong> (o function calling): l&rsquo;LLM non genera solo testo, ma emette chiamate strutturate a strumenti esterni ‚Äî editor di file, terminale bash, browser, API. Questo gli permette di interagire con il mondo reale: leggere un file, modificarlo, eseguire i test e reagire ai risultati.</p><p>La differenza fondamentale tra i vari agenti sul mercato sta in <em>quali tool</em> hanno a disposizione e in <em>quale ambiente</em> operano:</p><ul><li><strong>Agenti con accesso diretto al filesystem</strong> (Claude Code, Cursor): operano sulla tua macchina, con accesso completo a terminale e file. Massima flessibilit√†, ma richiedono supervisione.</li><li><strong>Agenti in sandbox isolata</strong> (Devin, GitHub Copilot coding agent): operano in un ambiente cloud dedicato. Pi√π sicuri per l&rsquo;autonomia completa, ma meno flessibili per workflow personalizzati.</li></ul><p>Il panorama dei coding agent si √® evoluto rapidamente e oggi possiamo distinguere diverse categorie:</p><h3 id=agenti-integrati-nellecosistema>Agenti integrati nell&rsquo;ecosistema<a hidden class=anchor aria-hidden=true href=#agenti-integrati-nellecosistema>#</a></h3><ul><li><strong>GitHub Copilot coding agent</strong>: lavora direttamente nel workflow delle Pull Request. Puoi assegnare una issue a <code>@copilot</code> e l&rsquo;agente pianifica, modifica il codice, esegue i test e apre una PR autonomamente. √à il target nativo di Spec Kit.</li><li><strong>Amazon Q Developer</strong>: l&rsquo;assistente AI di AWS, particolarmente forte per lo sviluppo cloud-native, IaC e le trasformazioni applicative (es. migrazione Java 8‚Üí17).</li><li><strong>Google Gemini Code Assist</strong>: forte integrazione con i servizi Google Cloud (BigQuery, Firebase, Apigee). Supportato esplicitamente da Spec Kit come target SDD.</li></ul><h3 id=agenti-editor-first>Agenti editor-first<a hidden class=anchor aria-hidden=true href=#agenti-editor-first>#</a></h3><ul><li><strong>Cursor</strong>: un fork di VS Code nativamente AI-first. La modalit√† Agentic + Composer permette di pianificare task multi-step, modificare pi√π file, eseguire comandi nel terminale e iterare fino al superamento dei test.</li><li><strong>JetBrains AI Assistant & Junie</strong>: integrato in tutti gli IDE JetBrains, Junie offre programmazione agentica per implementare fix, refactoring e test.</li></ul><h3 id=piattaforme-agente>Piattaforme agente<a hidden class=anchor aria-hidden=true href=#piattaforme-agente>#</a></h3><ul><li><strong>Claude Code / Claude Agent SDK</strong>: piattaforma di Anthropic basata sul principio &ldquo;dai all&rsquo;agente un computer&rdquo;. Claude Code ha accesso a terminale e file system e opera con un ciclo continuo: <em>raccogli contesto ‚Üí agisci ‚Üí verifica ‚Üí ripeti</em>. L&rsquo;Agent SDK permette di costruire agenti personalizzati.</li><li><strong>Devin (Cognition)</strong>: agente completamente autonomo con il proprio ambiente di sviluppo integrato (shell, editor, browser). Ancora sperimentale e poco &ldquo;enterprise&rdquo;</li></ul><h3 id=quale-agente-scegliere>Quale agente scegliere?<a hidden class=anchor aria-hidden=true href=#quale-agente-scegliere>#</a></h3><p>Per un&rsquo;azienda che vuole adottare l&rsquo;SDD oggi, un approccio pragmatico √®:</p><ul><li><strong>GitHub Copilot</strong> o <strong>Amazon Q</strong> per il lavoro issue/PR-driven sui servizi core</li><li><strong>Gemini Code Assist</strong> per workflow SDD su analytics e integrazioni GCP</li><li><strong>Cursor</strong> o <strong>JetBrains</strong> nell&rsquo;IDE per implementazione ad alta fedelt√† dalle specifiche</li><li><strong>Claude Code / Agent SDK</strong> per pipeline SDD personalizzate dove gli strumenti standard sono troppo rigidi</li></ul><h3 id=il-valore-aggiunto-dei-file-istruzione-claudemd>Il valore aggiunto dei file istruzione: CLAUDE.md<a hidden class=anchor aria-hidden=true href=#il-valore-aggiunto-dei-file-istruzione-claudemd>#</a></h3><p>Uno dei concetti pi√π potenti emersi con i coding agent √® quello dei <strong>file di istruzione persistente</strong>: file Markdown che l&rsquo;agente legge automaticamente all&rsquo;inizio di ogni sessione per comprendere il contesto del progetto. Ogni agente ha il suo formato (<code>.github/copilot-instructions.md</code> per Copilot, <code>.cursorrules</code> per Cursor, ecc.), ma il pi√π noto e maturo √® il <code>CLAUDE.md</code> di Claude Code.</p><h3 id=che-cos√®-claudemd>Che cos&rsquo;√® CLAUDE.md<a hidden class=anchor aria-hidden=true href=#che-cos√®-claudemd>#</a></h3><p><code>CLAUDE.md</code> √® un file di istruzione specifico per progetto che Claude Code legge automaticamente all&rsquo;avvio in una directory. Il suo scopo √®:</p><ul><li>Dare a Claude il <strong>contesto minimo</strong> che non pu√≤ inferire dal codice</li><li>Codificare <strong>regole critiche e caveat</strong> che devono essere rispettati in ogni task</li><li>Migliorare affidabilit√† e velocit√† evitando spiegazioni ripetute</li></ul><p>Va pensato come un <strong>system prompt curato con attenzione</strong>, non come una wiki. √à un <strong>contratto vivente</strong> tra la codebase e gli agenti AI.</p><h3 id=come-impostare-un-buon-claudemd>Come impostare un buon CLAUDE.md<a hidden class=anchor aria-hidden=true href=#come-impostare-un-buon-claudemd>#</a></h3><p>Le best practice, confermate sia dalla documentazione Anthropic che dalla esperienza empirica della Community, convergono su alcuni principi chiave.
Questi principi non sono specifici di Claude Code ma derivano dalle caratteristiche generali degli LLM, di conseguenza valgono per qualsiasi assistente o coding Agent, anche se il formato specifico pu√≤ variare a seconda dello strumento.</p><p><strong>1. Less is more</strong></p><p>Ogni riga aggiuntiva pu√≤ <em>ridurre</em> la qualit√† complessiva del rispetto delle istruzioni. Gli LLM possono seguire con alta fedelt√† solo un numero limitato di istruzioni distinte. Quando ce ne sono troppe, l&rsquo;aderenza a <em>tutte</em> le regole degrada ‚Äî non vengono ignorate le ultime, peggiorano tutte.</p><p><strong>2. Alto segnale, basso rumore</strong></p><p>Includere solo informazioni che sono:</p><ul><li>Difficili da inferire per Claude leggendo il codice</li><li>Rilevanti per la grande maggioranza dei task quotidiani</li></ul><p><strong>3. La struttura minima efficace</strong></p><p>Un buon <code>CLAUDE.md</code> contiene tipicamente tre blocchi:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gh># CLAUDE.md
</span></span></span><span class=line><span class=cl><span class=gh></span>
</span></span><span class=line><span class=cl><span class=gu>## Progetto
</span></span></span><span class=line><span class=cl><span class=gu></span>Questo √® un portale e-commerce Next.js + TypeScript che comunica
</span></span><span class=line><span class=cl>con le nostre API interne di pagamento e catalogo.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Comandi chiave
</span></span></span><span class=line><span class=cl><span class=gu></span><span class=k>-</span> Installare dipendenze: <span class=sb>`pnpm install`</span>
</span></span><span class=line><span class=cl><span class=k>-</span> Dev server: <span class=sb>`pnpm dev`</span>
</span></span><span class=line><span class=cl><span class=k>-</span> Build: <span class=sb>`pnpm build`</span>
</span></span><span class=line><span class=cl><span class=k>-</span> Test: <span class=sb>`pnpm test`</span>
</span></span><span class=line><span class=cl><span class=k>-</span> Lint: <span class=sb>`pnpm lint`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Caveat IMPORTANTI
</span></span></span><span class=line><span class=cl><span class=gu></span><span class=k>-</span> IMPORTANTE: Non modificare <span class=sb>`prisma/schema.prisma`</span> direttamente.
</span></span><span class=line><span class=cl>  Usare <span class=sb>`pnpm db:migrate`</span> e <span class=sb>`pnpm db:generate`</span>.
</span></span><span class=line><span class=cl><span class=k>-</span> IMPORTANTE: L&#39;endpoint <span class=sb>`/api/webhooks/stripe`</span> si aspetta il body
</span></span><span class=line><span class=cl>  raw della request. NON usare un body parser.
</span></span><span class=line><span class=cl><span class=k>-</span> Le immagini in <span class=sb>`public/`</span> devono essere ottimizzate prima del commit;
</span></span><span class=line><span class=cl>  file &gt; 200KB faranno fallire la CI.
</span></span></code></pre></div><p><strong>4. Non mettere regole di stile</strong></p><p>Regole come &ldquo;usa due spazi per l&rsquo;indentazione&rdquo; o &ldquo;usa single quotes&rdquo; sono uno spreco di istruzioni: Claude le inferisce dal codice esistente, e comunque linter e formatter le gestiscono meglio.</p><p><strong>5. Disclosure progressiva</strong></p><p>Per informazioni dettagliate ma raramente necessarie, non appesantire il file principale. Piuttosto:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gu>## Documentazione aggiuntiva
</span></span></span><span class=line><span class=cl><span class=gu></span><span class=k>-</span> Schema database e migrazioni: leggere <span class=sb>`docs/schema.md`</span> quando
</span></span><span class=line><span class=cl>  si modificano i modelli.
</span></span></code></pre></div><p>Claude aprir√† <code>docs/schema.md</code> solo quando necessario, invece di caricarlo ad ogni task.</p><p><strong>6. Regole path-specific con <code>.claude/rules/</code></strong></p><p>Claude Code supporta file di istruzione specifici per path:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gh># .claude/rules/tests.md
</span></span></span><span class=line><span class=cl><span class=gh></span>paths: [&#34;**/*.spec.ts&#34;, &#34;**/*.test.ts&#34;]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Regole di test
</span></span></span><span class=line><span class=cl><span class=gu></span><span class=k>-</span> Usare Vitest, non Jest.
</span></span><span class=line><span class=cl><span class=k>-</span> Usare gli helper in <span class=sb>`test-utils/`</span> per il rendering dei componenti.
</span></span></code></pre></div><p>Questo file viene caricato solo quando Claude lavora su file di test, mantenendo il <code>CLAUDE.md</code> globale pi√π snello.</p><p><strong>7. Manutenzione continua</strong></p><p>Trattare <code>CLAUDE.md</code> come un documento vivente: aggiornarlo quando si nota che Claude ripete errori evitabili, rimuovere istruzioni obsolete, riordinare per importanza. Le regole pi√π importanti vanno sempre <strong>in cima al file</strong>.</p><h2 id=limiti-e-rischi-dellsdd>Limiti e rischi dell&rsquo;SDD<a hidden class=anchor aria-hidden=true href=#limiti-e-rischi-dellsdd>#</a></h2><p>Sarebbe disonesto presentare l&rsquo;SDD come una soluzione priva di criticit√†. Ci sono limiti concreti che √® bene conoscere prima di adottarla:</p><ul><li><strong>Non-determinismo.</strong> Gli LLM non sono deterministici: la stessa specifica, data allo stesso modello in due momenti diversi, pu√≤ produrre codice strutturalmente diverso. Questo significa che l&rsquo;SDD non garantisce riproducibilit√†. La specifica riduce drasticamente la varianza rispetto a un prompt generico, ma non la elimina. Per questo i contract test e la validazione automatica sono indispensabili ‚Äî sono il &ldquo;guardrail deterministico&rdquo; che compensa la natura probabilistica del modello.
Allo stesso tempo, per√≤, vale la pena riflettere sul fatto che, in generale, lo stesso concetto vale anche per gli esseri umani: lo stesso sviluppatore, leggendo la stessa specifica in due momenti diversi, pu√≤ scrivere codice diverso.</li><li><strong>Garbage in, garbage out (spostato di livello).</strong> Se uso un LLM per generare le specifiche stesse, chi le valida? Il rischio √® di automatizzare la produzione di specifiche plausibili ma errate ‚Äî ad esempio, un modello dati che sembra ragionevole ma viola una regola di business non esplicitata. La revisione umana delle specifiche non √® opzionale: √® il punto di controllo critico dell&rsquo;intero workflow.</li><li><strong>Scalabilit√†.</strong> L&rsquo;esempio della libreria di libri funziona bene, ma cosa succede con un sistema distribuito di 200 microservizi? L&rsquo;SDD scala bene fino a quando le specifiche restano modularizzabili ‚Äî un servizio alla volta, una feature alla volta. Quando le dipendenze cross-service diventano troppo intricate, le specifiche rischiano di diventare esse stesse un problema di manutenzione. Non √® un motivo per non adottare l&rsquo;SDD, ma √® un motivo per non pensarla come una bacchetta magica.</li><li><strong>Costi.</strong> Un workflow SDD completo (specify ‚Üí clarify ‚Üí plan ‚Üí tasks ‚Üí implement) consuma significativamente pi√π token di un singolo prompt. Ogni fase √® una o pi√π chiamate all&rsquo;LLM, ognuna con il proprio contesto. Su modelli di punta come Claude Opus o GPT-4, un ciclo completo per una feature di media complessit√† pu√≤ costare tra i 5 e i 20 dollari in token. √à un investimento che si ripaga ampiamente in termini di tempo risparmiato, ma va pianificato ‚Äî soprattutto per team che lavorano su decine di feature in parallelo.</li><li><strong>Overhead per progetti semplici.</strong> Un workflow SDD completo per uno script di 50 righe √® over-engineering. L&rsquo;SDD d√† il meglio su feature con complessit√† medio-alta, dove le ambiguit√† sono il vero costo. Per task banali, un buon prompt diretto resta la scelta migliore.</li></ul><p>Tutti questi limiti sono tuttavia gestibili attraverso un approccio disciplinato e consapevole. In altre parole, un approccio naive in stile &ldquo;vibe-coding&rdquo; pu√≤ andar bene per un piccolo prototipo, ma all&rsquo;aumentare della complessit√† del progetto √® necessario applicare le tecniche di SDD sempre con maggior rigore per evitare di incorrere in questi problemi.</p><h2 id=conclusioni>Conclusioni<a hidden class=anchor aria-hidden=true href=#conclusioni>#</a></h2><p>La Spec-Driven Development non √® una moda passeggera n√© un esercizio accademico.</p><p>L&rsquo;SDD √® un approccio metodologico e disciplinato allo sviluppo del software tramite AI Agents, che sfrutta le capacit√† degli agenti su tutto lo stack di sviluppo, dalla esplorazione dello spazio delle soluzioni, alla scrittura di specifiche dettagliate, alla pianificazione tecnica, fino all&rsquo;implementazione e al testing.</p><p>Ma come abbiamo visto, non √® priva di limiti: il non-determinismo degli LLM, il rischio di specifiche errate, i costi in token e l&rsquo;overhead per progetti semplici sono tutti fattori da considerare. L&rsquo;SDD funziona meglio quando applicata con giudizio, non come dogma.</p><p>Per chi lavora nello sviluppo software oggi, il messaggio √® chiaro:</p><ol><li><strong>Investite nelle competenze trasversali</strong>: architettura, DevOps, modelli dati, sicurezza. Il Progettista del futuro non √® chi scrive il codice pi√π veloce, ma chi scrive le specifiche pi√π precise.</li><li><strong>Adottate gradualmente</strong>: partite con l&rsquo;API-first e i contract test. Poi aggiungete un framework SDD come Spec Kit su una feature nuova. Misurate i risultati.</li><li><strong>Abbandonate il Vibe Coding</strong>: scrivere prompt vaghi e sperare nel meglio non scala. Investire una giornata in specifiche per risparmiare due settimane di lavoro non √® &ldquo;perdere tempo&rdquo; ‚Äî √® il mestiere del Progettista.</li><li><strong>Preparatevi al cambio di mentalit√†</strong>: sar√† meno &ldquo;divertente&rdquo; nel senso tradizionale, ma la soddisfazione di orchestrare un sistema complesso attraverso specifiche che producono software funzionante √®, a suo modo, altrettanto appagante.</li></ol><p>Il futuro dello sviluppo software non √® scrivere codice. √à progettare sistemi e lasciare che il codice si scriva da solo ‚Äî ma sotto il controllo rigoroso di chi sa cosa vuole ottenere.</p><section id=comments><script src=https://giscus.app/client.js data-repo=c-daniele/c-daniele.github.io data-repo-id=R_kgDOKIObxg data-category=Announcements data-category-id=DIC_kwDOKIObxs4Cu2th data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=it crossorigin=anonymous async></script></section></div><footer class=post-footer><ul class=post-tags><li><a href=https://c-daniele.github.io/it/tags/genai/>GenAI</a></li><li><a href=https://c-daniele.github.io/it/tags/agents/>Agents</a></li><li><a href=https://c-daniele.github.io/it/tags/coding/>Coding</a></li></ul><nav class=paginav><a class=next href=https://c-daniele.github.io/it/posts/2025-11-10-genai-frameworks-update/><span class=title>Successivo ¬ª</span><br><span>Perch√© LangChain √® ancora il miglior framework per la GenAI</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share La transizione Sviluppatore --> Progettista on twitter" href="https://twitter.com/intent/tweet/?text=La%20transizione%20Sviluppatore%20--%3e%20Progettista&amp;url=https%3a%2f%2fc-daniele.github.io%2fit%2fposts%2f2026-02-14-intro-spec-driven-development%2f&amp;hashtags=GenAI%2cAgents%2cCoding"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share La transizione Sviluppatore --> Progettista on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fc-daniele.github.io%2fit%2fposts%2f2026-02-14-intro-spec-driven-development%2f&amp;title=La%20transizione%20Sviluppatore%20--%3e%20Progettista&amp;summary=La%20transizione%20Sviluppatore%20--%3e%20Progettista&amp;source=https%3a%2f%2fc-daniele.github.io%2fit%2fposts%2f2026-02-14-intro-spec-driven-development%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share La transizione Sviluppatore --> Progettista on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fc-daniele.github.io%2fit%2fposts%2f2026-02-14-intro-spec-driven-development%2f&title=La%20transizione%20Sviluppatore%20--%3e%20Progettista"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share La transizione Sviluppatore --> Progettista on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fc-daniele.github.io%2fit%2fposts%2f2026-02-14-intro-spec-driven-development%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share La transizione Sviluppatore --> Progettista on whatsapp" href="https://api.whatsapp.com/send?text=La%20transizione%20Sviluppatore%20--%3e%20Progettista%20-%20https%3a%2f%2fc-daniele.github.io%2fit%2fposts%2f2026-02-14-intro-spec-driven-development%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share La transizione Sviluppatore --> Progettista on telegram" href="https://telegram.me/share/url?text=La%20transizione%20Sviluppatore%20--%3e%20Progettista&amp;url=https%3a%2f%2fc-daniele.github.io%2fit%2fposts%2f2026-02-14-intro-spec-driven-development%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share La transizione Sviluppatore --> Progettista on ycombinator" href="https://news.ycombinator.com/submitlink?t=La%20transizione%20Sviluppatore%20--%3e%20Progettista&u=https%3a%2f%2fc-daniele.github.io%2fit%2fposts%2f2026-02-14-intro-spec-driven-development%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://c-daniele.github.io/it/>Cdani's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copia";function s(){t.innerHTML="copiato!",setTimeout(()=>{t.innerHTML="copia"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>