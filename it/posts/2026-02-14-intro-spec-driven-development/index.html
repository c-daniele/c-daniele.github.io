<!doctype html><html lang=en-IT><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>La transizione Sviluppatore --> Progettista - Cdani's Blog</title><meta name=Description content="Cdani's Blog"><meta property="og:url" content="https://c-daniele.github.io/it/posts/2026-02-14-intro-spec-driven-development/"><meta property="og:site_name" content="Cdani's Blog"><meta property="og:title" content="La transizione Sviluppatore --> Progettista"><meta property="og:description" content="Intro Qualche mese fa ho dovuto mettere mano a un‚Äôapplicazione complessa su AWS: frontend React su Amplify, diverse Lambda, Bedrock con AgentCore, Knowledge Bases e Prompt Management. Avevo fretta, e la tentazione era fortissima: aprire Claude Code, buttargli dentro un prompt generico e sperare che ‚Äúcapisse‚Äù. Invece ho fatto una cosa diversa ‚Äî ho scritto specifiche, le ho revisionate, ci ho perso una giornata intera ‚Äî e quel giorno mi √® sembrato di non aver combinato nulla. Due giorni dopo avevo un‚Äôapplicazione funzionante. Se avessi improvvisato, starei probabilmente ancora debuggando."><meta property="og:locale" content="en_IT"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-14T00:00:00+02:00"><meta property="article:modified_time" content="2026-02-14T00:00:00+02:00"><meta property="article:tag" content="GenAI"><meta property="article:tag" content="Agents"><meta property="article:tag" content="Coding"><meta property="og:image" content="https://c-daniele.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://c-daniele.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="La transizione Sviluppatore --> Progettista"><meta name=twitter:description content="Intro Qualche mese fa ho dovuto mettere mano a un‚Äôapplicazione complessa su AWS: frontend React su Amplify, diverse Lambda, Bedrock con AgentCore, Knowledge Bases e Prompt Management. Avevo fretta, e la tentazione era fortissima: aprire Claude Code, buttargli dentro un prompt generico e sperare che ‚Äúcapisse‚Äù. Invece ho fatto una cosa diversa ‚Äî ho scritto specifiche, le ho revisionate, ci ho perso una giornata intera ‚Äî e quel giorno mi √® sembrato di non aver combinato nulla. Due giorni dopo avevo un‚Äôapplicazione funzionante. Se avessi improvvisato, starei probabilmente ancora debuggando."><meta name=application-name content="Cdani's Blog"><meta name=apple-mobile-web-app-title content="Cdani's Blog"><meta name=referrer content="no-referrer"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=/logo_cd_v3.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#00872b><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://c-daniele.github.io/it/posts/2026-02-14-intro-spec-driven-development/><link rel=prev href=https://c-daniele.github.io/it/posts/2025-11-10-genai-frameworks-update/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"La transizione Sviluppatore --\u003e Progettista","inLanguage":"en-IT","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/c-daniele.github.io\/it\/posts\/2026-02-14-intro-spec-driven-development\/"},"genre":"posts","keywords":"GenAI, Agents, Coding","wordcount":4999,"url":"https:\/\/c-daniele.github.io\/it\/posts\/2026-02-14-intro-spec-driven-development\/","datePublished":"2026-02-14T00:00:00+02:00","dateModified":"2026-02-14T00:00:00+02:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Me"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script>const query=window.matchMedia("(prefers-color-scheme: dark)");function applyTheme(){let e=window.localStorage?.getItem("theme")||"auto",t=e==="dark"||e==="auto"&&query.matches;document.body.setAttribute("theme",t?"dark":"light"),document.body.setAttribute("cfg-theme",e)}applyTheme(),query.addEventListener("change",applyTheme)</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/it/ title="Cdani's Blog"><img class="lazyload logo" src=/svg/loading.min.svg data-src=/logo_cd_v3.svg data-srcset="/logo_cd_v3.svg, /logo_cd_v3.svg 1.5x, /logo_cd_v3.svg 2x" data-sizes=auto alt=/logo_cd_v3.svg title=/logo_cd_v3.svg>Cdani's Blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/it/posts/>Archive </a><a class=menu-item href=/it/tags/>Tags </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=Search... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Cerca><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Chiaro><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title="Cambiare il tema"><i class="fas fa-adjust fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="menu-item language" title="Scegliere la lingua"><i class="fa fa-globe fa-fw" aria-hidden=true></i>
<select class=language-select id=language-select-desktop onchange="location=this.value"><option value=/it/posts/2026-02-14-intro-spec-driven-development/ selected>Italiano</option><option value=/en/posts/2026-02-14-intro-spec-driven-development/>English</option></select></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/it/ title="Cdani's Blog"><img class="lazyload logo" src=/svg/loading.min.svg data-src=/logo_cd_v3.svg data-srcset="/logo_cd_v3.svg, /logo_cd_v3.svg 1.5x, /logo_cd_v3.svg 2x" data-sizes=auto alt=/logo_cd_v3.svg title=/logo_cd_v3.svg>Cdani's Blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=Search... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Cerca><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Chiaro><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Annulla</a></div><a class=menu-item href=/it/posts/ title>Archive</a><a class=menu-item href=/it/tags/ title>Tags</a><a href=javascript:void(0); class="menu-item theme-switch" title="Cambiare il tema">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class=menu-item title="Scegliere la lingua"><i class="fa fa-globe fa-fw" aria-hidden=true></i>
<select class=language-select onchange="location=this.value"><option value=/it/posts/2026-02-14-intro-spec-driven-development/ selected>Italiano</option><option value=/en/posts/2026-02-14-intro-spec-driven-development/>English</option></select></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contenuti</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">La transizione Sviluppatore --> Progettista</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/it/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Me</a></span>&nbsp;<span class=post-category>incluso in <a href=/it/categories/software-development/><i class="far fa-folder fa-fw" aria-hidden=true></i>Software Development</a>&nbsp;<a href=/it/categories/artificial-intelligence/><i class="far fa-folder fa-fw" aria-hidden=true></i>Artificial Intelligence</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime="February 14, 2026">February 14, 2026</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;4999 parole&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;24 minuti&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contenuti</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#lo-sviluppatore-√®-una-professione-morta>Lo sviluppatore √® una professione morta?</a></li><li><a href=#prerequisiti>Prerequisiti</a><ul><li><a href=#skills>Skills</a></li><li><a href=#mindset>Mindset</a></li></ul></li><li><a href=#concetti-di-base>Concetti di base</a><ul><li><a href=#context-window>Context window</a></li><li><a href=#context-engineering>Context Engineering</a></li><li><a href=#divide-et-impera>Divide et impera</a></li></ul></li><li><a href=#cos√®-lsdd>Cos&rsquo;√® l&rsquo;SDD</a><ul><li><a href=#i-livelli-dellsdd>I livelli dell&rsquo;SDD</a></li><li><a href=#overview-dei-principali-framework>Overview dei principali framework</a></li><li><a href=#deep-dive-su-spec-kit>Deep dive su Spec Kit</a></li><li><a href=#un-esempio-pratico>Un esempio pratico</a></li></ul></li><li><a href=#coding-agents>Coding Agents</a><ul><li><a href=#come-funziona-un-coding-agent-sotto-il-cofano>Come funziona un coding agent (sotto il cofano)</a></li><li><a href=#agenti-integrati-nellecosistema>Agenti integrati nell&rsquo;ecosistema</a></li><li><a href=#agenti-editor-first>Agenti editor-first</a></li><li><a href=#piattaforme-agente>Piattaforme agente</a></li><li><a href=#quale-agente-scegliere>Quale agente scegliere?</a></li><li><a href=#il-valore-aggiunto-dei-file-istruzione-claudemd>Il valore aggiunto dei file istruzione: CLAUDE.md</a></li><li><a href=#che-cos√®-claudemd>Che cos&rsquo;√® CLAUDE.md</a></li><li><a href=#come-impostare-un-buon-claudemd>Come impostare un buon CLAUDE.md</a></li></ul></li><li><a href=#limiti-e-rischi-dellsdd>Limiti e rischi dell&rsquo;SDD</a></li><li><a href=#conclusioni>Conclusioni</a></li></ul></nav></div></div><div class=content id=content><h2 id=intro>Intro</h2><p>Qualche mese fa ho dovuto mettere mano a un&rsquo;applicazione complessa su AWS: frontend React su Amplify, diverse Lambda, Bedrock con AgentCore, Knowledge Bases e Prompt Management. Avevo fretta, e la tentazione era fortissima: aprire Claude Code, buttargli dentro un prompt generico e sperare che &ldquo;capisse&rdquo;. Invece ho fatto una cosa diversa ‚Äî ho scritto specifiche, le ho revisionate, ci ho perso una giornata intera ‚Äî e quel giorno mi √® sembrato di non aver combinato nulla. Due giorni dopo avevo un&rsquo;applicazione funzionante. Se avessi improvvisato, starei probabilmente ancora debuggando.</p><p>Questa esperienza mi ha cambiato prospettiva su cosa significhi davvero usare l&rsquo;AI per sviluppare software. Non si tratta di &ldquo;vibe coding&rdquo; ‚Äî scrivere un prompt vago e sperare nel meglio ‚Äî ma di qualcosa di molto pi√π strutturato, e paradossalmente pi√π faticoso. Ma prima di entrare nel merito, guardiamoci intorno: i segnali di una trasformazione radicale sono gi√† ovunque.</p><ul><li>Lo scorso dicembre, Boris Cherny, ingegnere di Anthropic e creatore di Claude Code (praticamente il prodotto di punta dell&rsquo;azienda), <a href=https://x.com/bcherny/status/2004887829252317325 target=_blank rel="noopener noreffer">ha dichiarato</a> che nei 30 giorni precedenti il 100% delle attivit√† sul repository di Claude Code sono state fatte da Claude Code stesso</li><li>Il forte rallentamento in borsa di alcune societ√† SaaS fa pensare che <a href="https://www.bloomberg.com/news/articles/2026-02-04/what-s-behind-the-saaspocalypse-plunge-in-software-stocks?embedded-checkout=true" target=_blank rel="noopener noreffer">il mercato abbia gi√† prezzato</a> la propensione delle aziende a svilupparsi il software in casa piuttosto che comprarlo dai classici big</li><li>Spotify <a href=https://techcrunch.com/2026/02/12/spotify-says-its-best-developers-havent-written-a-line-of-code-since-december-thanks-to-ai/ target=_blank rel="noopener noreffer">ha dichiarato</a> che da dicembre 2025 i loro migliori sviluppatori non scrivono pi√π una riga di codice: inviano istruzioni via Slack al loro sistema interno &ldquo;Honk&rdquo; (basato su Claude Code), che implementa le modifiche, mentre gli ingegneri si occupano di revisione e architettura</li></ul><hr><p>Per affrontare questa discussione, per√≤, dobbiamo lasciarci alle spalle l&rsquo;hype del &ldquo;Vibe Coding&rdquo; e capire fin da subito che stiamo parlando di un modo diverso di concepire la professione dello sviluppatore e la catena di montaggio del software.
Questo modo richiede metodo e disciplina e potrebbe addirittura essere indigesto per alcuni, perch√© rischia di comprimere certe fasi &ldquo;creative&rdquo; del lavoro, che talvolta possono essere le pi√π gratificanti.</p><h2 id=lo-sviluppatore-√®-una-professione-morta>Lo sviluppatore √® una professione morta?</h2><p>Secondo molti analisti parliamo di una &ldquo;<em>trasformazione</em>&rdquo;, quindi in un certo senso la risposta √® negativa. Tuttavia, io penso che la trasformazione sar√† talmente radicale che nel giro di 5 o 10 anni nessuno di noi vedr√† pi√π un annuncio di lavoro che parla semplicemente di &ldquo;Sviluppatore&rdquo;.
Lo sviluppatore del software di domani richiede expertise molto variegate (architetture, reti, processi, linguaggi, dati, &mldr;). Non so come si chiamer√† colui il quale far√† questo lavoro in futuro, ma per semplicit√† io lo chiamer√≤ il &ldquo;<strong>PROGETTISTA</strong>&rdquo;.</p><p>Lo stesso concetto di Progettista, lo si sta applicando anche ad altri ambiti meno ortodossi, come ad esempio la scrittura o il giornalismo.
Per fare un esempio estremo, qualche mese fa Luciano Floridi, uno dei massimi esponenti della filosofia dell&rsquo;informazione e del Digitale, ha pubblicato un libro intitolato <a href=https://www.rivista.ai/wp-content/uploads/2025/04/ssrn-5232088.pdf target=_blank rel="noopener noreffer">Distant Writing: Literary Production in the Age of Artificial Intelligence.</a>, in cui Floridi realizza un suo ambizioso progetto di intrecciare storie di personaggi secondari (minori ma nominati) dei romanzi classici inglesi, da Jane Austen a Virginia Woolf, in brevi storie (1500-2000 parole ciascuna) dove si incontrano in catene narrative plausibili per epoca, luogo e status sociale.
Nelle interviste che ha rilasciato, Floridi ha dichiarato di aver sostanzialmente &ldquo;progettato&rdquo; il libro e di averlo nel casetto gi√† da molti anni, ma di essere riuscito a realizzarlo solo tramite l&rsquo;uso di LLM per espandere e scrivere le singole storie, e per fare in modo che i personaggi si incontrassero in modo coerente con le loro caratteristiche e con la trama complessiva.</p><h2 id=prerequisiti>Prerequisiti</h2><p>Per prepararsi a questa trasformazione io vedo principalmente 2 prerequisiti, uno tecnico e uno mentale. Nessuno dei due √® facoltativo: senza le skills giuste non si producono specifiche di qualit√†; senza il mindset giusto non si ha la pazienza di scriverle.</p><h3 id=skills>Skills</h3><p>Le specifiche software esistono da sempre, non sono certo una novit√† del 2026. Tuttavia √® sorprendente notare come il mondo tech torni ad attenzionare l&rsquo;importanza di questo concetto dopo aver inventato il transformer, disboscato foreste e funestato i mercati azionari con potenziali bolle AI.</p><p>Le tecniche di Spec-Driven Development si basano ovviamente sul concetto di &ldquo;Specifica&rdquo;, che pu√≤ essere inteso a vari livelli di astrazione (es: user story, specifica tecnica, code template, &mldr;).
Il Progettista deve dunque saper leggere e scrivere le specifiche su tutto lo stack e deve avere un approccio metodico e rigoroso per industrializzare il lavoro.</p><p>Ma come faccio a scrivere specifiche per una soluzione con componenti frontend, backend, un message broker, diversi container, e la necessit√† di distribuirla su un hyperscaler piuttosto che su un altro?</p><p>Nel passato, dovevi sapere le basi dei calcolatori, le CPU, le memorie, la modellazione dati e le reti di telecomunicazioni.
Adesso, bisogna alzare il livello di astrazione e allargare la prospettiva. Serve dunque conoscere le piattaforme dati, gli hyperscaler, i pattern di autenticazione, i modelli di deploy e la containerizzazione, le pipeline di automazione e la gestione del software su decine o potenzialmente centinaia di branch.</p><p>Per poter evolvere da &ldquo;Sviluppatore&rdquo; del 2020 a &ldquo;Progettista&rdquo; del 2026, serve dunque:</p><ul><li>conoscere le basi delle tecniche DevOps</li><li>avere competenze di base di Solution Design e sapersi districare tra i pattern di sviluppo e deploy pi√π noti (microservizi, message brokers, containers, protocolli di trasporto e applicativi, Security, IaC, &mldr;)</li><li>avere forti competenze tecniche su un&rsquo;area specifica (es: frontend, data engineering, &mldr;)</li><li>conoscere le basi degli LLM, in particolare il ruolo del contesto e le tecniche di context engineering</li></ul><h3 id=mindset>Mindset</h3><p>Per molte persone lo sviluppo √® una passione oltre che un lavoro, e lo dimostrano le numerosissime community di sviluppo Open Source.
Dobbiamo abituarci all&rsquo;idea che il lavoro del Progettista potrebbe essere molto meno divertente di quello dello Sviluppatore di oggi. Questo passaggio potrebbe essere uno sforzo non accettabile per tutti, ma √® molto probabile che sia proprio qui che si giocher√† la partita sulle competenze che verranno apprezzate dal mercato del lavoro: sar√† infatti fondamentale saper leggere e scrivere specifiche.</p><p>Bisogna inoltre combattere con l&rsquo;impulso di avere &ldquo;tutto e subito&rdquo;: non possiamo pensare di scrivere un prompt e avere il software pronto. Bisogna realmente applicare un certo livello di effort e utilizzare per davvero le skills che citavamo sopra. Come raccontavo nell&rsquo;introduzione, la giornata &ldquo;persa&rdquo; a scrivere specifiche mi ha risparmiato circa due settimane di lavoro. Ma la sensazione iniziale era esattamente quella: di perdere tempo. √à un investimento controintuitivo, e il mindset giusto consiste proprio nell&rsquo;accettarlo.</p><h2 id=concetti-di-base>Concetti di base</h2><h3 id=context-window>Context window</h3><p>La maggior parte delle persone pensa: &ldquo;pi√π cose metto dentro il contesto, meglio √®&rdquo;. √à un&rsquo;idea che pu√≤ portare fuori strada, e capire il perch√© richiede un minimo di comprensione di come funzionano i modelli.</p><p>Gli LLM sono modelli autoregressivi basati sull&rsquo;architettura Transformer. Il cuore di questa architettura √® il meccanismo di <strong>self-attention</strong>: per ogni token generato, il modello calcola un punteggio di &ldquo;attenzione&rdquo; rispetto a <em>tutti</em> i token precedenti nel contesto. Questo ha due implicazioni pratiche importanti:</p><ol><li><p><strong>Complessit√† quadratica</strong>: il costo computazionale dell&rsquo;attenzione cresce come O(n¬≤) rispetto alla lunghezza del contesto. Raddoppiare il contesto quadruplica il costo. Questo non √® solo un problema di latenza e di costi (che pure sono rilevanti), ma degrada la qualit√† stessa dell&rsquo;output.</p></li><li><p><strong>&ldquo;Lost in the middle&rdquo;</strong>: diversi studi (tra cui il noto paper di Liu et al., 2023) hanno dimostrato che gli LLM tendono a prestare maggiore attenzione alle informazioni che si trovano all&rsquo;inizio e alla fine del contesto, &ldquo;dimenticando&rdquo; quelle centrali. In pratica, se la specifica cruciale della tua API si trova a met√† di una conversazione da 80.000 token, il modello potrebbe semplicemente non tenerla in considerazione.</p></li></ol><p>Sebbene l&rsquo;interfaccia degli LLM si presenti come una chat, dobbiamo sempre valutare ogni singola interazione come se fosse un <strong>task isolato</strong>, che si porta dietro una storia conversazionale che spesso √® inutile, inquina la context window e porta il modello fuori strada. Questo fenomeno si chiama <em>Context Bloat</em>.</p><h3 id=context-engineering>Context Engineering</h3><p>Il termine &ldquo;Context Engineering&rdquo; viene spesso confuso con il prompt engineering, ma sono concetti distinti. Il prompt engineering riguarda la formulazione della singola richiesta all&rsquo;LLM. Il Context Engineering √® qualcosa di pi√π ampio: √® il controllo sistematico di <strong>tutto ci√≤ che entra nella context window</strong> del modello ‚Äî system prompt, istruzioni persistenti (come il <code>CLAUDE.md</code>), risultati di tool, file di codice caricati, memoria delle interazioni precedenti, e solo in ultimo il prompt dell&rsquo;utente.</p><p>Pensate al contesto come a un <strong>programma</strong>: ogni elemento che vi inserite √® un&rsquo;istruzione che il modello eseguir√† (o tenter√† di eseguire). Pi√π istruzioni contraddittorie o irrilevanti inserite, pi√π il &ldquo;programma&rdquo; diventa imprevedibile.</p><p>Con questa prospettiva, le tecniche di SDD sono essenzialmente tecniche di Context Engineering: massimizzano l&rsquo;efficacia della context window rendendo modulare lo sviluppo (SPEC ‚Üí PIANO ‚Üí CLARIFY ‚Üí IMPLEMENTATION) e soprattutto minimizzando il rumore. Ogni fase opera in un contesto pulito e dedicato, con solo le informazioni rilevanti per quel task specifico.</p><h3 id=divide-et-impera>Divide et impera</h3><p>Nell&rsquo;ambito dello sviluppo software, molti (anche molti <strong>sviluppatori</strong> di oggi) pensano che l&rsquo;LLM serva solo per scrivere il codice, mentre le tecniche di SDD si basano sull&rsquo;assunto che il Progettista utilizzi l&rsquo;LLM <strong>su tutta la pipeline</strong> di lavoro del software.</p><table><thead><tr><th>Fase</th><th>Obiettivo</th><th>Utilizzo LLM</th></tr></thead><tbody><tr><td>Ideazione</td><td>Esplorazione dello <strong>spazio delle soluzioni</strong></td><td>Per un determinato problema, esiste un numero potenzialmente infinito di soluzioni e gli LLM sono uno strumento formidabile per esplorarle</td></tr><tr><td>Specifiche</td><td>Definizione dettagliata dei requisiti utente</td><td>Oltre a definire le specifiche di dettaglio, in questa fase vengono anche individuati eventuali gap e aree di ambiguit√†</td></tr><tr><td>Disegno</td><td>Avere una solida baseline su cui scrivere il codice senza &ldquo;improvvisare&rdquo;</td><td>Ricerca, espansione, approfondimento e selezione delle componenti software da creare/modificare e del piano di sviluppo e della modalit√† di test</td></tr><tr><td>Implementazione</td><td>Tradurre il disegno in codice</td><td>Scrittura del codice e dei test</td></tr><tr><td>Test</td><td>Verifica del software</td><td>Esecuzione dei test e identificazione dei bug</td></tr></tbody></table><div class="callout callout-tip"><div class=callout-title>üí° Tip</div><div class=callout-content><ul><li>Per ogni fase, vale la pena valutare di volta in volta l&rsquo;LLM pi√π adatto. Ad esempio, al momento della scrittura Claude Opus 4.6 √® tra i pi√π performanti nel coding puro, ma modelli come le ultime versioni di ChatGPT, Gemini 3 o Kimi k2.5 possono essere pi√π efficaci e creativi nelle fasi di esplorazione delle soluzioni.</li><li>Riutilizzare lo stesso contesto per un intero ciclo di sviluppo √® fortemente sconsigliato, anche se il modello supporta milioni di token. Il motivo √® il Context Bloat discusso sopra: le decisioni architetturali della fase di Piano, i dettagli delle user story della fase di Specifica, e il codice della fase di Implementazione competono tutti per l&rsquo;attenzione del modello. Il risultato √® un degrado progressivo della qualit√† su <em>tutte</em> le fasi, non solo sull&rsquo;ultima.</li></ul></div></div><style>.callout{border-left:4px solid;padding:1rem;margin:1.5rem 0;border-radius:4px;background-color:var(--callout-bg)}.callout-title{font-weight:700;margin-bottom:.5rem}.callout-note{border-color:#0969da;background-color:#ddf4ff}.callout-tip{border-color:#1a7f37;background-color:#dcffe4}.callout-important{border-color:#8250df;background-color:#fbefff}.callout-warning{border-color:#9a6700;background-color:#fff8c5}.callout-caution{border-color:#cf222e;background-color:#ffebe9}[data-theme=dark] .callout-note,.dark .callout-note{background-color:#0969da1a;color:#e6edf3}[data-theme=dark] .callout-tip,.dark .callout-tip{background-color:#1a7f371a;color:#e6edf3}[data-theme=dark] .callout-important,.dark .callout-important{background-color:#8250df1a;color:#e6edf3}[data-theme=dark] .callout-warning,.dark .callout-warning{background-color:#9a67001a;color:#e6edf3}[data-theme=dark] .callout-caution,.dark .callout-caution{background-color:#cf222e1a;color:#e6edf3}</style><h2 id=cos√®-lsdd>Cos&rsquo;√® l&rsquo;SDD</h2><p>La <strong>Spec-Driven Development</strong> (SDD) √® un paradigma che tratta le <strong>specifiche come fonte primaria di verit√†</strong> di un sistema software. Il codice diventa un artefatto secondario, generato o verificato rispetto alla specifica. Invece del classico approccio &ldquo;scrivi il codice prima, documenta dopo&rdquo;, l&rsquo;SDD inverte il flusso: si scrivono specifiche chiare e strutturate del comportamento atteso e poi si genera, implementa o verifica il codice rispetto ad esse.</p><p>In altre parole: <strong>la specifica √® il prodotto, il codice √® un sottoprodotto</strong>.</p><p>Questo concetto non √® nuovo in assoluto. L&rsquo;API-first development con OpenAPI, il BDD (Behavior-Driven Development) e i contract-driven testing esistono da anni. Ci√≤ che cambia oggi √® che gli LLM rendono possibile <strong>automatizzare l&rsquo;intero flusso</strong>: dalla specifica al piano tecnico, dal piano ai task, dai task al codice, dal codice ai test. La specifica diventa un vero e proprio <em>control plane</em> che orchestra agenti AI e sviluppatori umani.</p><p>Un <a href=https://www.arxiv.org/pdf/2602.00180.pdf target=_blank rel="noopener noreffer">recente paper su arXiv</a> formalizza l&rsquo;SDD cos√¨: <em>&ldquo;Le specifiche sono la fonte di verit√†; il codice deriva da esse. La specifica √® la descrizione autoritativa che umani e macchine usano per comprendere, costruire e far evolvere il sistema.&rdquo;</em></p><h3 id=i-livelli-dellsdd>I livelli dell&rsquo;SDD</h3><p>Non esiste un unico modo di applicare l&rsquo;SDD. Si possono identificare tre livelli di rigore:</p><ul><li><strong>Spec-first</strong>: la specifica viene scritta prima dell&rsquo;implementazione e guida lo sviluppo iniziale. Ideale per nuovi servizi, API o feature con pi√π consumatori.</li><li><strong>Spec-anchored</strong>: specifica e codice evolvono insieme, mantenuti in sincronia tramite test e validazione. √à il livello pi√π pratico per la maggior parte dei team in produzione.</li><li><strong>Spec-as-source</strong>: gli umani editano solo le specifiche; il codice viene generato da esse. Adatto a domini altamente regolamentati o strutturati dove la tracciabilit√† dal requisito al codice deve essere rigorosa.</li></ul><p>La maggior parte dei team trover√† nello <strong>spec-anchored</strong> il giusto compromesso tra rigore e agilit√†.</p><h3 id=overview-dei-principali-framework>Overview dei principali framework</h3><p>L&rsquo;ecosistema di strumenti per l&rsquo;SDD si sta sviluppando rapidamente. Ecco i tre framework pi√π rilevanti:</p><h4 id=spec-kit-github>Spec Kit (GitHub)</h4><p><a href=https://github.com/github/spec-kit target=_blank rel="noopener noreffer">Spec Kit</a> √® il toolkit open-source di GitHub per l&rsquo;SDD. Propone un workflow multi-fase (<code>Specify ‚Üí Plan ‚Üí Tasks ‚Üí Implement</code>) e genera artefatti Markdown versionati nel repository. √à compatibile con GitHub Copilot, Claude Code, Cursor e Gemini CLI. Approfondiremo Spec Kit nel prossimo capitolo.</p><h4 id=openspec-fission-ai>OpenSpec (Fission AI)</h4><p><a href=https://openspec.pro/ target=_blank rel="noopener noreffer">OpenSpec</a> √® un framework leggero e open-source (TypeScript) pensato per portare determinismo nello sviluppo AI. Le sue caratteristiche distintive:</p><ul><li><strong>Delta Specs</strong>: cattura i cambiamenti incrementali nei requisiti, anzich√© riscrivere l&rsquo;intera specifica</li><li><strong>Brownfield-first</strong>: progettato per evolvere codebase esistenti, non solo per progetti greenfield</li><li><strong>Nessuna API key o installazione complessa</strong>: le specifiche vivono nel repository accanto al codice</li><li>Supporta oltre 20 strumenti, tra cui Claude Code, Cursor e GitHub Copilot</li></ul><h4 id=bmad-method>BMAD Method</h4><p>Il <a href=https://github.com/bmad-code-org/BMAD-METHOD target=_blank rel="noopener noreffer">BMAD Method</a> (Breakthrough Method for Agile AI-Driven Development) √® un framework open-source pi√π ambizioso, con:</p><ul><li><strong>21 agenti AI specializzati</strong> (Analyst, Product Manager, Architect, Developer, QA, Scrum Master, &mldr;) ognuno con ruoli e responsabilit√† definiti</li><li><strong>50+ workflow guidati</strong> per diversi tipi di progetto e fasi</li><li><strong>Architettura multi-agente</strong>: gli agenti collaborano dall&rsquo;ideazione all&rsquo;implementazione</li><li>Compatibile con Claude Code, Cursor, Windsurf e altri IDE AI</li></ul><p>Ecco una guida rapida per orientarsi nella scelta:</p><table><thead><tr><th>Criterio</th><th>Spec Kit</th><th>OpenSpec</th><th>BMAD</th></tr></thead><tbody><tr><td>Complessit√† di setup</td><td>Bassa (CLI + Markdown)</td><td>Molto bassa (file nel repo)</td><td>Media-alta (21 agenti da configurare)</td></tr><tr><td>Ideale per</td><td>Progetti greenfield con GitHub</td><td>Evoluzione di codebase esistenti</td><td>Progetti enterprise con team strutturati</td></tr><tr><td>Curva di apprendimento</td><td>~1 ora</td><td>~30 minuti</td><td>~1 giorno</td></tr><tr><td>Lock-in</td><td>Basso (Markdown + Git)</td><td>Nessuno (file nel repo)</td><td>Medio (dipendenza dal framework)</td></tr><tr><td>Supporto brownfield</td><td>Limitato</td><td>Eccellente (Delta Specs)</td><td>Buono</td></tr></tbody></table><p>In generale: partite con <strong>Spec Kit</strong> se usate GitHub e volete un workflow strutturato ma leggero. Scegliete <strong>OpenSpec</strong> se dovete evolvere una codebase esistente senza stravolgere il workflow. Valutate <strong>BMAD</strong> solo se il vostro progetto richiede coordinamento multi-ruolo e avete il budget di tempo per configurare l&rsquo;intera orchestra di agenti.</p><h3 id=deep-dive-su-spec-kit>Deep dive su Spec Kit</h3><p>Spec Kit merita un approfondimento perch√© rappresenta lo stato dell&rsquo;arte dell&rsquo;SDD applicata ai coding agent ed √® sostenuto direttamente da GitHub e Microsoft.</p><p>Il workflow di Spec Kit si articola in passi ben definiti, ognuno con un comando dedicato:</p><p><strong>1. Costituzione del progetto (<code>/speckit.constitution</code>)</strong></p><p>Si definiscono i principi non-negoziabili del progetto: standard di codifica, requisiti di test, regole di sicurezza, principi UX, target di performance. La <em>constitution</em> viene consultata automaticamente in ogni fase successiva come vincolo.</p><p><strong>2. Specifica funzionale (<code>/speckit.specify</code>)</strong></p><p>Si trasforma un&rsquo;idea in una specifica funzionale strutturata: user story, requisiti funzionali, criteri di accettazione. Nessun dettaglio tecnico qui ‚Äî solo il <em>cosa</em> e il <em>perch√©</em>. Spec Kit crea automaticamente un branch Git dedicato alla feature.</p><p><strong>3. Chiarificazione (<code>/speckit.clarify</code>)</strong></p><p>L&rsquo;agente AI pone domande strutturate per eliminare ambiguit√† dalla specifica: casi limite, vincoli, gestione degli errori, permessi. Questa fase √® fondamentale: una specifica ambigua produce codice ambiguo.</p><p><strong>4. Piano tecnico (<code>/speckit.plan</code>)</strong></p><p>La specifica validata viene tradotta in un piano tecnico dettagliato: decisioni architetturali, modelli dati, API, integrazioni. Qui si sceglie lo stack, i pattern e le interfacce. Gli artefatti generati includono <code>plan.md</code>, <code>data-model.md</code>, e una cartella <code>contracts/</code> con le specifiche API.</p><p><strong>5. Validazione (<code>/speckit.checklist</code>, <code>/speckit.analyze</code>)</strong></p><p>Controllo di qualit√† e coerenza tra tutti gli artefatti prima di scrivere codice. Si verificano inconsistenze, gap e problemi di qualit√†.</p><p><strong>6. Scomposizione in task (<code>/speckit.tasks</code>)</strong></p><p>Il piano viene scomposto in unit√† di lavoro piccole e reviewable: ogni task ha input, output e criteri di successo espliciti legati alla specifica. I task sono ordinati per dipendenze e quelli parallelizzabili sono marcati.</p><p><strong>7. Implementazione (<code>/speckit.implement</code>)</strong></p><p>L&rsquo;agente AI esegue i task, generando e modificando codice, test e configurazioni secondo il piano. Il codice viene prodotto in piccoli diff, facilmente reviewable.</p><h3 id=un-esempio-pratico>Un esempio pratico</h3><p>Immaginiamo di voler sviluppare una semplice API per la gestione di una libreria di libri. Ecco come si svolgerebbe il flusso con Spec Kit:</p><p><strong>Fase 1 - Constitution:</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-text"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copia negli appunti"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>/speckit.constitution
</span></span><span class=line><span class=cl>Il progetto segue un approccio API-first. Usiamo Python con FastAPI.
</span></span><span class=line><span class=cl>Ogni endpoint deve avere test unitari. Sicurezza: autenticazione JWT.
</span></span><span class=line><span class=cl>Database PostgreSQL con Alembic per le migrazioni.</span></span></code></pre></div></div><p><strong>Fase 2 - Specify:</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-text"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copia negli appunti"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>/speckit.specify
</span></span><span class=line><span class=cl>Costruire un&#39;API REST per gestire una libreria di libri.
</span></span><span class=line><span class=cl>Gli utenti possono cercare libri per titolo, autore o ISBN.
</span></span><span class=line><span class=cl>Gli amministratori possono aggiungere, modificare e rimuovere libri.
</span></span><span class=line><span class=cl>Ogni libro ha: titolo, autore, ISBN, anno di pubblicazione, genere.
</span></span><span class=line><span class=cl>Include user story e criteri di accettazione.</span></span></code></pre></div></div><p>A questo punto Spec Kit genera un file <code>spec.md</code> strutturato con user story del tipo:</p><ul><li><em>Come utente, voglio cercare libri per titolo, cos√¨ da trovare rapidamente il libro che mi interessa</em></li><li><em>Come amministratore, voglio aggiungere un nuovo libro al catalogo, specificando tutti i metadati</em></li></ul><p><strong>Fase 3 - Clarify:</strong> L&rsquo;agente chiede ad esempio: &ldquo;Ci sono limiti sul numero di risultati per pagina? Cosa succede se si tenta di inserire un ISBN duplicato? Quali campi sono obbligatori?&rdquo;</p><p><strong>Fase 4 - Plan:</strong> Viene generato un piano tecnico. Ecco un estratto realistico del <code>plan.md</code> generato:</p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-markdown"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copia negli appunti"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gh># Piano Tecnico - API Libreria
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Architettura
</span></span></span><span class=line><span class=cl><span class=k>-</span> Framework: FastAPI con Pydantic v2 per validazione
</span></span><span class=line><span class=cl><span class=k>-</span> Database: PostgreSQL 16 con SQLAlchemy 2.0 (async)
</span></span><span class=line><span class=cl><span class=k>-</span> Migrazioni: Alembic con autogenerate
</span></span><span class=line><span class=cl><span class=k>-</span> Auth: JWT (access token 15min + refresh token 7d)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Modello Dati
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>### Book
</span></span></span><span class=line><span class=cl>| Campo        | Tipo         | Vincoli                    |
</span></span><span class=line><span class=cl>|-------------|-------------|---------------------------|
</span></span><span class=line><span class=cl>| id          | UUID        | PK, auto-generato         |
</span></span><span class=line><span class=cl>| title       | VARCHAR(255)| NOT NULL, INDEX            |
</span></span><span class=line><span class=cl>| author      | VARCHAR(255)| NOT NULL, INDEX            |
</span></span><span class=line><span class=cl>| isbn        | VARCHAR(13) | UNIQUE, NOT NULL           |
</span></span><span class=line><span class=cl>| year        | INTEGER     | CHECK (year &gt;= 1450)       |
</span></span><span class=line><span class=cl>| genre       | VARCHAR(100)| NULL                       |
</span></span><span class=line><span class=cl>| created_at  | TIMESTAMP   | DEFAULT now()              |
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Endpoint REST
</span></span></span><span class=line><span class=cl><span class=k>-</span> <span class=sb>`GET /books?title=&amp;author=&amp;isbn=&amp;page=1&amp;size=20`</span> ‚Üí 200 + paginazione
</span></span><span class=line><span class=cl><span class=k>-</span> <span class=sb>`GET /books/{id}`</span> ‚Üí 200 | 404
</span></span><span class=line><span class=cl><span class=k>-</span> <span class=sb>`POST /books`</span> ‚Üí 201 | 400 (validazione) | 409 (ISBN duplicato)
</span></span><span class=line><span class=cl><span class=k>-</span> <span class=sb>`PUT /books/{id}`</span> ‚Üí 200 | 404
</span></span><span class=line><span class=cl><span class=k>-</span> <span class=sb>`DELETE /books/{id}`</span> ‚Üí 204 | 404
</span></span><span class=line><span class=cl>- Tutti i metodi POST/PUT/DELETE richiedono header <span class=sb>`Authorization: Bearer &lt;token&gt;`</span></span></span></code></pre></div></div><p>Notare il livello di dettaglio: tipi, vincoli, codici di risposta, regole di autenticazione. Non c&rsquo;√® ambiguit√†, e l&rsquo;agente AI che ricever√† questo piano non dovr√† &ldquo;indovinare&rdquo; nulla.</p><p><strong>Fase 5-6 - Checklist & Tasks:</strong> Vengono generati task come:</p><ol><li>Creare i modelli SQLAlchemy (Book, User)</li><li>Configurare Alembic e creare la migrazione iniziale</li><li>Implementare l&rsquo;endpoint <code>GET /books</code> con filtri e paginazione</li><li>Implementare l&rsquo;endpoint <code>POST /books</code> con validazione</li><li>Aggiungere autenticazione JWT</li><li>Scrivere i test per ogni endpoint</li></ol><p>Ogni task ha input, output e criteri di successo espliciti. I task parallelizzabili sono marcati con <code>[P]</code>, quelli sequenziali sono ordinati per dipendenze.</p><p><strong>Fase 7 - Implement:</strong> L&rsquo;agente esegue ogni task, producendo codice e test verificabili.</p><p>Il punto chiave √® che ogni fase produce artefatti Markdown versionati nel repository, creando una tracciabilit√† completa dall&rsquo;idea al codice. Se tra sei mesi qualcuno chiede &ldquo;perch√© questa API funziona cos√¨?&rdquo;, la risposta √® nella specifica.</p><h2 id=coding-agents>Coding Agents</h2><p>L&rsquo;SDD √® la metodologia, ma per metterla in pratica servono gli strumenti giusti. I <strong>coding agent</strong> sono la componente operativa di questo nuovo paradigma: agenti AI che non si limitano al completamento automatico, ma pianificano task, modificano codebase, eseguono test e collaborano attraverso i workflow DevOps esistenti.</p><h3 id=come-funziona-un-coding-agent-sotto-il-cofano>Come funziona un coding agent (sotto il cofano)</h3><p>Prima di passare in rassegna gli strumenti, vale la pena capire cosa distingue un &ldquo;agente&rdquo; da un semplice chatbot. Un coding agent opera secondo un <strong>loop agentico</strong> continuo, che in pseudo-codice si pu√≤ rappresentare cos√¨:</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copia negli appunti"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>while</span> <span class=n>task</span> <span class=ow>is</span> <span class=ow>not</span> <span class=n>complete</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>context</span>  <span class=o>=</span> <span class=n>gather</span><span class=p>(</span><span class=n>specs</span><span class=p>,</span> <span class=n>code</span><span class=p>,</span> <span class=n>test_results</span><span class=p>,</span> <span class=n>errors</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>plan</span>     <span class=o>=</span> <span class=n>reason</span><span class=p>(</span><span class=n>context</span><span class=p>)</span>           <span class=c1># l&#39;LLM decide cosa fare</span>
</span></span><span class=line><span class=cl>    <span class=n>action</span>   <span class=o>=</span> <span class=n>select_tool</span><span class=p>(</span><span class=n>plan</span><span class=p>)</span>         <span class=c1># scelta del tool: edit, bash, search...</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span>   <span class=o>=</span> <span class=n>execute</span><span class=p>(</span><span class=n>action</span><span class=p>)</span>           <span class=c1># esecuzione reale nel filesystem/terminale</span>
</span></span><span class=line><span class=cl>    <span class=n>feedback</span> <span class=o>=</span> <span class=n>verify</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>            <span class=c1># test, lint, output del comando</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>feedback</span><span class=o>.</span><span class=n>has_errors</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>context</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>feedback</span><span class=p>)</span>         <span class=c1># l&#39;errore diventa input per il prossimo ciclo</span></span></span></code></pre></div></div><p>Il meccanismo chiave √® il <strong>tool use</strong> (o function calling): l&rsquo;LLM non genera solo testo, ma emette chiamate strutturate a strumenti esterni ‚Äî editor di file, terminale bash, browser, API. Questo gli permette di interagire con il mondo reale: leggere un file, modificarlo, eseguire i test e reagire ai risultati.</p><p>La differenza fondamentale tra i vari agenti sul mercato sta in <em>quali tool</em> hanno a disposizione e in <em>quale ambiente</em> operano:</p><ul><li><strong>Agenti con accesso diretto al filesystem</strong> (Claude Code, Cursor): operano sulla tua macchina, con accesso completo a terminale e file. Massima flessibilit√†, ma richiedono supervisione.</li><li><strong>Agenti in sandbox isolata</strong> (Devin, GitHub Copilot coding agent): operano in un ambiente cloud dedicato. Pi√π sicuri per l&rsquo;autonomia completa, ma meno flessibili per workflow personalizzati.</li></ul><p>Il panorama dei coding agent si √® evoluto rapidamente e oggi possiamo distinguere diverse categorie:</p><h3 id=agenti-integrati-nellecosistema>Agenti integrati nell&rsquo;ecosistema</h3><ul><li><strong>GitHub Copilot coding agent</strong>: lavora direttamente nel workflow delle Pull Request. Puoi assegnare una issue a <code>@copilot</code> e l&rsquo;agente pianifica, modifica il codice, esegue i test e apre una PR autonomamente. √à il target nativo di Spec Kit.</li><li><strong>Amazon Q Developer</strong>: l&rsquo;assistente AI di AWS, particolarmente forte per lo sviluppo cloud-native, IaC e le trasformazioni applicative (es. migrazione Java 8‚Üí17).</li><li><strong>Google Gemini Code Assist</strong>: forte integrazione con i servizi Google Cloud (BigQuery, Firebase, Apigee). Supportato esplicitamente da Spec Kit come target SDD.</li></ul><h3 id=agenti-editor-first>Agenti editor-first</h3><ul><li><strong>Cursor</strong>: un fork di VS Code nativamente AI-first. La modalit√† Agentic + Composer permette di pianificare task multi-step, modificare pi√π file, eseguire comandi nel terminale e iterare fino al superamento dei test.</li><li><strong>JetBrains AI Assistant & Junie</strong>: integrato in tutti gli IDE JetBrains, Junie offre programmazione agentica per implementare fix, refactoring e test.</li></ul><h3 id=piattaforme-agente>Piattaforme agente</h3><ul><li><strong>Claude Code / Claude Agent SDK</strong>: piattaforma di Anthropic basata sul principio &ldquo;dai all&rsquo;agente un computer&rdquo;. Claude Code ha accesso a terminale e file system e opera con un ciclo continuo: <em>raccogli contesto ‚Üí agisci ‚Üí verifica ‚Üí ripeti</em>. L&rsquo;Agent SDK permette di costruire agenti personalizzati.</li><li><strong>Devin (Cognition)</strong>: agente completamente autonomo con il proprio ambiente di sviluppo integrato (shell, editor, browser). Ancora sperimentale e poco &ldquo;enterprise&rdquo;</li></ul><h3 id=quale-agente-scegliere>Quale agente scegliere?</h3><p>Per un&rsquo;azienda che vuole adottare l&rsquo;SDD oggi, un approccio pragmatico √®:</p><ul><li><strong>GitHub Copilot</strong> o <strong>Amazon Q</strong> per il lavoro issue/PR-driven sui servizi core</li><li><strong>Gemini Code Assist</strong> per workflow SDD su analytics e integrazioni GCP</li><li><strong>Cursor</strong> o <strong>JetBrains</strong> nell&rsquo;IDE per implementazione ad alta fedelt√† dalle specifiche</li><li><strong>Claude Code / Agent SDK</strong> per pipeline SDD personalizzate dove gli strumenti standard sono troppo rigidi</li></ul><h3 id=il-valore-aggiunto-dei-file-istruzione-claudemd>Il valore aggiunto dei file istruzione: CLAUDE.md</h3><p>Uno dei concetti pi√π potenti emersi con i coding agent √® quello dei <strong>file di istruzione persistente</strong>: file Markdown che l&rsquo;agente legge automaticamente all&rsquo;inizio di ogni sessione per comprendere il contesto del progetto. Ogni agente ha il suo formato (<code>.github/copilot-instructions.md</code> per Copilot, <code>.cursorrules</code> per Cursor, ecc.), ma il pi√π noto e maturo √® il <code>CLAUDE.md</code> di Claude Code.</p><h3 id=che-cos√®-claudemd>Che cos&rsquo;√® CLAUDE.md</h3><p><code>CLAUDE.md</code> √® un file di istruzione specifico per progetto che Claude Code legge automaticamente all&rsquo;avvio in una directory. Il suo scopo √®:</p><ul><li>Dare a Claude il <strong>contesto minimo</strong> che non pu√≤ inferire dal codice</li><li>Codificare <strong>regole critiche e caveat</strong> che devono essere rispettati in ogni task</li><li>Migliorare affidabilit√† e velocit√† evitando spiegazioni ripetute</li></ul><p>Va pensato come un <strong>system prompt curato con attenzione</strong>, non come una wiki. √à un <strong>contratto vivente</strong> tra la codebase e gli agenti AI.</p><h3 id=come-impostare-un-buon-claudemd>Come impostare un buon CLAUDE.md</h3><p>Le best practice, confermate sia dalla documentazione Anthropic che dalla esperienza empirica della Community, convergono su alcuni principi chiave.
Questi principi non sono specifici di Claude Code ma derivano dalle caratteristiche generali degli LLM, di conseguenza valgono per qualsiasi assistente o coding Agent, anche se il formato specifico pu√≤ variare a seconda dello strumento.</p><p><strong>1. Less is more</strong></p><p>Ogni riga aggiuntiva pu√≤ <em>ridurre</em> la qualit√† complessiva del rispetto delle istruzioni. Gli LLM possono seguire con alta fedelt√† solo un numero limitato di istruzioni distinte. Quando ce ne sono troppe, l&rsquo;aderenza a <em>tutte</em> le regole degrada ‚Äî non vengono ignorate le ultime, peggiorano tutte.</p><p><strong>2. Alto segnale, basso rumore</strong></p><p>Includere solo informazioni che sono:</p><ul><li>Difficili da inferire per Claude leggendo il codice</li><li>Rilevanti per la grande maggioranza dei task quotidiani</li></ul><p><strong>3. La struttura minima efficace</strong></p><p>Un buon <code>CLAUDE.md</code> contiene tipicamente tre blocchi:</p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-markdown"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copia negli appunti"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gh># CLAUDE.md
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Progetto
</span></span></span><span class=line><span class=cl>Questo √® un portale e-commerce Next.js + TypeScript che comunica
</span></span><span class=line><span class=cl>con le nostre API interne di pagamento e catalogo.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Comandi chiave
</span></span></span><span class=line><span class=cl><span class=k>-</span> Installare dipendenze: <span class=sb>`pnpm install`</span>
</span></span><span class=line><span class=cl><span class=k>-</span> Dev server: <span class=sb>`pnpm dev`</span>
</span></span><span class=line><span class=cl><span class=k>-</span> Build: <span class=sb>`pnpm build`</span>
</span></span><span class=line><span class=cl><span class=k>-</span> Test: <span class=sb>`pnpm test`</span>
</span></span><span class=line><span class=cl><span class=k>-</span> Lint: <span class=sb>`pnpm lint`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Caveat IMPORTANTI
</span></span></span><span class=line><span class=cl><span class=k>-</span> IMPORTANTE: Non modificare <span class=sb>`prisma/schema.prisma`</span> direttamente.
</span></span><span class=line><span class=cl>  Usare <span class=sb>`pnpm db:migrate`</span> e <span class=sb>`pnpm db:generate`</span>.
</span></span><span class=line><span class=cl><span class=k>-</span> IMPORTANTE: L&#39;endpoint <span class=sb>`/api/webhooks/stripe`</span> si aspetta il body
</span></span><span class=line><span class=cl>  raw della request. NON usare un body parser.
</span></span><span class=line><span class=cl><span class=k>-</span> Le immagini in <span class=sb>`public/`</span> devono essere ottimizzate prima del commit;
</span></span><span class=line><span class=cl>  file &gt; 200KB faranno fallire la CI.</span></span></code></pre></div></div><p><strong>4. Non mettere regole di stile</strong></p><p>Regole come &ldquo;usa due spazi per l&rsquo;indentazione&rdquo; o &ldquo;usa single quotes&rdquo; sono uno spreco di istruzioni: Claude le inferisce dal codice esistente, e comunque linter e formatter le gestiscono meglio.</p><p><strong>5. Disclosure progressiva</strong></p><p>Per informazioni dettagliate ma raramente necessarie, non appesantire il file principale. Piuttosto:</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-markdown"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copia negli appunti"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gu>## Documentazione aggiuntiva
</span></span></span><span class=line><span class=cl><span class=k>-</span> Schema database e migrazioni: leggere <span class=sb>`docs/schema.md`</span> quando
</span></span><span class=line><span class=cl>  si modificano i modelli.</span></span></code></pre></div></div><p>Claude aprir√† <code>docs/schema.md</code> solo quando necessario, invece di caricarlo ad ogni task.</p><p><strong>6. Regole path-specific con <code>.claude/rules/</code></strong></p><p>Claude Code supporta file di istruzione specifici per path:</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-markdown"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copia negli appunti"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gh># .claude/rules/tests.md
</span></span></span><span class=line><span class=cl>paths: [&#34;**/*.spec.ts&#34;, &#34;**/*.test.ts&#34;]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Regole di test
</span></span></span><span class=line><span class=cl><span class=k>-</span> Usare Vitest, non Jest.
</span></span><span class=line><span class=cl>- Usare gli helper in <span class=sb>`test-utils/`</span> per il rendering dei componenti.</span></span></code></pre></div></div><p>Questo file viene caricato solo quando Claude lavora su file di test, mantenendo il <code>CLAUDE.md</code> globale pi√π snello.</p><p><strong>7. Manutenzione continua</strong></p><p>Trattare <code>CLAUDE.md</code> come un documento vivente: aggiornarlo quando si nota che Claude ripete errori evitabili, rimuovere istruzioni obsolete, riordinare per importanza. Le regole pi√π importanti vanno sempre <strong>in cima al file</strong>.</p><h2 id=limiti-e-rischi-dellsdd>Limiti e rischi dell&rsquo;SDD</h2><p>Sarebbe disonesto presentare l&rsquo;SDD come una soluzione priva di criticit√†. Ci sono limiti concreti che √® bene conoscere prima di adottarla:</p><ul><li><strong>Non-determinismo.</strong> Gli LLM non sono deterministici: la stessa specifica, data allo stesso modello in due momenti diversi, pu√≤ produrre codice strutturalmente diverso. Questo significa che l&rsquo;SDD non garantisce riproducibilit√†. La specifica riduce drasticamente la varianza rispetto a un prompt generico, ma non la elimina. Per questo i contract test e la validazione automatica sono indispensabili ‚Äî sono il &ldquo;guardrail deterministico&rdquo; che compensa la natura probabilistica del modello.
Allo stesso tempo, per√≤, vale la pena riflettere sul fatto che, in generale, lo stesso concetto vale anche per gli esseri umani: lo stesso sviluppatore, leggendo la stessa specifica in due momenti diversi, pu√≤ scrivere codice diverso.</li><li><strong>Garbage in, garbage out (spostato di livello).</strong> Se uso un LLM per generare le specifiche stesse, chi le valida? Il rischio √® di automatizzare la produzione di specifiche plausibili ma errate ‚Äî ad esempio, un modello dati che sembra ragionevole ma viola una regola di business non esplicitata. La revisione umana delle specifiche non √® opzionale: √® il punto di controllo critico dell&rsquo;intero workflow.</li><li><strong>Scalabilit√†.</strong> L&rsquo;esempio della libreria di libri funziona bene, ma cosa succede con un sistema distribuito di 200 microservizi? L&rsquo;SDD scala bene fino a quando le specifiche restano modularizzabili ‚Äî un servizio alla volta, una feature alla volta. Quando le dipendenze cross-service diventano troppo intricate, le specifiche rischiano di diventare esse stesse un problema di manutenzione. Non √® un motivo per non adottare l&rsquo;SDD, ma √® un motivo per non pensarla come una bacchetta magica.</li><li><strong>Costi.</strong> Un workflow SDD completo (specify ‚Üí clarify ‚Üí plan ‚Üí tasks ‚Üí implement) consuma significativamente pi√π token di un singolo prompt. Ogni fase √® una o pi√π chiamate all&rsquo;LLM, ognuna con il proprio contesto. Su modelli di punta come Claude Opus o GPT-4, un ciclo completo per una feature di media complessit√† pu√≤ costare tra i 5 e i 20 dollari in token. √à un investimento che si ripaga ampiamente in termini di tempo risparmiato, ma va pianificato ‚Äî soprattutto per team che lavorano su decine di feature in parallelo.</li><li><strong>Overhead per progetti semplici.</strong> Un workflow SDD completo per uno script di 50 righe √® over-engineering. L&rsquo;SDD d√† il meglio su feature con complessit√† medio-alta, dove le ambiguit√† sono il vero costo. Per task banali, un buon prompt diretto resta la scelta migliore.</li></ul><p>Tutti questi limiti sono tuttavia gestibili attraverso un approccio disciplinato e consapevole. In altre parole, un approccio naive in stile &ldquo;vibe-coding&rdquo; pu√≤ andar bene per un piccolo prototipo, ma all&rsquo;aumentare della complessit√† del progetto √® necessario applicare le tecniche di SDD sempre con maggior rigore per evitare di incorrere in questi problemi.</p><h2 id=conclusioni>Conclusioni</h2><p>La Spec-Driven Development non √® una moda passeggera n√© un esercizio accademico.</p><p>L&rsquo;SDD √® un approccio metodologico e disciplinato allo sviluppo del software tramite AI Agents, che sfrutta le capacit√† degli agenti su tutto lo stack di sviluppo, dalla esplorazione dello spazio delle soluzioni, alla scrittura di specifiche dettagliate, alla pianificazione tecnica, fino all&rsquo;implementazione e al testing.</p><p>Ma come abbiamo visto, non √® priva di limiti: il non-determinismo degli LLM, il rischio di specifiche errate, i costi in token e l&rsquo;overhead per progetti semplici sono tutti fattori da considerare. L&rsquo;SDD funziona meglio quando applicata con giudizio, non come dogma.</p><p>Per chi lavora nello sviluppo software oggi, il messaggio √® chiaro:</p><ol><li><strong>Investite nelle competenze trasversali</strong>: architettura, DevOps, modelli dati, sicurezza. Il Progettista del futuro non √® chi scrive il codice pi√π veloce, ma chi scrive le specifiche pi√π precise.</li><li><strong>Adottate gradualmente</strong>: partite con l&rsquo;API-first e i contract test. Poi aggiungete un framework SDD come Spec Kit su una feature nuova. Misurate i risultati.</li><li><strong>Abbandonate il Vibe Coding</strong>: scrivere prompt vaghi e sperare nel meglio non scala. Investire una giornata in specifiche per risparmiare due settimane di lavoro non √® &ldquo;perdere tempo&rdquo; ‚Äî √® il mestiere del Progettista.</li><li><strong>Preparatevi al cambio di mentalit√†</strong>: sar√† meno &ldquo;divertente&rdquo; nel senso tradizionale, ma la soddisfazione di orchestrare un sistema complesso attraverso specifiche che producono software funzionante √®, a suo modo, altrettanto appagante.</li></ol><p>Il futuro dello sviluppo software non √® scrivere codice. √à progettare sistemi e lasciare che il codice si scriva da solo ‚Äî ma sotto il controllo rigoroso di chi sa cosa vuole ottenere.</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Aggiornato il February 14, 2026</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Condividi su X" data-sharer=x data-url=https://c-daniele.github.io/it/posts/2026-02-14-intro-spec-driven-development/ data-title="La transizione Sviluppatore --> Progettista" data-hashtags=GenAI,Agents,Coding><i class="fab fa-x-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Condividi su Threads" data-sharer=threads data-url=https://c-daniele.github.io/it/posts/2026-02-14-intro-spec-driven-development/ data-title="La transizione Sviluppatore --> Progettista"><i class="fab fa-threads fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Condividi su Facebook" data-sharer=facebook data-url=https://c-daniele.github.io/it/posts/2026-02-14-intro-spec-driven-development/ data-hashtag=GenAI><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Condividi su Hacker News" data-sharer=hackernews data-url=https://c-daniele.github.io/it/posts/2026-02-14-intro-spec-driven-development/ data-title="La transizione Sviluppatore --> Progettista"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Condividi su Line" data-sharer=line data-url=https://c-daniele.github.io/it/posts/2026-02-14-intro-spec-driven-development/ data-title="La transizione Sviluppatore --> Progettista"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@15.14.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Condividi su ÂæÆÂçö" data-sharer=weibo data-url=https://c-daniele.github.io/it/posts/2026-02-14-intro-spec-driven-development/ data-title="La transizione Sviluppatore --> Progettista"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Condividi su Diaspora" data-sharer=diaspora data-url=https://c-daniele.github.io/it/posts/2026-02-14-intro-spec-driven-development/ data-title="La transizione Sviluppatore --> Progettista" data-description><i class="fab fa-diaspora fa-fw" aria-hidden=true></i></a><a href="https://t.me/share/url?url=https%3a%2f%2fc-daniele.github.io%2fit%2fposts%2f2026-02-14-intro-spec-driven-development%2f&amp;text=La%20transizione%20Sviluppatore%20--%3e%20Progettista" target=_blank title="Condividi su Telegram"><i class="fab fa-telegram fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/it/tags/genai/>GenAI</a>,&nbsp;<a href=/it/tags/agents/>Agents</a>,&nbsp;<a href=/it/tags/coding/>Coding</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Indietro</a></span>&nbsp;|&nbsp;<span><a href=/it/>Home</a></span></section></div><div class=post-nav><a href=/it/posts/2025-11-10-genai-frameworks-update/ class=prev rel=prev title="Perch√© LangChain √® ancora il miglior framework per la GenAI"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Perch√© LangChain √® ancora il miglior framework per la GenAI</a></div></div></article></div></main></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Torna all'inizio"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i></a></div><div id=fixed-buttons-hidden><a href=# id=view-comments class=fixed-button title="Vedi commenti"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script src=/lib/lunr/lunr.stemmer.support.min.js></script><script src=/lib/lunr/lunr.it.min.js></script><script src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.2/sharer.min.js></script><script>window.config={comment:{},search:{highlightTag:"em",lunrIndexURL:"/it/index.json",lunrLanguageCode:"it",maxResultLength:10,noResultsFound:"Nessun risultato trovato",snippetLength:30,type:"lunr"}}</script><script src=/js/theme.min.js></script><script>var dnt,doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-8NZQZ3Z1RN")}</script><script src="https://www.googletagmanager.com/gtag/js?id=G-8NZQZ3Z1RN" async></script></body></html>