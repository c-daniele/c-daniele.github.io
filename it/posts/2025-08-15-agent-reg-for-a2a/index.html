<!doctype html><html lang=it dir=ltr><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Agent-Reg: Costruire un Agent Registry aperto per il Protocollo A2A | Cdani's Blog</title><meta name=keywords content="ai,agent,A2A"><meta name=description content="Introduzione Tra una cosa e l&rsquo;altra, in queste incandescenti giornate di agosto, ne ho approfittato per leggere bene la specifica del protocollo A2A di Google e provare a capire come utilizzarne i concetti per disegnare una un&rsquo;architettura enterprise di Agenti, possibilmente slegata da vincoli di piattaforma tecnologica.
Che cos&rsquo;è A2A? Il Protocollo Agent2Agent (A2A) è uno standard aperto progettato e condiviso pubblicamente da Google per facilitare la comunicazione e la collaborazione degli agenti AI."><meta name=author content="Me"><link rel=canonical href=https://c-daniele.github.io/it/posts/2025-08-15-agent-reg-for-a2a/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.3598bbf45621a4ad34d093926efeb15d6df27175e085d2f069483f14ad39d7fa.css integrity="sha256-NZi79FYhpK000JOSbv6xXW3ycXXghdLwaUg/FK051/o=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://c-daniele.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://c-daniele.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://c-daniele.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://c-daniele.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://c-daniele.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=it href=https://c-daniele.github.io/it/posts/2025-08-15-agent-reg-for-a2a/><link rel=alternate hreflang=en href=https://c-daniele.github.io/en/posts/2025-08-15-agent-reg-for-a2a/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0,theme:"default",securityLevel:"loose"})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-8NZQZ3Z1RN"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-8NZQZ3Z1RN",{anonymize_ip:!1})}</script><meta property="og:title" content="Agent-Reg: Costruire un Agent Registry aperto per il Protocollo A2A"><meta property="og:description" content="Introduzione Tra una cosa e l&rsquo;altra, in queste incandescenti giornate di agosto, ne ho approfittato per leggere bene la specifica del protocollo A2A di Google e provare a capire come utilizzarne i concetti per disegnare una un&rsquo;architettura enterprise di Agenti, possibilmente slegata da vincoli di piattaforma tecnologica.
Che cos&rsquo;è A2A? Il Protocollo Agent2Agent (A2A) è uno standard aperto progettato e condiviso pubblicamente da Google per facilitare la comunicazione e la collaborazione degli agenti AI."><meta property="og:type" content="article"><meta property="og:url" content="https://c-daniele.github.io/it/posts/2025-08-15-agent-reg-for-a2a/"><meta property="og:image" content="https://c-daniele.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-15T00:00:00+02:00"><meta property="article:modified_time" content="2025-08-15T00:00:00+02:00"><meta property="og:site_name" content="Cdani's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://c-daniele.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Agent-Reg: Costruire un Agent Registry aperto per il Protocollo A2A"><meta name=twitter:description content="Introduzione Tra una cosa e l&rsquo;altra, in queste incandescenti giornate di agosto, ne ho approfittato per leggere bene la specifica del protocollo A2A di Google e provare a capire come utilizzarne i concetti per disegnare una un&rsquo;architettura enterprise di Agenti, possibilmente slegata da vincoli di piattaforma tecnologica.
Che cos&rsquo;è A2A? Il Protocollo Agent2Agent (A2A) è uno standard aperto progettato e condiviso pubblicamente da Google per facilitare la comunicazione e la collaborazione degli agenti AI."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"Agent-Reg: Costruire un Agent Registry aperto per il Protocollo A2A","item":"https://c-daniele.github.io/it/posts/2025-08-15-agent-reg-for-a2a/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Agent-Reg: Costruire un Agent Registry aperto per il Protocollo A2A","name":"Agent-Reg: Costruire un Agent Registry aperto per il Protocollo A2A","description":"Introduzione Tra una cosa e l\u0026rsquo;altra, in queste incandescenti giornate di agosto, ne ho approfittato per leggere bene la specifica del protocollo A2A di Google e provare a capire come utilizzarne i concetti per disegnare una un\u0026rsquo;architettura enterprise di Agenti, possibilmente slegata da vincoli di piattaforma tecnologica.\nChe cos\u0026rsquo;è A2A? Il Protocollo Agent2Agent (A2A) è uno standard aperto progettato e condiviso pubblicamente da Google per facilitare la comunicazione e la collaborazione degli agenti AI.","keywords":["ai","agent","A2A"],"articleBody":"Introduzione Tra una cosa e l’altra, in queste incandescenti giornate di agosto, ne ho approfittato per leggere bene la specifica del protocollo A2A di Google e provare a capire come utilizzarne i concetti per disegnare una un’architettura enterprise di Agenti, possibilmente slegata da vincoli di piattaforma tecnologica.\nChe cos’è A2A? Il Protocollo Agent2Agent (A2A) è uno standard aperto progettato e condiviso pubblicamente da Google per facilitare la comunicazione e la collaborazione degli agenti AI. La standardizzazione del modello di interoperabilità dell’AI è un tema di cui si parla già dai primissimi momenti in cui si è iniziato a parlare di Agenti ed i motivi sono diversi:\nestrema eterogeneità, sia in termini di implementazione, di funzionalità e di modello d’ingaggio ed esecuzione dei task la tendenza verso la specializzazione fa sì che l’esecuzione di task complessi necessiterà di collaborazione tra Agenti in maniera sempre più pressante molte aziende hanno già sviluppato le prime soluzioni agentiche, ma per poterle scalare ed estenderle a nuovi contesti, è fondamentale avere un modello di interoperabilità future-proof e aperto. In assenza di uno standard condiviso e stabile, esiste un concreto rischio di lock-in. A2A identifica 5 elementi fondamentali per risolvere questi problemi:\nIl protocollo di trasporto A2A prevede 3 protocolli di trasporto alternativi, tutti basati su HTTPS e stabilisce che un agente A2A-compliant debba necessariamente implementarne almeno uno di essi\nJSON-RPC 2.0 gRPC HTTP+JSON/REST Le Agent Card Si tratta dello strumento principale per condividere le caratteristiche tecniche e funzionali degli agenti secondo uno schema standard definito in linguaggio JSON. Le “Agent Card” sono come una sorta di interface agreement esposto dall’agente che, oltre a definire i puntamenti e i tecnicismi per l’autenticazione e l’interoperabilità, definisce anche in maniera descrittiva lo scopo dell’agente e le sue capabilities (es: supporto allo streaming o push notifications). A2A impone che ogni agente debba sempre esporre la propria Agent Card in modo che possa essere facilmente scoperta e utilizzata da altri agenti e client.\nIn un contesto multi-agente, una determinata organizzazione deve dunque fare 2 cose:\ndefinire un modo per esporre queste “Agent Card” (come vedremo, A2A suggerisce l’utilizzo di un Well-known URI secondo lo standard RFC 8615) conoscere in ogni momento quali sono le AgentCard a disposizione dell’organizzazione, sapere dove trovarle e magari anche lo stato di salute (healthy/inactive) Questi 2 punti possono essere sintetizzati tramite il concetto di Discovery che a mio avviso non è affrontato in maniera esaustiva nelle specifiche ufficiali. Queste riflessioni mi hanno portato a considerare l’implementazione di un Agent Registry home-made.\nIl ciclo di vita dei task A2A classifica le tipologie di task e ne definisce il ciclo di vita. Ad esempio, un task potrebbe completarsi con un singolo messaggio di risposta (stateless) oppure, più frequentemente, essere un oggetto stateful che transita attraverso diversi stati. I client possono dunque far riferimento ad un task attraverso un taskId restituito dall’agente per tutto il ciclo di vita che può anche essere di lunga durata o richiedere più interazioni. Similmente, A2A prevede che nel primo messaggio di risposta, l’agente fornisca anche un contextId per gestire il riferimento al contesto del modello LLM sottostante. La cosa interessante è che il contextId può anche andare oltre il ciclo di vita del singolo task. In questa maniera, i client hanno la possibilità di scomporre autonomamente alcuni processi complessi in task più semplici ed autoconsistenti che però fanno riferimento al medesimo contesto conosciuto e memorizzato dall’agente.\nInterscambio di dati A2A fa una distinzione tra:\nMessages: rappresentano una singola interazione o un’informazione contestuale tra un client e un agente. I messaggi indicano sempre il ruolo del sender (user oppure agent) e vengono utilizzati per istruzioni, prompt, risposte e aggiornamenti di stato. Artifacts: rappresentano il vero output del task e vengono dunque generati alla fine dell’esecuzione Sia i messaggi che gli artefatti sono composti da unità atomiche denominate part, ciascuna delle quali può essere di tipo TextPart, FilePart o DataPart e può contenere anche metadati che aiutano a descriverne il contenuto.\nSicurezza e gestione delle interazioni asincrone Gli agenti devono autenticare tutte le richieste, in conformità con le specifiche definite nel SecurityScheme della propria AgentCard. A2A prevede che i server possano implementare l’autenticazione tramite i metodi più comuni come, ad esempio:\nOAuth 2.0 API Key OpenAI HTTP Basic Auth Mutual TLS (mTLS) Il tema della sicurezza è importante anche per quel che riguarda le Push Notifications, ovvero quel meccanismo che consente agli agenti di inviare aggiornamenti ai client in modo proattivo, tramite la predisposizione da parte dei client di un Webhook dedicato. A2A prevede un processo di Webhook validation, al fine di evitare attacchi di tipo SSRF.\nAgent Discovery Approcci per la Agent Discovery previsti in A2A Come accennato prima, secondo A2A ogni agente deve produrre una Agent Card secondo le specifiche indicate dal protocollo stesso. Questo documento è dunque di fondamentale importanza per la fase di Agent Discovery, la quale può essere implementata almeno in uno di questi 3 modi (ma A2A lascia spazio anche ad altre alternative):\nUtilizzo di Well-Known URI: Segue i principi dell’ RFC 8615 secondo cui viene riservato un percorso particolare (\".well-known\") all’interno degli URI per la condivisione di metadati su una specifica risorsa web. In altre parole, a partire da un dominio (es: www.example.com) e da una risorsa esposta all’interno del dominio (es: “my_resource”), lo standard RFC 8615 definisce il concetto di “Well Known URI” per la risorsa uguale a http://www.example.com/.well-known/my_resource. Secondo il protocollo A2A, le AgentCard potrebbero dunque essere esposte nativamente da parte degli Agent Server tramite degli URI tipo: https://{server_domain}/.well-known/agent-card.json (vedi Sezione 5.3). Agent Registry: Interrogazione di un catalogo centralizzato di agenti, che può essere pubblico o privato. Configurazione diretta: Le applicazioni client possono tranquillamente essere pre-configurate con tutte le informazioni presenti nella Agent Card degli Agent Server a cui deve accedere (per esempio con un inserimento diretto della AgentCard nel codice applicativo). Breve confronto Facendo riferimento alle 3 modalità di cui sopra, la terza mi sembra un brutale hard-coding di configurazioni punto-punto ed è sicuramente non elegante e non scalabile. La soluzione 1 è un mero tecnicismo che rimanda semplicemente ad uno standard per l’integrazione tra sistemi nel WEB e di per sè non risolve in alcun modo il problema, perché le applicazioni (o gli agenti) client non sanno a priori quali sono le risorse (ovvero gli Agenti) da ricercare e verso cui indirizzare le chiamate HTTP verso i percorsi “well-known”. A mio avviso, l’unica vera soluzione è la numero 2, ovvero l’utilizzo di un registro centralizzato, che consenta:\nagli Agenti: di essere condivisi e messi a disposizione dell’organizzazione ai client: di conoscere quali sono gli agenti a disposizione e le loro caratteristiche di interfaccia Dal mio punto di vista, accanto a questi 2 macro-requisiti basilari, l’Agent Registry potrebbe anche fornire alcune funzionalità ausiliari per far funzionare tutto l’ecosistema A2A, come ad esempio:\nun meccanismo di healthcheck, per conoscere lo stato di salute dell’agente un motore di ricerca per skill, ma anche per capability, tags, descrizione o nome del provider, … regole di autorizzazione per la consultazione e l’accesso verso agenti acquisto diretto per accesso ad agenti “premium” (Agent Marketplace) Tuttavia, A2A non definisce nulla di più in merito a come questi Agent Registry devono essere fatti e le specifiche che dovrebbero avere. Anzi, nella specifica del protocollo è scritto chiaramente\nThe A2A protocol does not currently define a standard API for such registries, though this is an area of potential future exploration and community standardization\nSoluzioni aperte per l’Agent Registry Volendo disegnare un’architettura agnostica e possibilmente “open”, ho fatto qualche ricerca per identificare eventuali tool di mercato che offrono questo tipo di funzionalità e, sorprendentemente, non ho trovato nulla. Anche nelle piattaforme leader di mercato, che promuovono lo sviluppo di architetture multi-agente e di applicazioni agentiche a livello enterprise, mi sembra (ma potrei sbagliarmi) che al momento non ci siano molti segnali di apertura verso questa parte del protocollo A2A.\nD’altro canto, mi sembra naturale che in questa fase di transizione i big del settore (hyperscalers e big tech) stiano cercando di creare un ecosistema chiuso, dove ogni cliente sviluppa, pubblica ed esegue i propri agenti. In questo scenario, è facile immaginare che ci sia una certa resistenza a standardizzare e aprire l’accesso ad Agent Registries veramente aperti ed interoperabili.\nFatte queste considerazioni, ho pensato: “ok ci metto un po’ di impegno, ma soprattutto un po’ di vibe-coding e me lo sviluppo da solo” 🛠️\nIntroduzione ad Agent-Reg Che cos’è Agent-Reg? Agent-Reg è una implementazione minimale ed open source di un Agent Registry, in maniera conforme alle specifiche A2A. Fornisce una soluzione centralizzata per la discovery e la manutenzione di agenti conformi ad A2A in un modo semplice ed interoperabile. Trovate il codice qui: Agent-Reg GitHub Repository\nLa soluzione può essere rilasciata ovunque ed è stata progettata mantenendo una completa apertura e indipendenza dalla piattaforma. Nel suo nucleo, Agent-Reg risolve il problema della Discovery attraverso:\nUniversal Agent Discovery: Un catalogo ricercabile di tutti gli agenti disponibili A2A Protocol Compliance: Supporto per la specifica Agent2Agent e validazione completa in fase di registrazione Health Monitoring: Tracciamento real-time della disponibilità e dello stato degli agenti (heartbeat) Advanced Search: Ricerca multi-criterio per skill, capabilities, ownership e altri attributi descrittivi Panoramica dell’Architettura L’architettura è estremamente semplice e, anche se alcune scelte implementative non sono ancora ottimizzate per la scalabilità (per esempio, l’utilizzo di SQLite), fornisce una base di partenza su cui poter costruire le proprie customizzazioni.\ngraph TB subgraph \"Client Layer\" UI[React Frontend] CLI[CLI Tools] EXT[External Clients] end subgraph \"API Layer\" GATEWAY[FastAPI Gateway] CORS[CORS Middleware] VALID[Schema Validator] end subgraph \"Business Layer\" REG[Agent Registry Service] HEART[Heartbeat Manager] SEARCH[Search \u0026 Filter Engine] end subgraph \"Data Layer\" DB[(SQLite with JSON)] SCHEMA[A2A JSON Schema] end UI --\u003e GATEWAY CLI --\u003e GATEWAY EXT --\u003e GATEWAY GATEWAY --\u003e CORS CORS --\u003e VALID VALID --\u003e REG REG --\u003e HEART REG --\u003e SEARCH REG --\u003e DB VALID --\u003e SCHEMA Macrocomponenti Backend Il backend è stato sviluppato utilizzando FastAPI, un framework Python moderno che fornisce documentazione API automatica, validazione dei tipi ed eccellenti prestazioni. Altre caratteristiche di rilievo:\nSQLite with JSON extension per la memorizzazione dei dati: un database leggero e ultraconsolidato, con supporto NoSQL tramite JSON, che richiede zero configurazione infrastrutturale aggiuntiva, rendendo semplice il deployment e fornendo prestazioni sufficienti almeno per un PoC o un prototipo funzionante, in grado di gestire qualche migliaio di oggetti Strict A2A Schema Validation: Ogni registrazione di agente è validata rispetto allo schema ufficiale di A2A per garantire la conformità al protocollo RESTful API Design: Endpoint puliti e intuitivi che seguono le specifiche OpenAPI 3.0 Frontend L’interfaccia web è costruita con React 18 e TypeScript, fornendo un’esperienza moderna e responsive per la gestione degli agenti:\nTailwind CSS: Framework CSS semplice e pulito Real-time Updates: Monitoraggio live dello stato e salute degli agenti Advanced Filtering: Interfaccia di ricerca intuitiva con criteri multipli Homepage di Agent-Reg Come Funziona la Registrazione degli Agenti Il processo di registrazione di un Agente su Agent-Reg assicura che solo gli agenti validi e conformi alle specifiche A2A possano unirsi al registry. Di seguito è riportato un diagramma di sequenza che illustra il flusso di registrazione end-to-end:\nsequenceDiagram participant Client participant API participant Validator participant Registry participant Database Client-\u003e\u003eAPI: POST /agents/register API-\u003e\u003eValidator: Validate Agent Card Validator-\u003e\u003eValidator: Check A2A Schema Compliance alt Valid Agent Card Validator--\u003e\u003eAPI: Valid ✓ API-\u003e\u003eRegistry: Store Agent Registry-\u003e\u003eRegistry: Generate UUID Registry-\u003e\u003eRegistry: Add Timestamps Registry-\u003e\u003eDatabase: Insert Agent Document Database--\u003e\u003eRegistry: Confirmation Registry--\u003e\u003eAPI: Agent Record API--\u003e\u003eClient: 201 Created + Agent ID else Invalid Agent Card Validator--\u003e\u003eAPI: Validation Errors API--\u003e\u003eClient: 422 Unprocessable Entity end Quando un agente vuole registrarsi con Agent-Reg, deve fornire la sua Agent Card. La piattaforma esegue una validazione dell’Agent Card per garantire la conformità, rifiutando la richiesta qualora non siano soddisfatti i requisiti del protocollo. Qualora la validazione abbia esito positivo, l’agente viene registrato a sistema e viene dunque ritornato un identificativo univoco, che l’Agente può in seguito utilizzare per effettuare operazioni sul registro (es: heartbeat).\nA livello di interfaccia frontend, la registrazione avviene caricando un’Agent Card o fornendo il percorso di rete verso il descrittore /.well-known/agent-card.json\nSmart Agent Discovery Agent-Reg fornisce un semplicissimo motore di ricerca che consente agli utenti di scoprire gli agenti di interesse in base a vari criteri. Il diagramma seguente illustra l’architettura del motore di ricerca e i filtri applicati:\ngraph LR subgraph \"Search Filters\" NAME[Name Filter] SKILL[Skill Filter] CAP[Capabilities Filter] OWNER[Owner Filter] ALIVE[Liveness Filter] end subgraph \"Search Engine\" FILTER[Filter Logic] HEART[Heartbeat Check] SORT[Result Sorting] end subgraph \"Results\" LIST[Agent List] META[Metadata] COUNT[Total Count] end NAME --\u003e FILTER SKILL --\u003e FILTER CAP --\u003e FILTER OWNER --\u003e FILTER ALIVE --\u003e HEART FILTER --\u003e SORT HEART --\u003e SORT SORT --\u003e LIST SORT --\u003e META SORT --\u003e COUNT Capacità di Ricerca I criteri di ricerca sono dunque i seguenti:\nBy Name: Ricerca testuale semplice basata sul nome dell’agente By Skills: Trova gli agenti che dichiarano skills specifiche (es. “route-planning”, “image-processing”, etc) By Capabilities: Filtra gli agenti basandosi sulle capabilities dichiarate nell’agent card secondo quanto previsto nel protocollo A2A (streaming, push notifications, etc) By Owner: Mostra gli agenti gestiti da team o organizzazioni specifiche By Liveness: Mostra solo gli agenti che sono attualmente attivi secondo l’heartbeat periodico. Health Monitoring In uno scenario realistico, gli agenti saranno molti e potenzialmente instabili a causa della loro continua evoluzione e manutenzione (basti pensare ad un cambio nel prompt o nel modello), ma anche a causa della complessa rete di dipendenze. Ad esempio, un Agente può dipendere da servizi o API esterni ma anche da altri Agenti. Agent-Reg prevede un meccanismo di heartbeat, dove gli agenti registrati notificano periodicamente al registry il loro stato di salute. Questo permette al registry di:\nFornire ai client informazioni sullo stato di salute in tempo reale Filtrare automaticamente gli agenti non responsivi secondo quanto ritornato dai risultati di ricerca Abilitare il monitoraggio proattivo e l’alerting per agenti critici Data Model e Conformità A2A Agent-Reg aderisce alla specifica del protocollo A2A per la struttura delle agent card, ma è ovviamente un modello semplificato ed estendibile. Ad esempio, non include le definizioni specifiche dei SecurityScheme nelle sue 5 varianti. Di seguito un class diagram che illustra il modello dati logico:\nclassDiagram class AgentCard { +string name +string description +string version +string protocolVersion +string url +AgentSkill[] skills +AgentCapabilities capabilities +string[] defaultInputModes +string[] defaultOutputModes +string preferredTransport +AgentProvider provider +string documentationUrl +string iconUrl +AgentInterface[] additionalInterfaces +SecurityRequirement[] security +SecuritySchemes securitySchemes +AgentCardSignature[] signatures +boolean supportsAuthenticatedExtendedCard } class AgentSkill { +string id +string name +string description +string[] tags +string[] examples +string[] inputModes +string[] outputModes +SecurityRequirement[] security } class AgentCapabilities { +boolean streaming +boolean stateTransitionHistory +boolean pushNotifications +AgentExtension[] extensions } class AgentProvider { +string organization +string url } AgentCard \"1\" --\u003e \"0..*\" AgentSkill : contains AgentCard \"1\" --\u003e \"1\" AgentCapabilities : has AgentCard \"1\" --\u003e \"0..1\" AgentProvider : provided by Backend APIs Agent-Reg fornisce una REST API completa con alcuni metodi che implementano le operazioni principali:\nOperazione Endpoint Descrizione Agent Registration POST /agents/register Registra un nuovo agente conforme A2A Agent Discovery GET /agents Cerca e filtra agenti con vari criteri Agent Details GET /agents/{id} Recupera informazioni complete su un agente specifico Health Check POST /agents/{id}/heartbeat Aggiorna lo stato liveness dell’agente Invocation Info GET /agents/{id}/invoke_url Ottieni dettagli di invocazione diretta Esempio di Utilizzo nel Mondo Reale Vediamo come Agent-Reg funziona nella pratica. Immagina di stare costruendo un’applicazione per la pianificazione di viaggi che ha bisogno di trovare un agente di pianificazione percorsi con capabilities di traffico real-time:\n# Search for agents with route planning skills and streaming capability curl \"http://localhost:8000/agents?skill=route-optimizer-traffic\u0026capabilities=streaming\u0026only_alive=true\" Il registry restituirà solo agenti attivi che corrispondono a questi criteri, completi dei loro URL di invocazione, requisiti di sicurezza e dettagli delle capability.\nA livello di interfaccia utente, è possibile fare la stessa cosa tramite la barra di ricerca. Perché Agent-Reg? Agent-Reg cerca di risolvere il problema della Discovery in un ecosistema di agenti basati sullo standard A2A e può essere potenzialmente utile anche per affrontare i temi di sicurezza e governance nelle applicazioni basate su agenti. Ho provato a sintetizzare i pillar principali su cui vorrei far evolvere il tool:\nInteroperabilità: agenti eterogenei che aderiscono allo standard possono lavorare insieme senza necessità di collegamenti punto-punto o integrazioni complesse e ridondanti Discovery: Le organizzazioni possono mantenere un catalogo completo e costantemente aggiornato dei loro Agenti Affidabilità: Il meccanismo di heartbeat assicura che i client interagiscano solo con agenti responsivi Scalabilità: L’architettura può gestire migliaia di agenti senza requisiti infrastrutturali complessi Apertura: E’ una soluzione open-source, che può essere distribuita ovunque, previene il vendor lock-in e incoraggia l’innovazione Come Iniziare Agent-Reg manca ancora di diverse funzionalità ed ottimizzazioni necessarie prima di poterlo realmente usare in un ambiente produttivo (es: autenticazione ed autorizzazione, gestione degli errori, logging, notifiche, supporto ad altri NoSql DB, …), ma è una base su cui costruire un piccolo ecosistema aperto ed estendibile. Avviarlo è semplicissimo:\n# Backend setup cd backend/app pip install -r requirements.txt python src/main.py # Frontend setup cd frontend npm install npm start Conclusioni In questo periodo di forte dinamismo in ambito AI, il protocollo A2A fa un passo molto importante, perché mette a fattor comune alcuni concetti di base su cui poter costruire una reale standardizzazione, ma da questo punto di vista a mio avviso non siamo ancora in una fase di maturità. Le specifiche in sé non sono scritte male, ma sono abbastanza generiche (provate a fare il confronto con altri standard, tipo quello di HTTP/2 per capire cosa intendo…) e lasciano ancora molti spazi per estensioni o integrazioni. Uno dei punti importanti che mi sembra sia stato tralasciato è quello della Discovery, per cui ho cercato di immaginare una soluzione centralizzata e aperta.\nLa metto a disposizione della collettività, sperando che qualche volontario possa aiutarmi contribuendo al suo sviluppo! 😊\n","wordCount":"2925","inLanguage":"it","datePublished":"2025-08-15T00:00:00+02:00","dateModified":"2025-08-15T00:00:00+02:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://c-daniele.github.io/it/posts/2025-08-15-agent-reg-for-a2a/"},"publisher":{"@type":"Organization","name":"Cdani's Blog","logo":{"@type":"ImageObject","url":"https://c-daniele.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://c-daniele.github.io/it/ accesskey=h title="Home (Alt + H)"><img src=https://c-daniele.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://c-daniele.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://c-daniele.github.io/it/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://c-daniele.github.io/it/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://c-daniele.github.io/it/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://c-daniele.github.io/it/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://c-daniele.github.io/it/>Home</a></div><h1 class=post-title>Agent-Reg: Costruire un Agent Registry aperto per il Protocollo A2A</h1><div class=post-meta><span title='2025-08-15 00:00:00 +0200 +0200'>agosto 15, 2025</span>&nbsp;·&nbsp;14 minuti&nbsp;·&nbsp;2925 parole&nbsp;·&nbsp;Me&nbsp;|&nbsp;Traduzioni:<ul class=i18n_list><li><a href=https://c-daniele.github.io/en/posts/2025-08-15-agent-reg-for-a2a/>En</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Indice contenuti</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#che-cosè-a2a>Che cos&rsquo;è A2A?</a><ul><li><a href=#il-protocollo-di-trasporto>Il protocollo di trasporto</a></li><li><a href=#le-agent-card>Le <em>Agent Card</em></a></li><li><a href=#il-ciclo-di-vita-dei-task>Il ciclo di vita dei task</a></li><li><a href=#interscambio-di-dati>Interscambio di dati</a></li><li><a href=#sicurezza-e-gestione-delle-interazioni-asincrone>Sicurezza e gestione delle interazioni asincrone</a></li></ul></li><li><a href=#agent-discovery>Agent Discovery</a><ul><li><a href=#approcci-per-la-agent-discovery-previsti-in-a2a>Approcci per la Agent Discovery previsti in A2A</a></li><li><a href=#breve-confronto>Breve confronto</a></li></ul></li></ul><ul><li><a href=#che-cosè-agent-reg>Che cos&rsquo;è Agent-Reg?</a></li><li><a href=#panoramica-dellarchitettura>Panoramica dell&rsquo;Architettura</a><ul><li><a href=#macrocomponenti>Macrocomponenti</a></li></ul></li><li><a href=#come-funziona-la-registrazione-degli-agenti>Come Funziona la Registrazione degli Agenti</a></li><li><a href=#smart-agent-discovery>Smart Agent Discovery</a><ul><li><a href=#capacità-di-ricerca>Capacità di Ricerca</a></li><li><a href=#health-monitoring>Health Monitoring</a></li></ul></li><li><a href=#data-model-e-conformità-a2a>Data Model e Conformità A2A</a></li><li><a href=#backend-apis>Backend APIs</a></li><li><a href=#esempio-di-utilizzo-nel-mondo-reale>Esempio di Utilizzo nel Mondo Reale</a></li><li><a href=#perché-agent-reg>Perché Agent-Reg?</a></li><li><a href=#come-iniziare>Come Iniziare</a></li></ul></nav></div></details></div><div class=post-content><h1 id=introduzione>Introduzione<a hidden class=anchor aria-hidden=true href=#introduzione>#</a></h1><p>Tra una cosa e l&rsquo;altra, in queste incandescenti giornate di agosto, ne ho approfittato per leggere bene la specifica del protocollo A2A di Google e provare a capire come utilizzarne i concetti per disegnare una un&rsquo;architettura enterprise di Agenti, possibilmente slegata da vincoli di piattaforma tecnologica.</p><h2 id=che-cosè-a2a>Che cos&rsquo;è A2A?<a hidden class=anchor aria-hidden=true href=#che-cosè-a2a>#</a></h2><p>Il Protocollo Agent2Agent (A2A) è uno standard aperto progettato e condiviso pubblicamente da Google per facilitare la comunicazione e la collaborazione degli agenti AI. La standardizzazione del modello di interoperabilità dell&rsquo;AI è un tema di cui si parla già dai primissimi momenti in cui si è iniziato a parlare di <em>Agenti</em> ed i motivi sono diversi:</p><ul><li>estrema eterogeneità, sia in termini di implementazione, di funzionalità e di modello d&rsquo;ingaggio ed esecuzione dei task</li><li>la tendenza verso la specializzazione fa sì che l&rsquo;esecuzione di task complessi necessiterà di collaborazione tra Agenti in maniera sempre più pressante</li><li>molte aziende hanno già sviluppato le prime soluzioni agentiche, ma per poterle scalare ed estenderle a nuovi contesti, è fondamentale avere un modello di interoperabilità future-proof e aperto. In assenza di uno standard condiviso e stabile, esiste un concreto rischio di lock-in.</li></ul><p>A2A identifica 5 elementi fondamentali per risolvere questi problemi:</p><h3 id=il-protocollo-di-trasporto>Il protocollo di trasporto<a hidden class=anchor aria-hidden=true href=#il-protocollo-di-trasporto>#</a></h3><p>A2A prevede 3 protocolli di trasporto alternativi, tutti basati su HTTPS e stabilisce che un agente A2A-compliant debba necessariamente implementarne almeno uno di essi</p><ol><li>JSON-RPC 2.0</li><li>gRPC</li><li>HTTP+JSON/REST</li></ol><h3 id=le-agent-card>Le <em>Agent Card</em><a hidden class=anchor aria-hidden=true href=#le-agent-card>#</a></h3><p>Si tratta dello strumento principale per condividere le caratteristiche tecniche e funzionali degli agenti secondo uno schema standard definito in linguaggio JSON.
Le &ldquo;Agent Card&rdquo; sono come una sorta di <em>interface agreement</em> esposto dall&rsquo;agente che, oltre a definire i puntamenti e i tecnicismi per l&rsquo;autenticazione e l&rsquo;interoperabilità, definisce anche in maniera descrittiva lo scopo dell&rsquo;agente e le sue capabilities (es: supporto allo streaming o push notifications).
A2A impone che ogni agente debba sempre esporre la propria <strong>Agent Card</strong> in modo che possa essere facilmente scoperta e utilizzata da altri agenti e client.</p><p>In un contesto multi-agente, una determinata organizzazione deve dunque fare 2 cose:</p><ol><li>definire un modo per esporre queste &ldquo;Agent Card&rdquo; (come vedremo, A2A suggerisce l&rsquo;utilizzo di un <em>Well-known URI</em> secondo lo standard <a href=https://datatracker.ietf.org/doc/html/rfc8615>RFC 8615</a>)</li><li>conoscere in ogni momento quali sono le AgentCard a disposizione dell&rsquo;organizzazione, sapere dove trovarle e magari anche lo stato di salute (healthy/inactive)</li></ol><p>Questi 2 punti possono essere sintetizzati tramite il concetto di <strong><a href=https://a2a-protocol.org/latest/topics/agent-discovery/#the-role-of-the-agent-card>Discovery</a></strong> che a mio avviso non è affrontato in maniera esaustiva nelle specifiche ufficiali. Queste riflessioni mi hanno portato a considerare l&rsquo;implementazione di un <strong>Agent Registry</strong> home-made.</p><h3 id=il-ciclo-di-vita-dei-task>Il ciclo di vita dei task<a hidden class=anchor aria-hidden=true href=#il-ciclo-di-vita-dei-task>#</a></h3><p>A2A classifica le tipologie di task e ne definisce il ciclo di vita. Ad esempio, un task potrebbe completarsi con un singolo messaggio di risposta (stateless) oppure, più frequentemente, essere un oggetto stateful che transita attraverso diversi stati. I client possono dunque far riferimento ad un task attraverso un <strong>taskId</strong> restituito dall&rsquo;agente per tutto il ciclo di vita che può anche essere di lunga durata o richiedere più interazioni. Similmente, A2A prevede che nel primo messaggio di risposta, l&rsquo;agente fornisca anche un <em>contextId</em> per gestire il riferimento al contesto del modello LLM sottostante. La cosa interessante è che il contextId può anche andare oltre il ciclo di vita del singolo task. In questa maniera, i client hanno la possibilità di scomporre autonomamente alcuni processi complessi in task più semplici ed autoconsistenti che però fanno riferimento al medesimo contesto conosciuto e memorizzato dall&rsquo;agente.</p><h3 id=interscambio-di-dati>Interscambio di dati<a hidden class=anchor aria-hidden=true href=#interscambio-di-dati>#</a></h3><p>A2A fa una distinzione tra:</p><ul><li><strong>Messages:</strong> rappresentano una singola interazione o un&rsquo;informazione contestuale tra un client e un agente. I messaggi indicano sempre il ruolo del sender (<em>user</em> oppure <em>agent</em>) e vengono utilizzati per istruzioni, prompt, risposte e aggiornamenti di stato.</li><li><strong>Artifacts:</strong> rappresentano il vero output del task e vengono dunque generati alla fine dell&rsquo;esecuzione</li></ul><p>Sia i messaggi che gli artefatti sono composti da unità atomiche denominate <em>part</em>, ciascuna delle quali può essere di tipo <em>TextPart</em>, <em>FilePart</em> o <em>DataPart</em> e può contenere anche metadati che aiutano a descriverne il contenuto.</p><h3 id=sicurezza-e-gestione-delle-interazioni-asincrone>Sicurezza e gestione delle interazioni asincrone<a hidden class=anchor aria-hidden=true href=#sicurezza-e-gestione-delle-interazioni-asincrone>#</a></h3><p>Gli agenti devono autenticare tutte le richieste, in conformità con le specifiche definite nel <em>SecurityScheme</em> della propria AgentCard. A2A prevede che i server possano implementare l&rsquo;autenticazione tramite i metodi più comuni come, ad esempio:</p><ul><li>OAuth 2.0</li><li>API Key</li><li>OpenAI</li><li>HTTP Basic Auth</li><li>Mutual TLS (mTLS)</li></ul><p>Il tema della sicurezza è importante anche per quel che riguarda le <em>Push Notifications</em>, ovvero quel meccanismo che consente agli agenti di inviare aggiornamenti ai client in modo proattivo, tramite la predisposizione da parte dei client di un Webhook dedicato.
A2A prevede un processo di Webhook validation, al fine di evitare attacchi di tipo SSRF.</p><h2 id=agent-discovery>Agent Discovery<a hidden class=anchor aria-hidden=true href=#agent-discovery>#</a></h2><h3 id=approcci-per-la-agent-discovery-previsti-in-a2a>Approcci per la Agent Discovery previsti in A2A<a hidden class=anchor aria-hidden=true href=#approcci-per-la-agent-discovery-previsti-in-a2a>#</a></h3><p>Come accennato prima, secondo A2A ogni agente <strong>deve</strong> produrre una Agent Card secondo le specifiche indicate dal protocollo stesso. Questo documento è dunque di fondamentale importanza per la fase di Agent Discovery, la quale può essere implementata almeno in uno di questi 3 modi (ma A2A lascia spazio anche ad altre alternative):</p><ol><li>Utilizzo di <strong>Well-Known URI:</strong> Segue i principi dell&rsquo; <a href=https://datatracker.ietf.org/doc/html/rfc8615>RFC 8615</a> secondo cui viene riservato un percorso particolare (".well-known") all&rsquo;interno degli URI per la condivisione di metadati su una specifica risorsa web. In altre parole, a partire da un dominio (es: <em><a href=https://www.example.com>www.example.com</a></em>) e da una risorsa esposta all&rsquo;interno del dominio (es: &ldquo;<em>my_resource</em>&rdquo;), lo standard RFC 8615 definisce il concetto di &ldquo;Well Known URI&rdquo; per la risorsa uguale a <a href=http://www.example.com/.well-known/my_resource>http://www.example.com/.well-known/my_resource</a>.<br>Secondo il protocollo A2A, le AgentCard potrebbero dunque essere esposte nativamente da parte degli Agent Server tramite degli URI tipo: https://{server_domain}/.well-known/agent-card.json (vedi <a href=https://a2a-protocol.org/latest/specification/#53-recommended-location>Sezione 5.3</a>).</li><li><strong>Agent Registry:</strong> Interrogazione di un catalogo centralizzato di agenti, che può essere pubblico o privato.</li><li><strong>Configurazione diretta:</strong> Le applicazioni client possono tranquillamente essere pre-configurate con tutte le informazioni presenti nella Agent Card degli Agent Server a cui deve accedere (per esempio con un inserimento diretto della AgentCard nel codice applicativo).</li></ol><h3 id=breve-confronto>Breve confronto<a hidden class=anchor aria-hidden=true href=#breve-confronto>#</a></h3><p>Facendo riferimento alle 3 modalità di cui sopra, la terza mi sembra un brutale hard-coding di configurazioni punto-punto ed è sicuramente non elegante e non scalabile.
La soluzione 1 è un mero tecnicismo che rimanda semplicemente ad uno standard per l&rsquo;integrazione tra sistemi nel WEB e di per sè non risolve in alcun modo il problema, perché le applicazioni (o gli agenti) client <strong>non sanno a priori quali sono le risorse (ovvero gli Agenti) da ricercare</strong> e verso cui indirizzare le chiamate HTTP verso i percorsi &ldquo;well-known&rdquo;.<br>A mio avviso, l&rsquo;unica vera soluzione è la numero 2, ovvero l&rsquo;utilizzo di un <strong>registro centralizzato</strong>, che consenta:</p><ul><li><strong>agli Agenti</strong>: di essere condivisi e messi a disposizione dell&rsquo;organizzazione</li><li><strong>ai client</strong>: di conoscere quali sono gli agenti a disposizione e le loro caratteristiche di interfaccia</li></ul><p>Dal mio punto di vista, accanto a questi 2 macro-requisiti basilari, l&rsquo;Agent Registry potrebbe anche fornire alcune funzionalità ausiliari per far funzionare tutto l&rsquo;ecosistema A2A, come ad esempio:</p><ul><li>un meccanismo di <strong>healthcheck</strong>, per conoscere lo stato di salute dell&rsquo;agente</li><li>un <strong>motore di ricerca</strong> per skill, ma anche per capability, tags, descrizione o nome del provider, &mldr;</li><li>regole di <strong>autorizzazione</strong> per la consultazione e l&rsquo;accesso verso agenti</li><li>acquisto diretto per accesso ad agenti &ldquo;premium&rdquo; (<strong>Agent Marketplace</strong>)</li></ul><p>Tuttavia, A2A non definisce nulla di più in merito a come questi Agent Registry devono essere fatti e le specifiche che dovrebbero avere. Anzi, nella specifica del protocollo è scritto chiaramente</p><blockquote><p><em>The A2A protocol does not currently define a standard API for such registries, though this is an area of potential future exploration and community standardization</em></p></blockquote><h1 id=soluzioni-aperte-per-lagent-registry>Soluzioni aperte per l&rsquo;Agent Registry<a hidden class=anchor aria-hidden=true href=#soluzioni-aperte-per-lagent-registry>#</a></h1><p>Volendo disegnare un&rsquo;architettura agnostica e possibilmente &ldquo;open&rdquo;, ho fatto qualche ricerca per identificare eventuali tool di mercato che offrono questo tipo di funzionalità e, sorprendentemente, <strong>non ho trovato nulla</strong>. Anche nelle piattaforme leader di mercato, che promuovono lo sviluppo di architetture multi-agente e di applicazioni agentiche a livello enterprise, mi sembra (ma potrei sbagliarmi) che al momento non ci siano molti segnali di apertura verso questa parte del protocollo A2A.<br>D&rsquo;altro canto, mi sembra naturale che in questa fase di transizione i big del settore (hyperscalers e big tech) stiano cercando di creare un ecosistema chiuso, dove ogni cliente sviluppa, pubblica ed esegue i propri agenti. In questo scenario, è facile immaginare che ci sia una certa resistenza a standardizzare e aprire l&rsquo;accesso ad Agent Registries veramente aperti ed interoperabili.</p><p>Fatte queste considerazioni, ho pensato: &ldquo;ok ci metto un po&rsquo; di impegno, ma soprattutto un po&rsquo; di vibe-coding e me lo sviluppo da solo&rdquo; 🛠️</p><h1 id=introduzione-ad-agent-reg>Introduzione ad Agent-Reg<a hidden class=anchor aria-hidden=true href=#introduzione-ad-agent-reg>#</a></h1><h2 id=che-cosè-agent-reg>Che cos&rsquo;è Agent-Reg?<a hidden class=anchor aria-hidden=true href=#che-cosè-agent-reg>#</a></h2><p>Agent-Reg è una implementazione minimale ed open source di un Agent Registry, in maniera conforme alle specifiche A2A. Fornisce una soluzione centralizzata per la discovery e la manutenzione di agenti conformi ad A2A in un modo semplice ed interoperabile.
Trovate il codice qui: <a href=https://github.com/c-daniele/agent-reg>Agent-Reg GitHub Repository</a></p><p>La soluzione può essere rilasciata ovunque ed è stata progettata mantenendo una completa apertura e indipendenza dalla piattaforma. Nel suo nucleo, Agent-Reg risolve il problema della Discovery attraverso:</p><ul><li><strong>Universal Agent Discovery</strong>: Un catalogo ricercabile di tutti gli agenti disponibili</li><li><strong>A2A Protocol Compliance</strong>: Supporto per la specifica Agent2Agent e validazione completa in fase di registrazione</li><li><strong>Health Monitoring</strong>: Tracciamento real-time della disponibilità e dello stato degli agenti (heartbeat)</li><li><strong>Advanced Search</strong>: Ricerca multi-criterio per skill, capabilities, ownership e altri attributi descrittivi</li></ul><h2 id=panoramica-dellarchitettura>Panoramica dell&rsquo;Architettura<a hidden class=anchor aria-hidden=true href=#panoramica-dellarchitettura>#</a></h2><p>L&rsquo;architettura è estremamente semplice e, anche se alcune scelte implementative non sono ancora ottimizzate per la scalabilità (per esempio, l&rsquo;utilizzo di SQLite), fornisce una base di partenza su cui poter costruire le proprie customizzazioni.</p><div class=mermaid>graph TB
subgraph "Client Layer"
UI[React Frontend]
CLI[CLI Tools]
EXT[External Clients]
end
subgraph "API Layer"
GATEWAY[FastAPI Gateway]
CORS[CORS Middleware]
VALID[Schema Validator]
end
subgraph "Business Layer"
REG[Agent Registry Service]
HEART[Heartbeat Manager]
SEARCH[Search & Filter Engine]
    end
    
    subgraph "Data Layer"
DB[(SQLite with JSON)]
SCHEMA[A2A JSON Schema]
end
UI --> GATEWAY
CLI --> GATEWAY
EXT --> GATEWAY
GATEWAY --> CORS
CORS --> VALID
VALID --> REG
REG --> HEART
REG --> SEARCH
REG --> DB
VALID --> SCHEMA</div><h3 id=macrocomponenti>Macrocomponenti<a hidden class=anchor aria-hidden=true href=#macrocomponenti>#</a></h3><h4 id=backend>Backend<a hidden class=anchor aria-hidden=true href=#backend>#</a></h4><p>Il backend è stato sviluppato utilizzando <strong>FastAPI</strong>, un framework Python moderno che fornisce documentazione API automatica, validazione dei tipi ed eccellenti prestazioni.<br>Altre caratteristiche di rilievo:</p><ul><li><strong>SQLite with JSON extension</strong> per la memorizzazione dei dati: un database leggero e ultraconsolidato, con supporto NoSQL tramite JSON, che richiede zero configurazione infrastrutturale aggiuntiva, rendendo semplice il deployment e fornendo prestazioni sufficienti almeno per un PoC o un prototipo funzionante, in grado di gestire qualche migliaio di oggetti</li><li><strong>Strict A2A Schema Validation</strong>: Ogni registrazione di agente è validata rispetto allo schema ufficiale di A2A per garantire la conformità al protocollo</li><li><strong>RESTful API Design</strong>: Endpoint puliti e intuitivi che seguono le specifiche OpenAPI 3.0</li></ul><h4 id=frontend>Frontend<a hidden class=anchor aria-hidden=true href=#frontend>#</a></h4><p>L&rsquo;interfaccia web è costruita con <strong>React 18</strong> e <strong>TypeScript</strong>, fornendo un&rsquo;esperienza moderna e responsive per la gestione degli agenti:</p><ul><li><strong>Tailwind CSS</strong>: Framework CSS semplice e pulito</li><li><strong>Real-time Updates</strong>: Monitoraggio live dello stato e salute degli agenti</li><li><strong>Advanced Filtering</strong>: Interfaccia di ricerca intuitiva con criteri multipli</li></ul><p>Homepage di Agent-Reg
<a href=/images/2025/agent-registry-home.png><img src=/images/2025/agent-registry-home.png alt="Agent-Reg Homepage"></a></p><h2 id=come-funziona-la-registrazione-degli-agenti>Come Funziona la Registrazione degli Agenti<a hidden class=anchor aria-hidden=true href=#come-funziona-la-registrazione-degli-agenti>#</a></h2><p>Il processo di registrazione di un Agente su Agent-Reg assicura che solo gli agenti validi e conformi alle specifiche A2A possano unirsi al registry. Di seguito è riportato un diagramma di sequenza che illustra il flusso di registrazione end-to-end:</p><div class=mermaid>sequenceDiagram
participant Client
participant API
participant Validator
participant Registry
participant Database
Client->>API: POST /agents/register
API->>Validator: Validate Agent Card
Validator->>Validator: Check A2A Schema Compliance
alt Valid Agent Card
Validator-->>API: Valid ✓
API->>Registry: Store Agent
Registry->>Registry: Generate UUID
Registry->>Registry: Add Timestamps
Registry->>Database: Insert Agent Document
Database-->>Registry: Confirmation
Registry-->>API: Agent Record
API-->>Client: 201 Created + Agent ID
else Invalid Agent Card
Validator-->>API: Validation Errors
API-->>Client: 422 Unprocessable Entity
end</div><p>Quando un agente vuole registrarsi con Agent-Reg, deve fornire la sua <strong>Agent Card</strong>. La piattaforma esegue una validazione dell&rsquo;Agent Card per garantire la conformità, rifiutando la richiesta qualora non siano soddisfatti i requisiti del protocollo.
Qualora la validazione abbia esito positivo, l&rsquo;agente viene registrato a sistema e viene dunque ritornato un identificativo univoco, che l&rsquo;Agente può in seguito utilizzare per effettuare operazioni sul registro (es: heartbeat).</p><p>A livello di interfaccia frontend, la registrazione avviene caricando un&rsquo;Agent Card o fornendo il percorso di rete verso il descrittore <em>/.well-known/agent-card.json</em></p><p><a href=/images/2025/agent-registry-add-agent.png><img src=/images/2025/agent-registry-add-agent.png alt="Add new Agent UI"></a></p><h2 id=smart-agent-discovery>Smart Agent Discovery<a hidden class=anchor aria-hidden=true href=#smart-agent-discovery>#</a></h2><p>Agent-Reg fornisce un semplicissimo motore di ricerca che consente agli utenti di scoprire gli agenti di interesse in base a vari criteri. Il diagramma seguente illustra l&rsquo;architettura del motore di ricerca e i filtri applicati:</p><div class=mermaid>graph LR
subgraph "Search Filters"
NAME[Name Filter]
SKILL[Skill Filter]
CAP[Capabilities Filter]
OWNER[Owner Filter]
ALIVE[Liveness Filter]
end
subgraph "Search Engine"
FILTER[Filter Logic]
HEART[Heartbeat Check]
SORT[Result Sorting]
end
subgraph "Results"
LIST[Agent List]
META[Metadata]
COUNT[Total Count]
end
NAME --> FILTER
SKILL --> FILTER
CAP --> FILTER
OWNER --> FILTER
ALIVE --> HEART
FILTER --> SORT
HEART --> SORT
SORT --> LIST
SORT --> META
SORT --> COUNT</div><h3 id=capacità-di-ricerca>Capacità di Ricerca<a hidden class=anchor aria-hidden=true href=#capacità-di-ricerca>#</a></h3><p>I criteri di ricerca sono dunque i seguenti:</p><ul><li><strong>By Name</strong>: Ricerca testuale semplice basata sul nome dell&rsquo;agente</li><li><strong>By Skills</strong>: Trova gli agenti che dichiarano skills specifiche (es. &ldquo;route-planning&rdquo;, &ldquo;image-processing&rdquo;, etc)</li><li><strong>By Capabilities</strong>: Filtra gli agenti basandosi sulle capabilities dichiarate nell&rsquo;agent card secondo quanto previsto nel protocollo A2A (streaming, push notifications, etc)</li><li><strong>By Owner</strong>: Mostra gli agenti gestiti da team o organizzazioni specifiche</li><li><strong>By Liveness</strong>: Mostra solo gli agenti che sono attualmente attivi secondo l&rsquo;heartbeat periodico.</li></ul><h3 id=health-monitoring>Health Monitoring<a hidden class=anchor aria-hidden=true href=#health-monitoring>#</a></h3><p>In uno scenario realistico, gli agenti saranno molti e potenzialmente instabili a causa della loro continua evoluzione e manutenzione (basti pensare ad un cambio nel prompt o nel modello), ma anche a causa della complessa rete di dipendenze. Ad esempio, un Agente può dipendere da servizi o API esterni ma anche da altri Agenti.
Agent-Reg prevede un meccanismo di heartbeat, dove gli agenti registrati notificano periodicamente al registry il loro stato di salute. Questo permette al registry di:</p><ul><li>Fornire ai client informazioni sullo stato di salute in tempo reale</li><li>Filtrare automaticamente gli agenti non responsivi secondo quanto ritornato dai risultati di ricerca</li><li>Abilitare il monitoraggio proattivo e l&rsquo;alerting per agenti critici</li></ul><h2 id=data-model-e-conformità-a2a>Data Model e Conformità A2A<a hidden class=anchor aria-hidden=true href=#data-model-e-conformità-a2a>#</a></h2><p>Agent-Reg aderisce alla specifica del protocollo A2A per la struttura delle agent card, ma è ovviamente un modello semplificato ed estendibile. Ad esempio, non include le definizioni specifiche dei SecurityScheme nelle sue 5 varianti.
Di seguito un class diagram che illustra il modello dati logico:</p><div class=mermaid>classDiagram
class AgentCard {
+string name
+string description
+string version
+string protocolVersion
+string url
+AgentSkill[] skills
+AgentCapabilities capabilities
+string[] defaultInputModes
+string[] defaultOutputModes
+string preferredTransport
+AgentProvider provider
+string documentationUrl
+string iconUrl
+AgentInterface[] additionalInterfaces
+SecurityRequirement[] security
+SecuritySchemes securitySchemes
+AgentCardSignature[] signatures
+boolean supportsAuthenticatedExtendedCard
}
class AgentSkill {
+string id
+string name
+string description
+string[] tags
+string[] examples
+string[] inputModes
+string[] outputModes
+SecurityRequirement[] security
}
class AgentCapabilities {
+boolean streaming
+boolean stateTransitionHistory
+boolean pushNotifications
+AgentExtension[] extensions
}
class AgentProvider {
+string organization
+string url
}
AgentCard "1" --> "0..*" AgentSkill : contains
AgentCard "1" --> "1" AgentCapabilities : has
AgentCard "1" --> "0..1" AgentProvider : provided by</div><h2 id=backend-apis>Backend APIs<a hidden class=anchor aria-hidden=true href=#backend-apis>#</a></h2><p>Agent-Reg fornisce una REST API completa con alcuni metodi che implementano le operazioni principali:</p><table><thead><tr><th>Operazione</th><th>Endpoint</th><th>Descrizione</th></tr></thead><tbody><tr><td>Agent Registration</td><td><code>POST /agents/register</code></td><td>Registra un nuovo agente conforme A2A</td></tr><tr><td>Agent Discovery</td><td><code>GET /agents</code></td><td>Cerca e filtra agenti con vari criteri</td></tr><tr><td>Agent Details</td><td><code>GET /agents/{id}</code></td><td>Recupera informazioni complete su un agente specifico</td></tr><tr><td>Health Check</td><td><code>POST /agents/{id}/heartbeat</code></td><td>Aggiorna lo stato liveness dell&rsquo;agente</td></tr><tr><td>Invocation Info</td><td><code>GET /agents/{id}/invoke_url</code></td><td>Ottieni dettagli di invocazione diretta</td></tr></tbody></table><h2 id=esempio-di-utilizzo-nel-mondo-reale>Esempio di Utilizzo nel Mondo Reale<a hidden class=anchor aria-hidden=true href=#esempio-di-utilizzo-nel-mondo-reale>#</a></h2><p>Vediamo come Agent-Reg funziona nella pratica. Immagina di stare costruendo un&rsquo;applicazione per la pianificazione di viaggi che ha bisogno di trovare un agente di pianificazione percorsi con capabilities di traffico real-time:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Search for agents with route planning skills and streaming capability</span>
</span></span><span class=line><span class=cl>curl <span class=s2>&#34;http://localhost:8000/agents?skill=route-optimizer-traffic&amp;capabilities=streaming&amp;only_alive=true&#34;</span>
</span></span></code></pre></div><p>Il registry restituirà solo agenti attivi che corrispondono a questi criteri, completi dei loro URL di invocazione, requisiti di sicurezza e dettagli delle capability.</p><p>A livello di interfaccia utente, è possibile fare la stessa cosa tramite la barra di ricerca.
<a href=/images/2025/agent-registry-search.png><img src=/images/2025/agent-registry-search.png alt="Agent Registry Search"></a></p><h2 id=perché-agent-reg>Perché Agent-Reg?<a hidden class=anchor aria-hidden=true href=#perché-agent-reg>#</a></h2><p>Agent-Reg cerca di risolvere il problema della Discovery in un ecosistema di agenti basati sullo standard A2A e può essere potenzialmente utile anche per affrontare i temi di sicurezza e governance nelle applicazioni basate su agenti.
Ho provato a sintetizzare i pillar principali su cui vorrei far evolvere il tool:</p><ol><li><strong>Interoperabilità</strong>: agenti eterogenei che aderiscono allo standard possono lavorare insieme senza necessità di collegamenti punto-punto o integrazioni complesse e ridondanti</li><li><strong>Discovery</strong>: Le organizzazioni possono mantenere un catalogo completo e costantemente aggiornato dei loro Agenti</li><li><strong>Affidabilità</strong>: Il meccanismo di heartbeat assicura che i client interagiscano solo con agenti responsivi</li><li><strong>Scalabilità</strong>: L&rsquo;architettura può gestire migliaia di agenti senza requisiti infrastrutturali complessi</li><li><strong>Apertura</strong>: E&rsquo; una soluzione open-source, che può essere distribuita ovunque, previene il vendor lock-in e incoraggia l&rsquo;innovazione</li></ol><h2 id=come-iniziare>Come Iniziare<a hidden class=anchor aria-hidden=true href=#come-iniziare>#</a></h2><p>Agent-Reg manca ancora di diverse funzionalità ed ottimizzazioni necessarie prima di poterlo realmente usare in un ambiente produttivo (es: autenticazione ed autorizzazione, gestione degli errori, logging, notifiche, supporto ad altri NoSql DB, &mldr;), ma è una base su cui costruire un piccolo ecosistema aperto ed estendibile.
Avviarlo è semplicissimo:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Backend setup</span>
</span></span><span class=line><span class=cl><span class=nb>cd</span> backend/app
</span></span><span class=line><span class=cl>pip install -r requirements.txt
</span></span><span class=line><span class=cl>python src/main.py
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Frontend setup</span>
</span></span><span class=line><span class=cl><span class=nb>cd</span> frontend
</span></span><span class=line><span class=cl>npm install
</span></span><span class=line><span class=cl>npm start
</span></span></code></pre></div><h1 id=conclusioni>Conclusioni<a hidden class=anchor aria-hidden=true href=#conclusioni>#</a></h1><p>In questo periodo di forte dinamismo in ambito AI, il protocollo A2A fa un passo molto importante, perché mette a fattor comune alcuni concetti di base su cui poter costruire una reale standardizzazione, ma da questo punto di vista a mio avviso non siamo ancora in una fase di maturità. Le specifiche in sé non sono scritte male, ma sono abbastanza generiche (provate a fare il confronto con altri standard, <a href=https://datatracker.ietf.org/doc/html/rfc7540>tipo quello di HTTP/2</a> per capire cosa intendo&mldr;) e lasciano ancora molti spazi per estensioni o integrazioni.
Uno dei punti importanti che mi sembra sia stato tralasciato è quello della Discovery, per cui ho cercato di immaginare una soluzione centralizzata e aperta.</p><p><a href=https://github.com/c-daniele/agent-reg>La metto a disposizione della collettività</a>, sperando che qualche volontario possa aiutarmi contribuendo al suo sviluppo! 😊</p><hr><section id=comments><script src=https://giscus.app/client.js data-repo=c-daniele/c-daniele.github.io data-repo-id=R_kgDOKIObxg data-category=Announcements data-category-id=DIC_kwDOKIObxs4Cu2th data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=it crossorigin=anonymous async></script></section></div><footer class=post-footer><ul class=post-tags><li><a href=https://c-daniele.github.io/it/tags/ai/>ai</a></li><li><a href=https://c-daniele.github.io/it/tags/agent/>agent</a></li><li><a href=https://c-daniele.github.io/it/tags/a2a/>A2A</a></li></ul><nav class=paginav><a class=prev href=https://c-daniele.github.io/it/posts/2025-08-31-alphaagents-a2a/><span class=title>« Precedente</span><br><span>AlphaAgents: Implementazione Multi-Agent A2A per Analisi Finanziaria Collaborativa</span></a>
<a class=next href=https://c-daniele.github.io/it/posts/2025-07-05-advanced-tecnique-for-analyzing-excel-files-with-llms/><span class=title>Successivo »</span><br><span>Oltre il RAG: Come analizzare efficacemente un file Excel tramite un LLM</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Agent-Reg: Costruire un Agent Registry aperto per il Protocollo A2A on twitter" href="https://twitter.com/intent/tweet/?text=Agent-Reg%3a%20Costruire%20un%20Agent%20Registry%20aperto%20per%20il%20Protocollo%20A2A&amp;url=https%3a%2f%2fc-daniele.github.io%2fit%2fposts%2f2025-08-15-agent-reg-for-a2a%2f&amp;hashtags=ai%2cagent%2cA2A"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Agent-Reg: Costruire un Agent Registry aperto per il Protocollo A2A on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fc-daniele.github.io%2fit%2fposts%2f2025-08-15-agent-reg-for-a2a%2f&amp;title=Agent-Reg%3a%20Costruire%20un%20Agent%20Registry%20aperto%20per%20il%20Protocollo%20A2A&amp;summary=Agent-Reg%3a%20Costruire%20un%20Agent%20Registry%20aperto%20per%20il%20Protocollo%20A2A&amp;source=https%3a%2f%2fc-daniele.github.io%2fit%2fposts%2f2025-08-15-agent-reg-for-a2a%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Agent-Reg: Costruire un Agent Registry aperto per il Protocollo A2A on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fc-daniele.github.io%2fit%2fposts%2f2025-08-15-agent-reg-for-a2a%2f&title=Agent-Reg%3a%20Costruire%20un%20Agent%20Registry%20aperto%20per%20il%20Protocollo%20A2A"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Agent-Reg: Costruire un Agent Registry aperto per il Protocollo A2A on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fc-daniele.github.io%2fit%2fposts%2f2025-08-15-agent-reg-for-a2a%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Agent-Reg: Costruire un Agent Registry aperto per il Protocollo A2A on whatsapp" href="https://api.whatsapp.com/send?text=Agent-Reg%3a%20Costruire%20un%20Agent%20Registry%20aperto%20per%20il%20Protocollo%20A2A%20-%20https%3a%2f%2fc-daniele.github.io%2fit%2fposts%2f2025-08-15-agent-reg-for-a2a%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Agent-Reg: Costruire un Agent Registry aperto per il Protocollo A2A on telegram" href="https://telegram.me/share/url?text=Agent-Reg%3a%20Costruire%20un%20Agent%20Registry%20aperto%20per%20il%20Protocollo%20A2A&amp;url=https%3a%2f%2fc-daniele.github.io%2fit%2fposts%2f2025-08-15-agent-reg-for-a2a%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Agent-Reg: Costruire un Agent Registry aperto per il Protocollo A2A on ycombinator" href="https://news.ycombinator.com/submitlink?t=Agent-Reg%3a%20Costruire%20un%20Agent%20Registry%20aperto%20per%20il%20Protocollo%20A2A&u=https%3a%2f%2fc-daniele.github.io%2fit%2fposts%2f2025-08-15-agent-reg-for-a2a%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://c-daniele.github.io/it/>Cdani's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copia";function s(){t.innerHTML="copiato!",setTimeout(()=>{t.innerHTML="copia"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>