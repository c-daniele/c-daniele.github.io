<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The Developer --> Designer switch | Cdani's Blog</title><meta name=keywords content="GenAI,Agents,Coding"><meta name=description content="Intro A few months ago I had to work on a complex application on AWS: a React frontend on Amplify, several Lambda functions, Bedrock with AgentCore, Knowledge Bases, and Prompt Management. I was in a hurry, and the temptation was overwhelming: open Claude Code, throw in a generic prompt, and hope it would &ldquo;figure it out.&rdquo; Instead, I did something different ‚Äî I wrote specifications, reviewed them, spent an entire day on it ‚Äî and that day it felt like I hadn&rsquo;t accomplished anything."><meta name=author content="Me"><link rel=canonical href=https://c-daniele.github.io/en/posts/2026-02-14-intro-spec-driven-development/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.3598bbf45621a4ad34d093926efeb15d6df27175e085d2f069483f14ad39d7fa.css integrity="sha256-NZi79FYhpK000JOSbv6xXW3ycXXghdLwaUg/FK051/o=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://c-daniele.github.io/logo_cd_v3.svg><link rel=icon type=image/png sizes=16x16 href=https://c-daniele.github.io/logo_cd_v3.svg><link rel=icon type=image/png sizes=32x32 href=https://c-daniele.github.io/logo_cd_v3.svg><link rel=apple-touch-icon href=https://c-daniele.github.io/logo_cd_v3.svg><link rel=mask-icon href=https://c-daniele.github.io/logo_cd_v3.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=it href=https://c-daniele.github.io/it/posts/2026-02-14-intro-spec-driven-development/><link rel=alternate hreflang=en href=https://c-daniele.github.io/en/posts/2026-02-14-intro-spec-driven-development/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0,theme:"default",securityLevel:"loose"})</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-8NZQZ3Z1RN"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-8NZQZ3Z1RN",{anonymize_ip:!1})}</script><meta property="og:title" content="The Developer --> Designer switch"><meta property="og:description" content="Intro A few months ago I had to work on a complex application on AWS: a React frontend on Amplify, several Lambda functions, Bedrock with AgentCore, Knowledge Bases, and Prompt Management. I was in a hurry, and the temptation was overwhelming: open Claude Code, throw in a generic prompt, and hope it would &ldquo;figure it out.&rdquo; Instead, I did something different ‚Äî I wrote specifications, reviewed them, spent an entire day on it ‚Äî and that day it felt like I hadn&rsquo;t accomplished anything."><meta property="og:type" content="article"><meta property="og:url" content="https://c-daniele.github.io/en/posts/2026-02-14-intro-spec-driven-development/"><meta property="og:image" content="https://c-daniele.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-14T00:00:00+02:00"><meta property="article:modified_time" content="2026-02-14T00:00:00+02:00"><meta property="og:site_name" content="Cdani's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://c-daniele.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="The Developer --> Designer switch"><meta name=twitter:description content="Intro A few months ago I had to work on a complex application on AWS: a React frontend on Amplify, several Lambda functions, Bedrock with AgentCore, Knowledge Bases, and Prompt Management. I was in a hurry, and the temptation was overwhelming: open Claude Code, throw in a generic prompt, and hope it would &ldquo;figure it out.&rdquo; Instead, I did something different ‚Äî I wrote specifications, reviewed them, spent an entire day on it ‚Äî and that day it felt like I hadn&rsquo;t accomplished anything."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"The Developer --\u003e Designer switch","item":"https://c-daniele.github.io/en/posts/2026-02-14-intro-spec-driven-development/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The Developer --\u003e Designer switch","name":"The Developer --\u003e Designer switch","description":"Intro A few months ago I had to work on a complex application on AWS: a React frontend on Amplify, several Lambda functions, Bedrock with AgentCore, Knowledge Bases, and Prompt Management. I was in a hurry, and the temptation was overwhelming: open Claude Code, throw in a generic prompt, and hope it would \u0026ldquo;figure it out.\u0026rdquo; Instead, I did something different ‚Äî I wrote specifications, reviewed them, spent an entire day on it ‚Äî and that day it felt like I hadn\u0026rsquo;t accomplished anything.","keywords":["GenAI","Agents","Coding"],"articleBody":"Intro A few months ago I had to work on a complex application on AWS: a React frontend on Amplify, several Lambda functions, Bedrock with AgentCore, Knowledge Bases, and Prompt Management. I was in a hurry, and the temptation was overwhelming: open Claude Code, throw in a generic prompt, and hope it would ‚Äúfigure it out.‚Äù Instead, I did something different ‚Äî I wrote specifications, reviewed them, spent an entire day on it ‚Äî and that day it felt like I hadn‚Äôt accomplished anything. Two days later I had a working application. If I had improvised, I‚Äôd probably still be debugging.\nThis experience changed my perspective on what it truly means to use AI for software development. It‚Äôs not about ‚Äúvibe coding‚Äù ‚Äî writing a vague prompt and hoping for the best ‚Äî but something far more structured, and paradoxically more demanding. But before diving into the details, let‚Äôs look around: the signs of a radical transformation are already everywhere.\nLast December, Boris Cherny, an Anthropic engineer and creator of Claude Code (essentially the company‚Äôs flagship product), stated that in the previous 30 days, 100% of the work on the Claude Code repository had been done by Claude Code itself The sharp slowdown in stock prices for some SaaS companies suggests that the market has already priced in the tendency for companies to build software in-house rather than buying it from the usual big players Spotify declared that since December 2025 their best developers haven‚Äôt written a single line of code: they send instructions via Slack to their internal system ‚ÄúHonk‚Äù (based on Claude Code), which implements the changes, while the engineers focus on review and architecture To tackle this discussion, however, we need to leave behind the ‚ÄúVibe Coding‚Äù hype and understand from the outset that we‚Äôre talking about a different way of conceiving the developer‚Äôs profession and the software assembly line. This approach requires method and discipline, and might even be hard to swallow for some, because it risks compressing certain ‚Äúcreative‚Äù phases of the work ‚Äî which can sometimes be the most rewarding. Is Software Development a Dead Profession? According to many analysts, we‚Äôre looking at a ‚Äútransformation,‚Äù so in a sense the answer is no. However, I believe the transformation will be so radical that within 5 to 10 years, none of us will see a job posting that simply says ‚ÄúDeveloper.‚Äù The software developer of tomorrow requires highly varied expertise (architectures, networks, processes, languages, data, ‚Ä¶). I don‚Äôt know what this role will be called in the future, but for simplicity I‚Äôll call it the ‚ÄúDESIGNER‚Äù (in the sense of system designer/architect).\nThe same ‚ÄúDesigner‚Äù pattern is already being applied in other less common domains, such as writing and journalism. To give you an extreme example, a few months ago Luciano Floridi, one of the leading figures in the philosophy of information and the digital age, published a book titled Distant Writing: Literary Production in the Age of Artificial Intelligence. In this work, Floridi pursues an ambitious project of interweaving stories of minor characters (mentioned but secondary) from classic English novels, from Jane Austen to Virginia Woolf, into short stories (1,500‚Äì2,000 words each) where they meet in narrative chains that are plausible given the era, location, and social status. In interviews he has given, Floridi stated that he essentially ‚Äúdesigned‚Äù the book and had it in a drawer for many years, but was able to realize it only through the use of LLMs to expand and write the individual stories, and to ensure that characters would encounter one another in a way consistent with their characteristics and the overall plot.\nPrerequisites To prepare for this transformation, I see mainly 2 prerequisites ‚Äî one technical and one mental. Neither is optional: without the right skills you can‚Äôt produce quality specifications; without the right mindset you won‚Äôt have the patience to write them.\nSkills Software specifications have existed forever ‚Äî they‚Äôre certainly not a 2026 novelty. Yet it‚Äôs surprising to note how the tech world is refocusing on the importance of this concept after having invented the transformer, cleared forests, and haunted stock markets with potential AI bubbles.\nSpec-Driven Development techniques are obviously based on the concept of ‚ÄúSpecification,‚Äù which can be understood at various levels of abstraction (e.g., user story, technical specification, code template, ‚Ä¶). The Designer must therefore be able to read and write specifications across the entire stack and must have a methodical and rigorous approach to industrialize the work.\nBut how do I write specifications for a solution with frontend components, backend, a message broker, various containers, and the need to deploy it on one hyperscaler rather than another?\nIn the past, you needed to know the basics of computing, CPUs, memory, data modeling, and telecommunications networks. Now, you need to raise the level of abstraction and broaden the perspective. This means knowing data platforms, hyperscalers, authentication patterns, deployment models and containerization, automation pipelines, and managing software across dozens or potentially hundreds of branches.\nTo evolve from ‚ÄúDeveloper‚Äù of 2020 to ‚ÄúDesigner‚Äù of 2026, you need:\nknowledge of basic DevOps practices foundational competencies in Solution Design and the ability to navigate the most common development and deployment patterns (microservices, message brokers, containers, transport and application protocols, Security, IaC, ‚Ä¶) strong technical expertise in a specific area (e.g., frontend, data engineering, ‚Ä¶) understanding the basics of LLMs, particularly the role of context and context engineering techniques Mindset For many people, development is a passion as well as a job, as demonstrated by the countless open-source development communities. We need to get used to the idea that the Designer‚Äôs work might be far less fun than today‚Äôs Developer‚Äôs work. This shift might be an unacceptable effort for everyone, but it‚Äôs very likely that this is exactly where the battle over skills valued by the job market will be fought: the ability to read and write specifications will be fundamental.\nWe also need to fight the impulse to have ‚Äúeverything right now‚Äù: we can‚Äôt expect to write a prompt and have the software ready. We truly need to apply a certain level of effort and genuinely use the skills we mentioned above. As I described in the introduction, the day ‚Äúwasted‚Äù writing specifications saved me about two weeks of work. But the initial feeling was exactly that: of wasting time. It‚Äôs a counterintuitive investment, and the right mindset consists precisely in accepting it.\nCore Concepts Context Window Most people think: ‚Äúthe more I put into the context, the better.‚Äù This is an idea that can lead you astray, and understanding why requires a minimum understanding of how models work.\nLLMs are autoregressive models based on the Transformer architecture. The heart of this architecture is the self-attention mechanism: for each generated token, the model calculates an ‚Äúattention‚Äù score against all previous tokens in the context. This has two important practical implications:\nQuadratic complexity: the computational cost of attention grows as O(n^2) relative to context length. Doubling the context quadruples the cost. This is not just a latency and cost issue (which are also significant), but it degrades the quality of the output itself.\n‚ÄúLost in the middle‚Äù: several studies (including the well-known paper by Liu et al., 2023) have shown that LLMs tend to pay more attention to information at the beginning and end of the context, ‚Äúforgetting‚Äù what‚Äôs in the middle. In practice, if the crucial specification of your API is in the middle of an 80,000-token conversation, the model might simply not take it into account.\nAlthough the LLM interface presents itself as a chat, we should always evaluate each interaction as if it were an isolated task, carrying along a conversational history that is often useless, pollutes the context window, and leads the model astray. This phenomenon is called Context Bloat.\nContext Engineering The term ‚ÄúContext Engineering‚Äù is often confused with prompt engineering, but they are distinct concepts. Prompt engineering concerns the formulation of a single request to the LLM. Context Engineering is something broader: it‚Äôs the systematic control of everything that enters the model‚Äôs context window ‚Äî system prompt, persistent instructions (like CLAUDE.md), tool results, loaded code files, memory of previous interactions, and only lastly the user‚Äôs prompt.\nThink of the context as a program: every element you insert is an instruction that the model will execute (or attempt to execute). The more contradictory or irrelevant instructions you insert, the more unpredictable the ‚Äúprogram‚Äù becomes.\nWith this perspective, SDD techniques are essentially Context Engineering techniques: they maximize the effectiveness of the context window by making development modular (SPEC -\u003e PLAN -\u003e CLARIFY -\u003e IMPLEMENTATION) and above all by minimizing noise. Each phase operates in a clean, dedicated context, with only the information relevant to that specific task.\nDivide and Conquer In the realm of software development, many people (including many of today‚Äôs developers) think that the LLM is only useful for writing code, while SDD techniques are based on the assumption that the Designer uses the LLM across the entire pipeline of software work.\nPhase Objective LLM Usage Ideation Exploration of the solution space For a given problem, there are potentially infinite solutions, and LLMs are a formidable tool for exploring them Specifications Detailed definition of user requirements Beyond defining detailed specifications, this phase also identifies any gaps and areas of ambiguity Design Having a solid baseline to write code without ‚Äúimprovising‚Äù Research, expansion, deep-dive, and selection of software components to create/modify, plus the development plan and testing approach Implementation Translating the design into code Writing code and tests Testing Software verification Running tests and identifying bugs üí° Tip For each phase, it‚Äôs worth evaluating the most suitable LLM on a case-by-case basis. For example, at the time of writing, Claude Opus 4.6 is among the top performers in pure coding, but models like the latest versions of ChatGPT, Gemini 3, or Kimi k2.5 can be more effective and creative in the solution exploration phases. Reusing the same context for an entire development cycle is strongly discouraged, even if the model supports millions of tokens. The reason is the Context Bloat discussed above: the architectural decisions from the Planning phase, the user story details from the Specification phase, and the code from the Implementation phase all compete for the model‚Äôs attention. The result is a progressive degradation in quality across all phases, not just the last one. What Is SDD Spec-Driven Development (SDD) is a paradigm that treats specifications as the primary source of truth for a software system. Code becomes a secondary artifact, generated or verified against the specification. Instead of the classic approach ‚Äúwrite the code first, document later,‚Äù SDD inverts the flow: you write clear, structured specifications of the expected behavior and then generate, implement, or verify the code against them.\nIn other words: the specification is the product, the code is a byproduct.\nThis concept is not entirely new. API-first development with OpenAPI, BDD (Behavior-Driven Development), and contract-driven testing have existed for years. What changes today is that LLMs make it possible to automate the entire flow: from specification to technical plan, from plan to tasks, from tasks to code, from code to tests. The specification becomes a true control plane that orchestrates AI agents and human developers.\nA recent paper on arXiv formalizes SDD as follows: ‚ÄúSpecifications are the source of truth; code derives from them. The specification is the authoritative description that humans and machines use to understand, build, and evolve the system.‚Äù\nLevels of SDD There isn‚Äôt a single way to apply SDD. Three levels of rigor can be identified:\nSpec-first: the specification is written before implementation and guides initial development. Ideal for new services, APIs, or features with multiple consumers. Spec-anchored: specification and code evolve together, kept in sync through tests and validation. This is the most practical level for most teams in production. Spec-as-source: humans only edit specifications; code is generated from them. Suitable for highly regulated or structured domains where traceability from requirement to code must be rigorous. Most teams will find spec-anchored to be the right compromise between rigor and agility.\nOverview of Key Frameworks The SDD tooling ecosystem is developing rapidly. Here are the three most relevant frameworks:\nSpec Kit (GitHub) Spec Kit is GitHub‚Äôs open-source toolkit for SDD. It proposes a multi-phase workflow (Specify -\u003e Plan -\u003e Tasks -\u003e Implement) and generates versioned Markdown artifacts in the repository. It‚Äôs compatible with GitHub Copilot, Claude Code, Cursor, and Gemini CLI. We‚Äôll dive deeper into Spec Kit in the next chapter.\nOpenSpec (Fission AI) OpenSpec is a lightweight, open-source framework (TypeScript) designed to bring determinism to AI development. Its distinctive features:\nDelta Specs: captures incremental changes in requirements, rather than rewriting the entire specification Brownfield-first: designed to evolve existing codebases, not just greenfield projects No API key or complex installation: specifications live in the repository alongside the code Supports over 20 tools, including Claude Code, Cursor, and GitHub Copilot BMAD Method The BMAD Method (Breakthrough Method for Agile AI-Driven Development) is a more ambitious open-source framework, with:\n21 specialized AI agents (Analyst, Product Manager, Architect, Developer, QA, Scrum Master, ‚Ä¶) each with defined roles and responsibilities 50+ guided workflows for different project types and phases Multi-agent architecture: agents collaborate from ideation to implementation Compatible with Claude Code, Cursor, Windsurf, and other AI IDEs Here‚Äôs a quick guide to help you choose:\nCriterion Spec Kit OpenSpec BMAD Setup complexity Low (CLI + Markdown) Very low (files in repo) Medium-high (21 agents to configure) Ideal for Greenfield projects with GitHub Evolving existing codebases Enterprise projects with structured teams Learning curve ~1 hour ~30 minutes ~1 day Lock-in Low (Markdown + Git) None (files in repo) Medium (framework dependency) Brownfield support Limited Excellent (Delta Specs) Good In general: start with Spec Kit if you use GitHub and want a structured but lightweight workflow. Choose OpenSpec if you need to evolve an existing codebase without disrupting your workflow. Consider BMAD only if your project requires multi-role coordination and you have the time budget to configure the entire orchestra of agents.\nDeep Dive into Spec Kit Spec Kit deserves a deeper look because it represents the state of the art in SDD applied to coding agents and is directly backed by GitHub and Microsoft.\nThe Spec Kit workflow is organized into well-defined steps, each with a dedicated command:\n1. Project Constitution (/speckit.constitution)\nYou define the non-negotiable principles of the project: coding standards, testing requirements, security rules, UX principles, performance targets. The constitution is automatically consulted at every subsequent phase as a constraint.\n2. Functional Specification (/speckit.specify)\nAn idea is transformed into a structured functional specification: user stories, functional requirements, acceptance criteria. No technical details here ‚Äî only the what and the why. Spec Kit automatically creates a dedicated Git branch for the feature.\n3. Clarification (/speckit.clarify)\nThe AI agent asks structured questions to eliminate ambiguities from the specification: edge cases, constraints, error handling, permissions. This phase is critical: an ambiguous specification produces ambiguous code.\n4. Technical Plan (/speckit.plan)\nThe validated specification is translated into a detailed technical plan: architectural decisions, data models, APIs, integrations. This is where you choose the stack, patterns, and interfaces. Generated artifacts include plan.md, data-model.md, and a contracts/ folder with API specifications.\n5. Validation (/speckit.checklist, /speckit.analyze)\nQuality control and consistency checking across all artifacts before writing code. Inconsistencies, gaps, and quality issues are identified.\n6. Task Decomposition (/speckit.tasks)\nThe plan is decomposed into small, reviewable work units: each task has explicit inputs, outputs, and success criteria tied to the specification. Tasks are ordered by dependencies, and parallelizable ones are marked.\n7. Implementation (/speckit.implement)\nThe AI agent executes the tasks, generating and modifying code, tests, and configurations according to the plan. Code is produced in small diffs, easily reviewable.\nA Practical Example Let‚Äôs imagine we want to develop a simple API for managing a book library. Here‚Äôs how the flow would unfold with Spec Kit:\nPhase 1 - Constitution:\n/speckit.constitution The project follows an API-first approach. We use Python with FastAPI. Every endpoint must have unit tests. Security: JWT authentication. PostgreSQL database with Alembic for migrations. Phase 2 - Specify:\n/speckit.specify Build a REST API to manage a book library. Users can search books by title, author, or ISBN. Administrators can add, modify, and remove books. Each book has: title, author, ISBN, publication year, genre. Include user stories and acceptance criteria. At this point, Spec Kit generates a structured spec.md file with user stories like:\nAs a user, I want to search books by title, so I can quickly find the book I‚Äôm interested in As an administrator, I want to add a new book to the catalog, specifying all metadata Phase 3 - Clarify: The agent asks, for example: ‚ÄúAre there limits on the number of results per page? What happens if someone tries to insert a duplicate ISBN? Which fields are required?‚Äù\nPhase 4 - Plan: A technical plan is generated. Here‚Äôs a realistic excerpt from the generated plan.md:\n# Technical Plan - Library API ## Architecture - Framework: FastAPI with Pydantic v2 for validation - Database: PostgreSQL 16 with SQLAlchemy 2.0 (async) - Migrations: Alembic with autogenerate - Auth: JWT (access token 15min + refresh token 7d) ## Data Model ### Book | Field | Type | Constraints | |-------------|-------------|---------------------------| | id | UUID | PK, auto-generated | | title | VARCHAR(255)| NOT NULL, INDEX | | author | VARCHAR(255)| NOT NULL, INDEX | | isbn | VARCHAR(13) | UNIQUE, NOT NULL | | year | INTEGER | CHECK (year \u003e= 1450) | | genre | VARCHAR(100)| NULL | | created_at | TIMESTAMP | DEFAULT now() | ## REST Endpoints - `GET /books?title=\u0026author=\u0026isbn=\u0026page=1\u0026size=20` -\u003e 200 + pagination - `GET /books/{id}` -\u003e 200 | 404 - `POST /books` -\u003e 201 | 400 (validation) | 409 (duplicate ISBN) - `PUT /books/{id}` -\u003e 200 | 404 - `DELETE /books/{id}` -\u003e 204 | 404 - All POST/PUT/DELETE methods require header `Authorization: Bearer ` Note the level of detail: types, constraints, response codes, authentication rules. There‚Äôs no ambiguity, and the AI agent receiving this plan won‚Äôt have to ‚Äúguess‚Äù anything.\nPhase 5-6 - Checklist \u0026 Tasks: Tasks are generated such as:\nCreate SQLAlchemy models (Book, User) Configure Alembic and create the initial migration Implement the GET /books endpoint with filters and pagination Implement the POST /books endpoint with validation Add JWT authentication Write tests for each endpoint Each task has explicit inputs, outputs, and success criteria. Parallelizable tasks are marked with [P], sequential ones are ordered by dependencies.\nPhase 7 - Implement: The agent executes each task, producing verifiable code and tests.\nThe key point is that every phase produces versioned Markdown artifacts in the repository, creating complete traceability from idea to code. If six months from now someone asks ‚Äúwhy does this API work this way?‚Äù, the answer is in the specification.\nCoding Agents SDD is the methodology, but putting it into practice requires the right tools. Coding agents are the operational component of this new paradigm: AI agents that go beyond auto-completion ‚Äî they plan tasks, modify codebases, run tests, and collaborate through existing DevOps workflows.\nHow a Coding Agent Works (Under the Hood) Before surveying the tools, it‚Äôs worth understanding what distinguishes an ‚Äúagent‚Äù from a simple chatbot. A coding agent operates according to a continuous agentic loop, which in pseudocode can be represented as:\nwhile task is not complete: context = gather(specs, code, test_results, errors) plan = reason(context) # the LLM decides what to do action = select_tool(plan) # tool selection: edit, bash, search... result = execute(action) # real execution on filesystem/terminal feedback = verify(result) # test, lint, command output if feedback.has_errors: context.append(feedback) # the error becomes input for the next cycle The key mechanism is tool use (or function calling): the LLM doesn‚Äôt just generate text ‚Äî it emits structured calls to external tools: file editors, bash terminal, browser, APIs. This allows it to interact with the real world: read a file, modify it, run tests, and react to results.\nThe fundamental difference between the various agents on the market lies in which tools they have available and in which environment they operate:\nAgents with direct filesystem access (Claude Code, Cursor): operate on your machine, with full access to terminal and files. Maximum flexibility, but require supervision. Agents in isolated sandbox (Devin, GitHub Copilot coding agent): operate in a dedicated cloud environment. Safer for full autonomy, but less flexible for custom workflows. The coding agent landscape has evolved rapidly, and today we can distinguish several categories:\nEcosystem-Integrated Agents GitHub Copilot coding agent: works directly within the Pull Request workflow. You can assign an issue to @copilot and the agent plans, modifies code, runs tests, and opens a PR autonomously. It‚Äôs the native target for Spec Kit. Amazon Q Developer: AWS‚Äôs AI assistant, particularly strong for cloud-native development, IaC, and application transformations (e.g., Java 8-\u003e17 migration). Google Gemini Code Assist: strong integration with Google Cloud services (BigQuery, Firebase, Apigee). Explicitly supported by Spec Kit as an SDD target. Editor-First Agents Cursor: a fork of VS Code that‚Äôs natively AI-first. The Agentic + Composer mode allows planning multi-step tasks, modifying multiple files, executing terminal commands, and iterating until tests pass. JetBrains AI Assistant \u0026 Junie: integrated across all JetBrains IDEs, Junie offers agentic programming for implementing fixes, refactoring, and tests. Agent Platforms Claude Code / Claude Agent SDK: Anthropic‚Äôs platform based on the principle ‚Äúgive the agent a computer.‚Äù Claude Code has access to terminal and file system and operates with a continuous cycle: gather context -\u003e act -\u003e verify -\u003e repeat. The Agent SDK allows building custom agents. Devin (Cognition): a fully autonomous agent with its own integrated development environment (shell, editor, browser). Still experimental and not very ‚Äúenterprise-ready.‚Äù Which Agent Should You Choose? For a company looking to adopt SDD today, a pragmatic approach is:\nGitHub Copilot or Amazon Q for issue/PR-driven work on core services Gemini Code Assist for SDD workflows on analytics and GCP integrations Cursor or JetBrains in the IDE for high-fidelity implementation from specifications Claude Code / Agent SDK for custom SDD pipelines where standard tools are too rigid The Added Value of Instruction Files: CLAUDE.md One of the most powerful concepts to emerge with coding agents is that of persistent instruction files: Markdown files that the agent reads automatically at the start of every session to understand the project context. Each agent has its own format (.github/copilot-instructions.md for Copilot, .cursorrules for Cursor, etc.), but the most well-known and mature is Claude Code‚Äôs CLAUDE.md.\nWhat Is CLAUDE.md CLAUDE.md is a project-specific instruction file that Claude Code reads automatically when starting in a directory. Its purpose is to:\nGive Claude the minimum context it cannot infer from the code Codify critical rules and caveats that must be respected in every task Improve reliability and speed by avoiding repeated explanations Think of it as a carefully curated system prompt, not a wiki. It‚Äôs a living contract between the codebase and the AI agents.\nHow to Set Up a Good CLAUDE.md Best practices, confirmed by both Anthropic documentation and empirical community experience, converge on several key principles. These principles are not specific to Claude Code but derive from the general characteristics of LLMs, and therefore apply to any assistant or coding agent, even if the specific format may vary depending on the tool.\n1. Less is more\nEvery additional line can reduce the overall quality of instruction adherence. LLMs can follow only a limited number of distinct instructions with high fidelity. When there are too many, adherence to all rules degrades ‚Äî it‚Äôs not that the last ones are ignored; all of them get worse.\n2. High signal, low noise\nOnly include information that is:\nHard for Claude to infer by reading the code Relevant to the vast majority of daily tasks 3. The minimum effective structure\nA good CLAUDE.md typically contains three blocks:\n# CLAUDE.md ## Project This is a Next.js + TypeScript e-commerce portal that communicates with our internal payment and catalog APIs. ## Key Commands - Install dependencies: `pnpm install` - Dev server: `pnpm dev` - Build: `pnpm build` - Test: `pnpm test` - Lint: `pnpm lint` ## IMPORTANT Caveats - IMPORTANT: Do not modify `prisma/schema.prisma` directly. Use `pnpm db:migrate` and `pnpm db:generate`. - IMPORTANT: The `/api/webhooks/stripe` endpoint expects the raw request body. DO NOT use a body parser. - Images in `public/` must be optimized before committing; files \u003e 200KB will fail CI. 4. Don‚Äôt include style rules\nRules like ‚Äúuse two spaces for indentation‚Äù or ‚Äúuse single quotes‚Äù are a waste of instructions: Claude infers them from existing code, and linters and formatters handle them better anyway.\n5. Progressive disclosure\nFor detailed but rarely needed information, don‚Äôt weigh down the main file. Instead:\n## Additional Documentation - Database schema and migrations: read `docs/schema.md` when modifying models. Claude will open docs/schema.md only when necessary, instead of loading it on every task.\n6. Path-specific rules with .claude/rules/\nClaude Code supports path-specific instruction files:\n# .claude/rules/tests.md paths: [\"**/*.spec.ts\", \"**/*.test.ts\"] ## Testing Rules - Use Vitest, not Jest. - Use the helpers in `test-utils/` for component rendering. This file is loaded only when Claude works on test files, keeping the global CLAUDE.md leaner.\n7. Continuous maintenance\nTreat CLAUDE.md as a living document: update it when you notice Claude repeating avoidable mistakes, remove obsolete instructions, reorder by importance. The most important rules should always be at the top of the file.\nLimitations and Risks of SDD It would be dishonest to present SDD as a solution without issues. There are concrete limitations worth knowing before adopting it:\nNon-determinism. LLMs are not deterministic: the same specification, given to the same model at two different times, can produce structurally different code. This means SDD doesn‚Äôt guarantee reproducibility. The specification drastically reduces variance compared to a generic prompt, but doesn‚Äôt eliminate it. That‚Äôs why contract tests and automated validation are indispensable ‚Äî they‚Äôre the ‚Äúdeterministic guardrail‚Äù that compensates for the probabilistic nature of the model. At the same time, though, it‚Äôs worth reflecting on the fact that, in general, the same concept applies to humans as well: the same developer, reading the same specification at two different times, can write different code. Garbage in, garbage out (shifted up a level). If I use an LLM to generate the specifications themselves, who validates them? The risk is automating the production of plausible but incorrect specifications ‚Äî for example, a data model that seems reasonable but violates an unstated business rule. Human review of specifications is not optional: it‚Äôs the critical control point of the entire workflow. Scalability. The book library example works well, but what happens with a distributed system of 200 microservices? SDD scales well as long as specifications remain modularizable ‚Äî one service at a time, one feature at a time. When cross-service dependencies become too intricate, the specifications themselves risk becoming a maintenance problem. This isn‚Äôt a reason not to adopt SDD, but it is a reason not to think of it as a magic wand. Costs. A complete SDD workflow (specify -\u003e clarify -\u003e plan -\u003e tasks -\u003e implement) consumes significantly more tokens than a single prompt. Each phase involves one or more calls to the LLM, each with its own context. On top-tier models like Claude Opus or GPT-4, a complete cycle for a medium-complexity feature can cost between 5 and 20 dollars in tokens. It‚Äôs an investment that pays for itself amply in terms of time saved, but it needs to be planned ‚Äî especially for teams working on dozens of features in parallel. Overhead for simple projects. A complete SDD workflow for a 50-line script is over-engineering. SDD performs best on features with medium-to-high complexity, where ambiguities are the real cost. For trivial tasks, a good direct prompt remains the best choice. All these limitations are, however, manageable through a disciplined and aware approach. In other words, a naive ‚Äúvibe-coding‚Äù approach may work fine for a small prototype, but as project complexity increases, it becomes necessary to apply SDD techniques with ever-greater rigor to avoid running into these problems.\nConclusions Spec-Driven Development is neither a passing fad nor an academic exercise.\nIt is a methodological and disciplined approach to software development through AI Agents, leveraging the capabilities of agents across the entire development stack ‚Äî from exploring the solution space, to writing detailed specifications, to technical planning, through to implementation and testing.\nBut as we‚Äôve seen, it‚Äôs not without limitations: the non-determinism of LLMs, the risk of incorrect specifications, token costs, and overhead for simple projects are all factors to consider. SDD works best when applied with judgment, not as dogma.\nFor those working in software development today, the message is clear:\nInvest in cross-cutting skills: architecture, DevOps, data models, security. The Designer of the future isn‚Äôt the one who writes the fastest code, but the one who writes the most precise specifications. Adopt gradually: start with API-first and contract tests. Then add an SDD framework like Spec Kit on a new feature. Measure the results. Abandon Vibe Coding: writing vague prompts and hoping for the best doesn‚Äôt scale. Investing a day in specifications to save two weeks of work isn‚Äôt ‚Äúwasting time‚Äù ‚Äî it‚Äôs the Designer‚Äôs craft. Prepare for the mindset shift: it will be less ‚Äúfun‚Äù in the traditional sense, but the satisfaction of orchestrating a complex system through specifications that produce working software is, in its own way, equally rewarding. The future of software development isn‚Äôt writing code. It‚Äôs designing systems and letting the code write itself ‚Äî but under the rigorous control of someone who knows what they want to achieve.\n","wordCount":"4918","inLanguage":"en","datePublished":"2026-02-14T00:00:00+02:00","dateModified":"2026-02-14T00:00:00+02:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://c-daniele.github.io/en/posts/2026-02-14-intro-spec-driven-development/"},"publisher":{"@type":"Organization","name":"Cdani's Blog","logo":{"@type":"ImageObject","url":"https://c-daniele.github.io/logo_cd_v3.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://c-daniele.github.io/en/ accesskey=h title="Home (Alt + H)"><img src=https://c-daniele.github.io/logo_cd_v3.svg alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://c-daniele.github.io/it/ title=Italiano aria-label=Italiano>It</a></li></ul></div></div><ul id=menu><li><a href=https://c-daniele.github.io/en/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://c-daniele.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://c-daniele.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://c-daniele.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://c-daniele.github.io/en/>Home</a></div><h1 class=post-title>The Developer --> Designer switch</h1><div class=post-meta><span title='2026-02-14 00:00:00 +0200 +0200'>February 14, 2026</span>&nbsp;¬∑&nbsp;24 min&nbsp;¬∑&nbsp;4918 words&nbsp;¬∑&nbsp;Me&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://c-daniele.github.io/it/posts/2026-02-14-intro-spec-driven-development/>It</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#is-software-development-a-dead-profession>Is Software Development a Dead Profession?</a></li><li><a href=#prerequisites>Prerequisites</a><ul><li><a href=#skills>Skills</a></li><li><a href=#mindset>Mindset</a></li></ul></li><li><a href=#core-concepts>Core Concepts</a><ul><li><a href=#context-window>Context Window</a></li><li><a href=#context-engineering>Context Engineering</a></li><li><a href=#divide-and-conquer>Divide and Conquer</a></li></ul></li><li><a href=#what-is-sdd>What Is SDD</a><ul><li><a href=#levels-of-sdd>Levels of SDD</a></li><li><a href=#overview-of-key-frameworks>Overview of Key Frameworks</a></li><li><a href=#deep-dive-into-spec-kit>Deep Dive into Spec Kit</a></li><li><a href=#a-practical-example>A Practical Example</a></li></ul></li><li><a href=#coding-agents>Coding Agents</a><ul><li><a href=#how-a-coding-agent-works-under-the-hood>How a Coding Agent Works (Under the Hood)</a></li><li><a href=#ecosystem-integrated-agents>Ecosystem-Integrated Agents</a></li><li><a href=#editor-first-agents>Editor-First Agents</a></li><li><a href=#agent-platforms>Agent Platforms</a></li><li><a href=#which-agent-should-you-choose>Which Agent Should You Choose?</a></li><li><a href=#the-added-value-of-instruction-files-claudemd>The Added Value of Instruction Files: CLAUDE.md</a></li><li><a href=#what-is-claudemd>What Is CLAUDE.md</a></li><li><a href=#how-to-set-up-a-good-claudemd>How to Set Up a Good CLAUDE.md</a></li></ul></li><li><a href=#limitations-and-risks-of-sdd>Limitations and Risks of SDD</a></li><li><a href=#conclusions>Conclusions</a></li></ul></nav></div></details></div><div class=post-content><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><p>A few months ago I had to work on a complex application on AWS: a React frontend on Amplify, several Lambda functions, Bedrock with AgentCore, Knowledge Bases, and Prompt Management. I was in a hurry, and the temptation was overwhelming: open Claude Code, throw in a generic prompt, and hope it would &ldquo;figure it out.&rdquo; Instead, I did something different ‚Äî I wrote specifications, reviewed them, spent an entire day on it ‚Äî and that day it felt like I hadn&rsquo;t accomplished anything. Two days later I had a working application. If I had improvised, I&rsquo;d probably still be debugging.</p><p>This experience changed my perspective on what it truly means to use AI for software development. It&rsquo;s not about &ldquo;vibe coding&rdquo; ‚Äî writing a vague prompt and hoping for the best ‚Äî but something far more structured, and paradoxically more demanding. But before diving into the details, let&rsquo;s look around: the signs of a radical transformation are already everywhere.</p><ul><li>Last December, Boris Cherny, an Anthropic engineer and creator of Claude Code (essentially the company&rsquo;s flagship product), <a href=https://x.com/bcherny/status/2004887829252317325>stated</a> that in the previous 30 days, 100% of the work on the Claude Code repository had been done by Claude Code itself</li><li>The sharp slowdown in stock prices for some SaaS companies suggests that <a href="https://www.bloomberg.com/news/articles/2026-02-04/what-s-behind-the-saaspocalypse-plunge-in-software-stocks?embedded-checkout=true">the market has already priced in</a> the tendency for companies to build software in-house rather than buying it from the usual big players</li><li>Spotify <a href=https://techcrunch.com/2026/02/12/spotify-says-its-best-developers-havent-written-a-line-of-code-since-december-thanks-to-ai/>declared</a> that since December 2025 their best developers haven&rsquo;t written a single line of code: they send instructions via Slack to their internal system &ldquo;Honk&rdquo; (based on Claude Code), which implements the changes, while the engineers focus on review and architecture
To tackle this discussion, however, we need to leave behind the &ldquo;Vibe Coding&rdquo; hype and understand from the outset that we&rsquo;re talking about a different way of conceiving the developer&rsquo;s profession and the software assembly line.
This approach requires method and discipline, and might even be hard to swallow for some, because it risks compressing certain &ldquo;creative&rdquo; phases of the work ‚Äî which can sometimes be the most rewarding.</li></ul><h2 id=is-software-development-a-dead-profession>Is Software Development a Dead Profession?<a hidden class=anchor aria-hidden=true href=#is-software-development-a-dead-profession>#</a></h2><p>According to many analysts, we&rsquo;re looking at a &ldquo;<em>transformation</em>,&rdquo; so in a sense the answer is no. However, I believe the transformation will be so radical that within 5 to 10 years, none of us will see a job posting that simply says &ldquo;Developer.&rdquo;
The software developer of tomorrow requires highly varied expertise (architectures, networks, processes, languages, data, &mldr;). I don&rsquo;t know what this role will be called in the future, but for simplicity I&rsquo;ll call it the &ldquo;<strong>DESIGNER</strong>&rdquo; (in the sense of system designer/architect).</p><p>The same &ldquo;Designer&rdquo; pattern is already being applied in other less common domains, such as writing and journalism.
To give you an extreme example, a few months ago Luciano Floridi, one of the leading figures in the philosophy of information and the digital age, published a book titled <a href=https://www.rivista.ai/wp-content/uploads/2025/04/ssrn-5232088.pdf>Distant Writing: Literary Production in the Age of Artificial Intelligence.</a> In this work, Floridi pursues an ambitious project of interweaving stories of minor characters (mentioned but secondary) from classic English novels, from Jane Austen to Virginia Woolf, into short stories (1,500‚Äì2,000 words each) where they meet in narrative chains that are plausible given the era, location, and social status.
In interviews he has given, Floridi stated that he essentially &ldquo;designed&rdquo; the book and had it in a drawer for many years, but was able to realize it only through the use of LLMs to expand and write the individual stories, and to ensure that characters would encounter one another in a way consistent with their characteristics and the overall plot.</p><h2 id=prerequisites>Prerequisites<a hidden class=anchor aria-hidden=true href=#prerequisites>#</a></h2><p>To prepare for this transformation, I see mainly 2 prerequisites ‚Äî one technical and one mental. Neither is optional: without the right skills you can&rsquo;t produce quality specifications; without the right mindset you won&rsquo;t have the patience to write them.</p><h3 id=skills>Skills<a hidden class=anchor aria-hidden=true href=#skills>#</a></h3><p>Software specifications have existed forever ‚Äî they&rsquo;re certainly not a 2026 novelty. Yet it&rsquo;s surprising to note how the tech world is refocusing on the importance of this concept after having invented the transformer, cleared forests, and haunted stock markets with potential AI bubbles.</p><p>Spec-Driven Development techniques are obviously based on the concept of &ldquo;Specification,&rdquo; which can be understood at various levels of abstraction (e.g., user story, technical specification, code template, &mldr;).
The Designer must therefore be able to read and write specifications across the entire stack and must have a methodical and rigorous approach to industrialize the work.</p><p>But how do I write specifications for a solution with frontend components, backend, a message broker, various containers, and the need to deploy it on one hyperscaler rather than another?</p><p>In the past, you needed to know the basics of computing, CPUs, memory, data modeling, and telecommunications networks.
Now, you need to raise the level of abstraction and broaden the perspective. This means knowing data platforms, hyperscalers, authentication patterns, deployment models and containerization, automation pipelines, and managing software across dozens or potentially hundreds of branches.</p><p>To evolve from &ldquo;Developer&rdquo; of 2020 to &ldquo;Designer&rdquo; of 2026, you need:</p><ul><li>knowledge of basic DevOps practices</li><li>foundational competencies in Solution Design and the ability to navigate the most common development and deployment patterns (microservices, message brokers, containers, transport and application protocols, Security, IaC, &mldr;)</li><li>strong technical expertise in a specific area (e.g., frontend, data engineering, &mldr;)</li><li>understanding the basics of LLMs, particularly the role of context and context engineering techniques</li></ul><h3 id=mindset>Mindset<a hidden class=anchor aria-hidden=true href=#mindset>#</a></h3><p>For many people, development is a passion as well as a job, as demonstrated by the countless open-source development communities.
We need to get used to the idea that the Designer&rsquo;s work might be far less fun than today&rsquo;s Developer&rsquo;s work. This shift might be an unacceptable effort for everyone, but it&rsquo;s very likely that this is exactly where the battle over skills valued by the job market will be fought: the ability to read and write specifications will be fundamental.</p><p>We also need to fight the impulse to have &ldquo;everything right now&rdquo;: we can&rsquo;t expect to write a prompt and have the software ready. We truly need to apply a certain level of effort and genuinely use the skills we mentioned above. As I described in the introduction, the day &ldquo;wasted&rdquo; writing specifications saved me about two weeks of work. But the initial feeling was exactly that: of wasting time. It&rsquo;s a counterintuitive investment, and the right mindset consists precisely in accepting it.</p><h2 id=core-concepts>Core Concepts<a hidden class=anchor aria-hidden=true href=#core-concepts>#</a></h2><h3 id=context-window>Context Window<a hidden class=anchor aria-hidden=true href=#context-window>#</a></h3><p>Most people think: &ldquo;the more I put into the context, the better.&rdquo; This is an idea that can lead you astray, and understanding why requires a minimum understanding of how models work.</p><p>LLMs are autoregressive models based on the Transformer architecture. The heart of this architecture is the <strong>self-attention</strong> mechanism: for each generated token, the model calculates an &ldquo;attention&rdquo; score against <em>all</em> previous tokens in the context. This has two important practical implications:</p><ol><li><p><strong>Quadratic complexity</strong>: the computational cost of attention grows as O(n^2) relative to context length. Doubling the context quadruples the cost. This is not just a latency and cost issue (which are also significant), but it degrades the quality of the output itself.</p></li><li><p><strong>&ldquo;Lost in the middle&rdquo;</strong>: several studies (including the well-known paper by Liu et al., 2023) have shown that LLMs tend to pay more attention to information at the beginning and end of the context, &ldquo;forgetting&rdquo; what&rsquo;s in the middle. In practice, if the crucial specification of your API is in the middle of an 80,000-token conversation, the model might simply not take it into account.</p></li></ol><p>Although the LLM interface presents itself as a chat, we should always evaluate each interaction as if it were an <strong>isolated task</strong>, carrying along a conversational history that is often useless, pollutes the context window, and leads the model astray. This phenomenon is called <em>Context Bloat</em>.</p><h3 id=context-engineering>Context Engineering<a hidden class=anchor aria-hidden=true href=#context-engineering>#</a></h3><p>The term &ldquo;Context Engineering&rdquo; is often confused with prompt engineering, but they are distinct concepts. Prompt engineering concerns the formulation of a single request to the LLM. Context Engineering is something broader: it&rsquo;s the systematic control of <strong>everything that enters the model&rsquo;s context window</strong> ‚Äî system prompt, persistent instructions (like <code>CLAUDE.md</code>), tool results, loaded code files, memory of previous interactions, and only lastly the user&rsquo;s prompt.</p><p>Think of the context as a <strong>program</strong>: every element you insert is an instruction that the model will execute (or attempt to execute). The more contradictory or irrelevant instructions you insert, the more unpredictable the &ldquo;program&rdquo; becomes.</p><p>With this perspective, SDD techniques are essentially Context Engineering techniques: they maximize the effectiveness of the context window by making development modular (SPEC -> PLAN -> CLARIFY -> IMPLEMENTATION) and above all by minimizing noise. Each phase operates in a clean, dedicated context, with only the information relevant to that specific task.</p><h3 id=divide-and-conquer>Divide and Conquer<a hidden class=anchor aria-hidden=true href=#divide-and-conquer>#</a></h3><p>In the realm of software development, many people (including many of today&rsquo;s <strong>developers</strong>) think that the LLM is only useful for writing code, while SDD techniques are based on the assumption that the Designer uses the LLM <strong>across the entire pipeline</strong> of software work.</p><table><thead><tr><th>Phase</th><th>Objective</th><th>LLM Usage</th></tr></thead><tbody><tr><td>Ideation</td><td>Exploration of the <strong>solution space</strong></td><td>For a given problem, there are potentially infinite solutions, and LLMs are a formidable tool for exploring them</td></tr><tr><td>Specifications</td><td>Detailed definition of user requirements</td><td>Beyond defining detailed specifications, this phase also identifies any gaps and areas of ambiguity</td></tr><tr><td>Design</td><td>Having a solid baseline to write code without &ldquo;improvising&rdquo;</td><td>Research, expansion, deep-dive, and selection of software components to create/modify, plus the development plan and testing approach</td></tr><tr><td>Implementation</td><td>Translating the design into code</td><td>Writing code and tests</td></tr><tr><td>Testing</td><td>Software verification</td><td>Running tests and identifying bugs</td></tr></tbody></table><div class="callout callout-tip"><div class=callout-title>üí° Tip</div><div class=callout-content><ul><li>For each phase, it&rsquo;s worth evaluating the most suitable LLM on a case-by-case basis. For example, at the time of writing, Claude Opus 4.6 is among the top performers in pure coding, but models like the latest versions of ChatGPT, Gemini 3, or Kimi k2.5 can be more effective and creative in the solution exploration phases.</li><li>Reusing the same context for an entire development cycle is strongly discouraged, even if the model supports millions of tokens. The reason is the Context Bloat discussed above: the architectural decisions from the Planning phase, the user story details from the Specification phase, and the code from the Implementation phase all compete for the model&rsquo;s attention. The result is a progressive degradation in quality across <em>all</em> phases, not just the last one.</li></ul></div></div><style>.callout{border-left:4px solid;padding:1rem;margin:1.5rem 0;border-radius:4px;background-color:var(--callout-bg)}.callout-title{font-weight:700;margin-bottom:.5rem}.callout-note{border-color:#0969da;background-color:#ddf4ff}.callout-tip{border-color:#1a7f37;background-color:#dcffe4}.callout-important{border-color:#8250df;background-color:#fbefff}.callout-warning{border-color:#9a6700;background-color:#fff8c5}.callout-caution{border-color:#cf222e;background-color:#ffebe9}[data-theme=dark] .callout-note,.dark .callout-note{background-color:#0969da1a;color:#e6edf3}[data-theme=dark] .callout-tip,.dark .callout-tip{background-color:#1a7f371a;color:#e6edf3}[data-theme=dark] .callout-important,.dark .callout-important{background-color:#8250df1a;color:#e6edf3}[data-theme=dark] .callout-warning,.dark .callout-warning{background-color:#9a67001a;color:#e6edf3}[data-theme=dark] .callout-caution,.dark .callout-caution{background-color:#cf222e1a;color:#e6edf3}</style><h2 id=what-is-sdd>What Is SDD<a hidden class=anchor aria-hidden=true href=#what-is-sdd>#</a></h2><p><strong>Spec-Driven Development</strong> (SDD) is a paradigm that treats <strong>specifications as the primary source of truth</strong> for a software system. Code becomes a secondary artifact, generated or verified against the specification. Instead of the classic approach &ldquo;write the code first, document later,&rdquo; SDD inverts the flow: you write clear, structured specifications of the expected behavior and then generate, implement, or verify the code against them.</p><p>In other words: <strong>the specification is the product, the code is a byproduct</strong>.</p><p>This concept is not entirely new. API-first development with OpenAPI, BDD (Behavior-Driven Development), and contract-driven testing have existed for years. What changes today is that LLMs make it possible to <strong>automate the entire flow</strong>: from specification to technical plan, from plan to tasks, from tasks to code, from code to tests. The specification becomes a true <em>control plane</em> that orchestrates AI agents and human developers.</p><p>A <a href=https://www.arxiv.org/pdf/2602.00180.pdf>recent paper on arXiv</a> formalizes SDD as follows: <em>&ldquo;Specifications are the source of truth; code derives from them. The specification is the authoritative description that humans and machines use to understand, build, and evolve the system.&rdquo;</em></p><h3 id=levels-of-sdd>Levels of SDD<a hidden class=anchor aria-hidden=true href=#levels-of-sdd>#</a></h3><p>There isn&rsquo;t a single way to apply SDD. Three levels of rigor can be identified:</p><ul><li><strong>Spec-first</strong>: the specification is written before implementation and guides initial development. Ideal for new services, APIs, or features with multiple consumers.</li><li><strong>Spec-anchored</strong>: specification and code evolve together, kept in sync through tests and validation. This is the most practical level for most teams in production.</li><li><strong>Spec-as-source</strong>: humans only edit specifications; code is generated from them. Suitable for highly regulated or structured domains where traceability from requirement to code must be rigorous.</li></ul><p>Most teams will find <strong>spec-anchored</strong> to be the right compromise between rigor and agility.</p><h3 id=overview-of-key-frameworks>Overview of Key Frameworks<a hidden class=anchor aria-hidden=true href=#overview-of-key-frameworks>#</a></h3><p>The SDD tooling ecosystem is developing rapidly. Here are the three most relevant frameworks:</p><h4 id=spec-kit-github>Spec Kit (GitHub)<a hidden class=anchor aria-hidden=true href=#spec-kit-github>#</a></h4><p><a href=https://github.com/github/spec-kit>Spec Kit</a> is GitHub&rsquo;s open-source toolkit for SDD. It proposes a multi-phase workflow (<code>Specify -> Plan -> Tasks -> Implement</code>) and generates versioned Markdown artifacts in the repository. It&rsquo;s compatible with GitHub Copilot, Claude Code, Cursor, and Gemini CLI. We&rsquo;ll dive deeper into Spec Kit in the next chapter.</p><h4 id=openspec-fission-ai>OpenSpec (Fission AI)<a hidden class=anchor aria-hidden=true href=#openspec-fission-ai>#</a></h4><p><a href=https://openspec.pro/>OpenSpec</a> is a lightweight, open-source framework (TypeScript) designed to bring determinism to AI development. Its distinctive features:</p><ul><li><strong>Delta Specs</strong>: captures incremental changes in requirements, rather than rewriting the entire specification</li><li><strong>Brownfield-first</strong>: designed to evolve existing codebases, not just greenfield projects</li><li><strong>No API key or complex installation</strong>: specifications live in the repository alongside the code</li><li>Supports over 20 tools, including Claude Code, Cursor, and GitHub Copilot</li></ul><h4 id=bmad-method>BMAD Method<a hidden class=anchor aria-hidden=true href=#bmad-method>#</a></h4><p>The <a href=https://github.com/bmad-code-org/BMAD-METHOD>BMAD Method</a> (Breakthrough Method for Agile AI-Driven Development) is a more ambitious open-source framework, with:</p><ul><li><strong>21 specialized AI agents</strong> (Analyst, Product Manager, Architect, Developer, QA, Scrum Master, &mldr;) each with defined roles and responsibilities</li><li><strong>50+ guided workflows</strong> for different project types and phases</li><li><strong>Multi-agent architecture</strong>: agents collaborate from ideation to implementation</li><li>Compatible with Claude Code, Cursor, Windsurf, and other AI IDEs</li></ul><p>Here&rsquo;s a quick guide to help you choose:</p><table><thead><tr><th>Criterion</th><th>Spec Kit</th><th>OpenSpec</th><th>BMAD</th></tr></thead><tbody><tr><td>Setup complexity</td><td>Low (CLI + Markdown)</td><td>Very low (files in repo)</td><td>Medium-high (21 agents to configure)</td></tr><tr><td>Ideal for</td><td>Greenfield projects with GitHub</td><td>Evolving existing codebases</td><td>Enterprise projects with structured teams</td></tr><tr><td>Learning curve</td><td>~1 hour</td><td>~30 minutes</td><td>~1 day</td></tr><tr><td>Lock-in</td><td>Low (Markdown + Git)</td><td>None (files in repo)</td><td>Medium (framework dependency)</td></tr><tr><td>Brownfield support</td><td>Limited</td><td>Excellent (Delta Specs)</td><td>Good</td></tr></tbody></table><p>In general: start with <strong>Spec Kit</strong> if you use GitHub and want a structured but lightweight workflow. Choose <strong>OpenSpec</strong> if you need to evolve an existing codebase without disrupting your workflow. Consider <strong>BMAD</strong> only if your project requires multi-role coordination and you have the time budget to configure the entire orchestra of agents.</p><h3 id=deep-dive-into-spec-kit>Deep Dive into Spec Kit<a hidden class=anchor aria-hidden=true href=#deep-dive-into-spec-kit>#</a></h3><p>Spec Kit deserves a deeper look because it represents the state of the art in SDD applied to coding agents and is directly backed by GitHub and Microsoft.</p><p>The Spec Kit workflow is organized into well-defined steps, each with a dedicated command:</p><p><strong>1. Project Constitution (<code>/speckit.constitution</code>)</strong></p><p>You define the non-negotiable principles of the project: coding standards, testing requirements, security rules, UX principles, performance targets. The <em>constitution</em> is automatically consulted at every subsequent phase as a constraint.</p><p><strong>2. Functional Specification (<code>/speckit.specify</code>)</strong></p><p>An idea is transformed into a structured functional specification: user stories, functional requirements, acceptance criteria. No technical details here ‚Äî only the <em>what</em> and the <em>why</em>. Spec Kit automatically creates a dedicated Git branch for the feature.</p><p><strong>3. Clarification (<code>/speckit.clarify</code>)</strong></p><p>The AI agent asks structured questions to eliminate ambiguities from the specification: edge cases, constraints, error handling, permissions. This phase is critical: an ambiguous specification produces ambiguous code.</p><p><strong>4. Technical Plan (<code>/speckit.plan</code>)</strong></p><p>The validated specification is translated into a detailed technical plan: architectural decisions, data models, APIs, integrations. This is where you choose the stack, patterns, and interfaces. Generated artifacts include <code>plan.md</code>, <code>data-model.md</code>, and a <code>contracts/</code> folder with API specifications.</p><p><strong>5. Validation (<code>/speckit.checklist</code>, <code>/speckit.analyze</code>)</strong></p><p>Quality control and consistency checking across all artifacts before writing code. Inconsistencies, gaps, and quality issues are identified.</p><p><strong>6. Task Decomposition (<code>/speckit.tasks</code>)</strong></p><p>The plan is decomposed into small, reviewable work units: each task has explicit inputs, outputs, and success criteria tied to the specification. Tasks are ordered by dependencies, and parallelizable ones are marked.</p><p><strong>7. Implementation (<code>/speckit.implement</code>)</strong></p><p>The AI agent executes the tasks, generating and modifying code, tests, and configurations according to the plan. Code is produced in small diffs, easily reviewable.</p><h3 id=a-practical-example>A Practical Example<a hidden class=anchor aria-hidden=true href=#a-practical-example>#</a></h3><p>Let&rsquo;s imagine we want to develop a simple API for managing a book library. Here&rsquo;s how the flow would unfold with Spec Kit:</p><p><strong>Phase 1 - Constitution:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>/speckit.constitution
</span></span><span class=line><span class=cl>The project follows an API-first approach. We use Python with FastAPI.
</span></span><span class=line><span class=cl>Every endpoint must have unit tests. Security: JWT authentication.
</span></span><span class=line><span class=cl>PostgreSQL database with Alembic for migrations.
</span></span></code></pre></div><p><strong>Phase 2 - Specify:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>/speckit.specify
</span></span><span class=line><span class=cl>Build a REST API to manage a book library.
</span></span><span class=line><span class=cl>Users can search books by title, author, or ISBN.
</span></span><span class=line><span class=cl>Administrators can add, modify, and remove books.
</span></span><span class=line><span class=cl>Each book has: title, author, ISBN, publication year, genre.
</span></span><span class=line><span class=cl>Include user stories and acceptance criteria.
</span></span></code></pre></div><p>At this point, Spec Kit generates a structured <code>spec.md</code> file with user stories like:</p><ul><li><em>As a user, I want to search books by title, so I can quickly find the book I&rsquo;m interested in</em></li><li><em>As an administrator, I want to add a new book to the catalog, specifying all metadata</em></li></ul><p><strong>Phase 3 - Clarify:</strong> The agent asks, for example: &ldquo;Are there limits on the number of results per page? What happens if someone tries to insert a duplicate ISBN? Which fields are required?&rdquo;</p><p><strong>Phase 4 - Plan:</strong> A technical plan is generated. Here&rsquo;s a realistic excerpt from the generated <code>plan.md</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gh># Technical Plan - Library API
</span></span></span><span class=line><span class=cl><span class=gh></span>
</span></span><span class=line><span class=cl><span class=gu>## Architecture
</span></span></span><span class=line><span class=cl><span class=gu></span><span class=k>-</span> Framework: FastAPI with Pydantic v2 for validation
</span></span><span class=line><span class=cl><span class=k>-</span> Database: PostgreSQL 16 with SQLAlchemy 2.0 (async)
</span></span><span class=line><span class=cl><span class=k>-</span> Migrations: Alembic with autogenerate
</span></span><span class=line><span class=cl><span class=k>-</span> Auth: JWT (access token 15min + refresh token 7d)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Data Model
</span></span></span><span class=line><span class=cl><span class=gu></span>
</span></span><span class=line><span class=cl><span class=gu>### Book
</span></span></span><span class=line><span class=cl><span class=gu></span>| Field        | Type         | Constraints                 |
</span></span><span class=line><span class=cl>|-------------|-------------|---------------------------|
</span></span><span class=line><span class=cl>| id          | UUID        | PK, auto-generated         |
</span></span><span class=line><span class=cl>| title       | VARCHAR(255)| NOT NULL, INDEX            |
</span></span><span class=line><span class=cl>| author      | VARCHAR(255)| NOT NULL, INDEX            |
</span></span><span class=line><span class=cl>| isbn        | VARCHAR(13) | UNIQUE, NOT NULL           |
</span></span><span class=line><span class=cl>| year        | INTEGER     | CHECK (year &gt;= 1450)       |
</span></span><span class=line><span class=cl>| genre       | VARCHAR(100)| NULL                       |
</span></span><span class=line><span class=cl>| created_at  | TIMESTAMP   | DEFAULT now()              |
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## REST Endpoints
</span></span></span><span class=line><span class=cl><span class=gu></span><span class=k>-</span> <span class=sb>`GET /books?title=&amp;author=&amp;isbn=&amp;page=1&amp;size=20`</span> -&gt; 200 + pagination
</span></span><span class=line><span class=cl><span class=k>-</span> <span class=sb>`GET /books/{id}`</span> -&gt; 200 | 404
</span></span><span class=line><span class=cl><span class=k>-</span> <span class=sb>`POST /books`</span> -&gt; 201 | 400 (validation) | 409 (duplicate ISBN)
</span></span><span class=line><span class=cl><span class=k>-</span> <span class=sb>`PUT /books/{id}`</span> -&gt; 200 | 404
</span></span><span class=line><span class=cl><span class=k>-</span> <span class=sb>`DELETE /books/{id}`</span> -&gt; 204 | 404
</span></span><span class=line><span class=cl><span class=k>-</span> All POST/PUT/DELETE methods require header <span class=sb>`Authorization: Bearer &lt;token&gt;`</span>
</span></span></code></pre></div><p>Note the level of detail: types, constraints, response codes, authentication rules. There&rsquo;s no ambiguity, and the AI agent receiving this plan won&rsquo;t have to &ldquo;guess&rdquo; anything.</p><p><strong>Phase 5-6 - Checklist & Tasks:</strong> Tasks are generated such as:</p><ol><li>Create SQLAlchemy models (Book, User)</li><li>Configure Alembic and create the initial migration</li><li>Implement the <code>GET /books</code> endpoint with filters and pagination</li><li>Implement the <code>POST /books</code> endpoint with validation</li><li>Add JWT authentication</li><li>Write tests for each endpoint</li></ol><p>Each task has explicit inputs, outputs, and success criteria. Parallelizable tasks are marked with <code>[P]</code>, sequential ones are ordered by dependencies.</p><p><strong>Phase 7 - Implement:</strong> The agent executes each task, producing verifiable code and tests.</p><p>The key point is that every phase produces versioned Markdown artifacts in the repository, creating complete traceability from idea to code. If six months from now someone asks &ldquo;why does this API work this way?&rdquo;, the answer is in the specification.</p><h2 id=coding-agents>Coding Agents<a hidden class=anchor aria-hidden=true href=#coding-agents>#</a></h2><p>SDD is the methodology, but putting it into practice requires the right tools. <strong>Coding agents</strong> are the operational component of this new paradigm: AI agents that go beyond auto-completion ‚Äî they plan tasks, modify codebases, run tests, and collaborate through existing DevOps workflows.</p><h3 id=how-a-coding-agent-works-under-the-hood>How a Coding Agent Works (Under the Hood)<a hidden class=anchor aria-hidden=true href=#how-a-coding-agent-works-under-the-hood>#</a></h3><p>Before surveying the tools, it&rsquo;s worth understanding what distinguishes an &ldquo;agent&rdquo; from a simple chatbot. A coding agent operates according to a continuous <strong>agentic loop</strong>, which in pseudocode can be represented as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>while</span> <span class=n>task</span> <span class=ow>is</span> <span class=ow>not</span> <span class=n>complete</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>context</span>  <span class=o>=</span> <span class=n>gather</span><span class=p>(</span><span class=n>specs</span><span class=p>,</span> <span class=n>code</span><span class=p>,</span> <span class=n>test_results</span><span class=p>,</span> <span class=n>errors</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>plan</span>     <span class=o>=</span> <span class=n>reason</span><span class=p>(</span><span class=n>context</span><span class=p>)</span>           <span class=c1># the LLM decides what to do</span>
</span></span><span class=line><span class=cl>    <span class=n>action</span>   <span class=o>=</span> <span class=n>select_tool</span><span class=p>(</span><span class=n>plan</span><span class=p>)</span>         <span class=c1># tool selection: edit, bash, search...</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span>   <span class=o>=</span> <span class=n>execute</span><span class=p>(</span><span class=n>action</span><span class=p>)</span>           <span class=c1># real execution on filesystem/terminal</span>
</span></span><span class=line><span class=cl>    <span class=n>feedback</span> <span class=o>=</span> <span class=n>verify</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>            <span class=c1># test, lint, command output</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>feedback</span><span class=o>.</span><span class=n>has_errors</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>context</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>feedback</span><span class=p>)</span>         <span class=c1># the error becomes input for the next cycle</span>
</span></span></code></pre></div><p>The key mechanism is <strong>tool use</strong> (or function calling): the LLM doesn&rsquo;t just generate text ‚Äî it emits structured calls to external tools: file editors, bash terminal, browser, APIs. This allows it to interact with the real world: read a file, modify it, run tests, and react to results.</p><p>The fundamental difference between the various agents on the market lies in <em>which tools</em> they have available and in <em>which environment</em> they operate:</p><ul><li><strong>Agents with direct filesystem access</strong> (Claude Code, Cursor): operate on your machine, with full access to terminal and files. Maximum flexibility, but require supervision.</li><li><strong>Agents in isolated sandbox</strong> (Devin, GitHub Copilot coding agent): operate in a dedicated cloud environment. Safer for full autonomy, but less flexible for custom workflows.</li></ul><p>The coding agent landscape has evolved rapidly, and today we can distinguish several categories:</p><h3 id=ecosystem-integrated-agents>Ecosystem-Integrated Agents<a hidden class=anchor aria-hidden=true href=#ecosystem-integrated-agents>#</a></h3><ul><li><strong>GitHub Copilot coding agent</strong>: works directly within the Pull Request workflow. You can assign an issue to <code>@copilot</code> and the agent plans, modifies code, runs tests, and opens a PR autonomously. It&rsquo;s the native target for Spec Kit.</li><li><strong>Amazon Q Developer</strong>: AWS&rsquo;s AI assistant, particularly strong for cloud-native development, IaC, and application transformations (e.g., Java 8->17 migration).</li><li><strong>Google Gemini Code Assist</strong>: strong integration with Google Cloud services (BigQuery, Firebase, Apigee). Explicitly supported by Spec Kit as an SDD target.</li></ul><h3 id=editor-first-agents>Editor-First Agents<a hidden class=anchor aria-hidden=true href=#editor-first-agents>#</a></h3><ul><li><strong>Cursor</strong>: a fork of VS Code that&rsquo;s natively AI-first. The Agentic + Composer mode allows planning multi-step tasks, modifying multiple files, executing terminal commands, and iterating until tests pass.</li><li><strong>JetBrains AI Assistant & Junie</strong>: integrated across all JetBrains IDEs, Junie offers agentic programming for implementing fixes, refactoring, and tests.</li></ul><h3 id=agent-platforms>Agent Platforms<a hidden class=anchor aria-hidden=true href=#agent-platforms>#</a></h3><ul><li><strong>Claude Code / Claude Agent SDK</strong>: Anthropic&rsquo;s platform based on the principle &ldquo;give the agent a computer.&rdquo; Claude Code has access to terminal and file system and operates with a continuous cycle: <em>gather context -> act -> verify -> repeat</em>. The Agent SDK allows building custom agents.</li><li><strong>Devin (Cognition)</strong>: a fully autonomous agent with its own integrated development environment (shell, editor, browser). Still experimental and not very &ldquo;enterprise-ready.&rdquo;</li></ul><h3 id=which-agent-should-you-choose>Which Agent Should You Choose?<a hidden class=anchor aria-hidden=true href=#which-agent-should-you-choose>#</a></h3><p>For a company looking to adopt SDD today, a pragmatic approach is:</p><ul><li><strong>GitHub Copilot</strong> or <strong>Amazon Q</strong> for issue/PR-driven work on core services</li><li><strong>Gemini Code Assist</strong> for SDD workflows on analytics and GCP integrations</li><li><strong>Cursor</strong> or <strong>JetBrains</strong> in the IDE for high-fidelity implementation from specifications</li><li><strong>Claude Code / Agent SDK</strong> for custom SDD pipelines where standard tools are too rigid</li></ul><h3 id=the-added-value-of-instruction-files-claudemd>The Added Value of Instruction Files: CLAUDE.md<a hidden class=anchor aria-hidden=true href=#the-added-value-of-instruction-files-claudemd>#</a></h3><p>One of the most powerful concepts to emerge with coding agents is that of <strong>persistent instruction files</strong>: Markdown files that the agent reads automatically at the start of every session to understand the project context. Each agent has its own format (<code>.github/copilot-instructions.md</code> for Copilot, <code>.cursorrules</code> for Cursor, etc.), but the most well-known and mature is Claude Code&rsquo;s <code>CLAUDE.md</code>.</p><h3 id=what-is-claudemd>What Is CLAUDE.md<a hidden class=anchor aria-hidden=true href=#what-is-claudemd>#</a></h3><p><code>CLAUDE.md</code> is a project-specific instruction file that Claude Code reads automatically when starting in a directory. Its purpose is to:</p><ul><li>Give Claude the <strong>minimum context</strong> it cannot infer from the code</li><li>Codify <strong>critical rules and caveats</strong> that must be respected in every task</li><li>Improve reliability and speed by avoiding repeated explanations</li></ul><p>Think of it as a <strong>carefully curated system prompt</strong>, not a wiki. It&rsquo;s a <strong>living contract</strong> between the codebase and the AI agents.</p><h3 id=how-to-set-up-a-good-claudemd>How to Set Up a Good CLAUDE.md<a hidden class=anchor aria-hidden=true href=#how-to-set-up-a-good-claudemd>#</a></h3><p>Best practices, confirmed by both Anthropic documentation and empirical community experience, converge on several key principles.
These principles are not specific to Claude Code but derive from the general characteristics of LLMs, and therefore apply to any assistant or coding agent, even if the specific format may vary depending on the tool.</p><p><strong>1. Less is more</strong></p><p>Every additional line can <em>reduce</em> the overall quality of instruction adherence. LLMs can follow only a limited number of distinct instructions with high fidelity. When there are too many, adherence to <em>all</em> rules degrades ‚Äî it&rsquo;s not that the last ones are ignored; all of them get worse.</p><p><strong>2. High signal, low noise</strong></p><p>Only include information that is:</p><ul><li>Hard for Claude to infer by reading the code</li><li>Relevant to the vast majority of daily tasks</li></ul><p><strong>3. The minimum effective structure</strong></p><p>A good <code>CLAUDE.md</code> typically contains three blocks:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gh># CLAUDE.md
</span></span></span><span class=line><span class=cl><span class=gh></span>
</span></span><span class=line><span class=cl><span class=gu>## Project
</span></span></span><span class=line><span class=cl><span class=gu></span>This is a Next.js + TypeScript e-commerce portal that communicates
</span></span><span class=line><span class=cl>with our internal payment and catalog APIs.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Key Commands
</span></span></span><span class=line><span class=cl><span class=gu></span><span class=k>-</span> Install dependencies: <span class=sb>`pnpm install`</span>
</span></span><span class=line><span class=cl><span class=k>-</span> Dev server: <span class=sb>`pnpm dev`</span>
</span></span><span class=line><span class=cl><span class=k>-</span> Build: <span class=sb>`pnpm build`</span>
</span></span><span class=line><span class=cl><span class=k>-</span> Test: <span class=sb>`pnpm test`</span>
</span></span><span class=line><span class=cl><span class=k>-</span> Lint: <span class=sb>`pnpm lint`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## IMPORTANT Caveats
</span></span></span><span class=line><span class=cl><span class=gu></span><span class=k>-</span> IMPORTANT: Do not modify <span class=sb>`prisma/schema.prisma`</span> directly.
</span></span><span class=line><span class=cl>  Use <span class=sb>`pnpm db:migrate`</span> and <span class=sb>`pnpm db:generate`</span>.
</span></span><span class=line><span class=cl><span class=k>-</span> IMPORTANT: The <span class=sb>`/api/webhooks/stripe`</span> endpoint expects the raw
</span></span><span class=line><span class=cl>  request body. DO NOT use a body parser.
</span></span><span class=line><span class=cl><span class=k>-</span> Images in <span class=sb>`public/`</span> must be optimized before committing;
</span></span><span class=line><span class=cl>  files &gt; 200KB will fail CI.
</span></span></code></pre></div><p><strong>4. Don&rsquo;t include style rules</strong></p><p>Rules like &ldquo;use two spaces for indentation&rdquo; or &ldquo;use single quotes&rdquo; are a waste of instructions: Claude infers them from existing code, and linters and formatters handle them better anyway.</p><p><strong>5. Progressive disclosure</strong></p><p>For detailed but rarely needed information, don&rsquo;t weigh down the main file. Instead:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gu>## Additional Documentation
</span></span></span><span class=line><span class=cl><span class=gu></span><span class=k>-</span> Database schema and migrations: read <span class=sb>`docs/schema.md`</span> when
</span></span><span class=line><span class=cl>  modifying models.
</span></span></code></pre></div><p>Claude will open <code>docs/schema.md</code> only when necessary, instead of loading it on every task.</p><p><strong>6. Path-specific rules with <code>.claude/rules/</code></strong></p><p>Claude Code supports path-specific instruction files:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gh># .claude/rules/tests.md
</span></span></span><span class=line><span class=cl><span class=gh></span>paths: [&#34;**/*.spec.ts&#34;, &#34;**/*.test.ts&#34;]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Testing Rules
</span></span></span><span class=line><span class=cl><span class=gu></span><span class=k>-</span> Use Vitest, not Jest.
</span></span><span class=line><span class=cl><span class=k>-</span> Use the helpers in <span class=sb>`test-utils/`</span> for component rendering.
</span></span></code></pre></div><p>This file is loaded only when Claude works on test files, keeping the global <code>CLAUDE.md</code> leaner.</p><p><strong>7. Continuous maintenance</strong></p><p>Treat <code>CLAUDE.md</code> as a living document: update it when you notice Claude repeating avoidable mistakes, remove obsolete instructions, reorder by importance. The most important rules should always be <strong>at the top of the file</strong>.</p><h2 id=limitations-and-risks-of-sdd>Limitations and Risks of SDD<a hidden class=anchor aria-hidden=true href=#limitations-and-risks-of-sdd>#</a></h2><p>It would be dishonest to present SDD as a solution without issues. There are concrete limitations worth knowing before adopting it:</p><ul><li><strong>Non-determinism.</strong> LLMs are not deterministic: the same specification, given to the same model at two different times, can produce structurally different code. This means SDD doesn&rsquo;t guarantee reproducibility. The specification drastically reduces variance compared to a generic prompt, but doesn&rsquo;t eliminate it. That&rsquo;s why contract tests and automated validation are indispensable ‚Äî they&rsquo;re the &ldquo;deterministic guardrail&rdquo; that compensates for the probabilistic nature of the model.
At the same time, though, it&rsquo;s worth reflecting on the fact that, in general, the same concept applies to humans as well: the same developer, reading the same specification at two different times, can write different code.</li><li><strong>Garbage in, garbage out (shifted up a level).</strong> If I use an LLM to generate the specifications themselves, who validates them? The risk is automating the production of plausible but incorrect specifications ‚Äî for example, a data model that seems reasonable but violates an unstated business rule. Human review of specifications is not optional: it&rsquo;s the critical control point of the entire workflow.</li><li><strong>Scalability.</strong> The book library example works well, but what happens with a distributed system of 200 microservices? SDD scales well as long as specifications remain modularizable ‚Äî one service at a time, one feature at a time. When cross-service dependencies become too intricate, the specifications themselves risk becoming a maintenance problem. This isn&rsquo;t a reason not to adopt SDD, but it is a reason not to think of it as a magic wand.</li><li><strong>Costs.</strong> A complete SDD workflow (specify -> clarify -> plan -> tasks -> implement) consumes significantly more tokens than a single prompt. Each phase involves one or more calls to the LLM, each with its own context. On top-tier models like Claude Opus or GPT-4, a complete cycle for a medium-complexity feature can cost between 5 and 20 dollars in tokens. It&rsquo;s an investment that pays for itself amply in terms of time saved, but it needs to be planned ‚Äî especially for teams working on dozens of features in parallel.</li><li><strong>Overhead for simple projects.</strong> A complete SDD workflow for a 50-line script is over-engineering. SDD performs best on features with medium-to-high complexity, where ambiguities are the real cost. For trivial tasks, a good direct prompt remains the best choice.</li></ul><p>All these limitations are, however, manageable through a disciplined and aware approach. In other words, a naive &ldquo;vibe-coding&rdquo; approach may work fine for a small prototype, but as project complexity increases, it becomes necessary to apply SDD techniques with ever-greater rigor to avoid running into these problems.</p><h2 id=conclusions>Conclusions<a hidden class=anchor aria-hidden=true href=#conclusions>#</a></h2><p>Spec-Driven Development is neither a passing fad nor an academic exercise.</p><p>It is a methodological and disciplined approach to software development through AI Agents, leveraging the capabilities of agents across the entire development stack ‚Äî from exploring the solution space, to writing detailed specifications, to technical planning, through to implementation and testing.</p><p>But as we&rsquo;ve seen, it&rsquo;s not without limitations: the non-determinism of LLMs, the risk of incorrect specifications, token costs, and overhead for simple projects are all factors to consider. SDD works best when applied with judgment, not as dogma.</p><p>For those working in software development today, the message is clear:</p><ol><li><strong>Invest in cross-cutting skills</strong>: architecture, DevOps, data models, security. The Designer of the future isn&rsquo;t the one who writes the fastest code, but the one who writes the most precise specifications.</li><li><strong>Adopt gradually</strong>: start with API-first and contract tests. Then add an SDD framework like Spec Kit on a new feature. Measure the results.</li><li><strong>Abandon Vibe Coding</strong>: writing vague prompts and hoping for the best doesn&rsquo;t scale. Investing a day in specifications to save two weeks of work isn&rsquo;t &ldquo;wasting time&rdquo; ‚Äî it&rsquo;s the Designer&rsquo;s craft.</li><li><strong>Prepare for the mindset shift</strong>: it will be less &ldquo;fun&rdquo; in the traditional sense, but the satisfaction of orchestrating a complex system through specifications that produce working software is, in its own way, equally rewarding.</li></ol><p>The future of software development isn&rsquo;t writing code. It&rsquo;s designing systems and letting the code write itself ‚Äî but under the rigorous control of someone who knows what they want to achieve.</p><section id=comments><script src=https://giscus.app/client.js data-repo=c-daniele/c-daniele.github.io data-repo-id=R_kgDOKIObxg data-category=Announcements data-category-id=DIC_kwDOKIObxs4Cu2th data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=it crossorigin=anonymous async></script></section></div><footer class=post-footer><ul class=post-tags><li><a href=https://c-daniele.github.io/en/tags/genai/>GenAI</a></li><li><a href=https://c-daniele.github.io/en/tags/agents/>Agents</a></li><li><a href=https://c-daniele.github.io/en/tags/coding/>Coding</a></li></ul><nav class=paginav><a class=next href=https://c-daniele.github.io/en/posts/2025-11-10-genai-frameworks-update/><span class=title>Next ¬ª</span><br><span>Why LangChain Is Still the Best Framework for GenAI</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share The Developer --> Designer switch on twitter" href="https://twitter.com/intent/tweet/?text=The%20Developer%20--%3e%20Designer%20switch&amp;url=https%3a%2f%2fc-daniele.github.io%2fen%2fposts%2f2026-02-14-intro-spec-driven-development%2f&amp;hashtags=GenAI%2cAgents%2cCoding"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share The Developer --> Designer switch on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fc-daniele.github.io%2fen%2fposts%2f2026-02-14-intro-spec-driven-development%2f&amp;title=The%20Developer%20--%3e%20Designer%20switch&amp;summary=The%20Developer%20--%3e%20Designer%20switch&amp;source=https%3a%2f%2fc-daniele.github.io%2fen%2fposts%2f2026-02-14-intro-spec-driven-development%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share The Developer --> Designer switch on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fc-daniele.github.io%2fen%2fposts%2f2026-02-14-intro-spec-driven-development%2f&title=The%20Developer%20--%3e%20Designer%20switch"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share The Developer --> Designer switch on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fc-daniele.github.io%2fen%2fposts%2f2026-02-14-intro-spec-driven-development%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share The Developer --> Designer switch on whatsapp" href="https://api.whatsapp.com/send?text=The%20Developer%20--%3e%20Designer%20switch%20-%20https%3a%2f%2fc-daniele.github.io%2fen%2fposts%2f2026-02-14-intro-spec-driven-development%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share The Developer --> Designer switch on telegram" href="https://telegram.me/share/url?text=The%20Developer%20--%3e%20Designer%20switch&amp;url=https%3a%2f%2fc-daniele.github.io%2fen%2fposts%2f2026-02-14-intro-spec-driven-development%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share The Developer --> Designer switch on ycombinator" href="https://news.ycombinator.com/submitlink?t=The%20Developer%20--%3e%20Designer%20switch&u=https%3a%2f%2fc-daniele.github.io%2fen%2fposts%2f2026-02-14-intro-spec-driven-development%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://c-daniele.github.io/en/>Cdani's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>