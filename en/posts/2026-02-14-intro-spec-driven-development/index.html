<!doctype html><html lang=en-US><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>The Developer --> Designer switch - Cdani's Blog</title><meta name=Description content="Cdani's Blog"><meta property="og:url" content="https://c-daniele.github.io/en/posts/2026-02-14-intro-spec-driven-development/"><meta property="og:site_name" content="Cdani's Blog"><meta property="og:title" content="The Developer --> Designer switch"><meta property="og:description" content="Intro A few months ago I had to work on a complex application on AWS: a React frontend on Amplify, several Lambda functions, Bedrock with AgentCore, Knowledge Bases, and Prompt Management. I was in a hurry, and the temptation was overwhelming: open Claude Code, throw in a generic prompt, and hope it would â€œfigure it out.â€ Instead, I did something different â€” I wrote specifications, reviewed them, spent an entire day on it â€” and that day it felt like I hadnâ€™t accomplished anything. Two days later I had a working application. If I had improvised, Iâ€™d probably still be debugging."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-14T00:00:00+02:00"><meta property="article:modified_time" content="2026-02-14T00:00:00+02:00"><meta property="article:tag" content="GenAI"><meta property="article:tag" content="Agents"><meta property="article:tag" content="Coding"><meta property="og:image" content="https://c-daniele.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://c-daniele.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="The Developer --> Designer switch"><meta name=twitter:description content="Intro A few months ago I had to work on a complex application on AWS: a React frontend on Amplify, several Lambda functions, Bedrock with AgentCore, Knowledge Bases, and Prompt Management. I was in a hurry, and the temptation was overwhelming: open Claude Code, throw in a generic prompt, and hope it would â€œfigure it out.â€ Instead, I did something different â€” I wrote specifications, reviewed them, spent an entire day on it â€” and that day it felt like I hadnâ€™t accomplished anything. Two days later I had a working application. If I had improvised, Iâ€™d probably still be debugging."><meta name=application-name content="Cdani's Blog"><meta name=apple-mobile-web-app-title content="Cdani's Blog"><meta name=referrer content="no-referrer"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=/logo_cd_v3.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#00872b><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://c-daniele.github.io/en/posts/2026-02-14-intro-spec-driven-development/><link rel=prev href=https://c-daniele.github.io/en/posts/2025-11-10-genai-frameworks-update/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"The Developer --\u003e Designer switch","inLanguage":"en-US","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/c-daniele.github.io\/en\/posts\/2026-02-14-intro-spec-driven-development\/"},"genre":"posts","keywords":"GenAI, Agents, Coding","wordcount":4918,"url":"https:\/\/c-daniele.github.io\/en\/posts\/2026-02-14-intro-spec-driven-development\/","datePublished":"2026-02-14T00:00:00+02:00","dateModified":"2026-02-14T00:00:00+02:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Me"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script>const query=window.matchMedia("(prefers-color-scheme: dark)");function applyTheme(){let e=window.localStorage?.getItem("theme")||"auto",t=e==="dark"||e==="auto"&&query.matches;document.body.setAttribute("theme",t?"dark":"light"),document.body.setAttribute("cfg-theme",e)}applyTheme(),query.addEventListener("change",applyTheme)</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/en/ title="Cdani's Blog"><img class="lazyload logo" src=/svg/loading.min.svg data-src=/logo_cd_v3.svg data-srcset="/logo_cd_v3.svg, /logo_cd_v3.svg 1.5x, /logo_cd_v3.svg 2x" data-sizes=auto alt=/logo_cd_v3.svg title=/logo_cd_v3.svg>Cdani's Blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/en/posts/>Archive </a><a class=menu-item href=/en/tags/>Tags </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=Search... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="menu-item language" title="Select Language"><i class="fa fa-globe fa-fw" aria-hidden=true></i>
<select class=language-select id=language-select-desktop onchange="location=this.value"><option value=/it/posts/2026-02-14-intro-spec-driven-development/>Italiano</option><option value=/en/posts/2026-02-14-intro-spec-driven-development/ selected>English</option></select></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/en/ title="Cdani's Blog"><img class="lazyload logo" src=/svg/loading.min.svg data-src=/logo_cd_v3.svg data-srcset="/logo_cd_v3.svg, /logo_cd_v3.svg 1.5x, /logo_cd_v3.svg 2x" data-sizes=auto alt=/logo_cd_v3.svg title=/logo_cd_v3.svg>Cdani's Blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=Search... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/en/posts/ title>Archive</a><a class=menu-item href=/en/tags/ title>Tags</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class=menu-item title="Select Language"><i class="fa fa-globe fa-fw" aria-hidden=true></i>
<select class=language-select onchange="location=this.value"><option value=/it/posts/2026-02-14-intro-spec-driven-development/>Italiano</option><option value=/en/posts/2026-02-14-intro-spec-driven-development/ selected>English</option></select></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">The Developer --> Designer switch</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/en/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Me</a></span>&nbsp;<span class=post-category>included in <a href=/en/categories/software-development/><i class="far fa-folder fa-fw" aria-hidden=true></i>Software Development</a>&nbsp;<a href=/en/categories/artificial-intelligence/><i class="far fa-folder fa-fw" aria-hidden=true></i>Artificial Intelligence</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime="February 14, 2026">February 14, 2026</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;4918 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;24 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#is-software-development-a-dead-profession>Is Software Development a Dead Profession?</a></li><li><a href=#prerequisites>Prerequisites</a><ul><li><a href=#skills>Skills</a></li><li><a href=#mindset>Mindset</a></li></ul></li><li><a href=#core-concepts>Core Concepts</a><ul><li><a href=#context-window>Context Window</a></li><li><a href=#context-engineering>Context Engineering</a></li><li><a href=#divide-and-conquer>Divide and Conquer</a></li></ul></li><li><a href=#what-is-sdd>What Is SDD</a><ul><li><a href=#levels-of-sdd>Levels of SDD</a></li><li><a href=#overview-of-key-frameworks>Overview of Key Frameworks</a></li><li><a href=#deep-dive-into-spec-kit>Deep Dive into Spec Kit</a></li><li><a href=#a-practical-example>A Practical Example</a></li></ul></li><li><a href=#coding-agents>Coding Agents</a><ul><li><a href=#how-a-coding-agent-works-under-the-hood>How a Coding Agent Works (Under the Hood)</a></li><li><a href=#ecosystem-integrated-agents>Ecosystem-Integrated Agents</a></li><li><a href=#editor-first-agents>Editor-First Agents</a></li><li><a href=#agent-platforms>Agent Platforms</a></li><li><a href=#which-agent-should-you-choose>Which Agent Should You Choose?</a></li><li><a href=#the-added-value-of-instruction-files-claudemd>The Added Value of Instruction Files: CLAUDE.md</a></li><li><a href=#what-is-claudemd>What Is CLAUDE.md</a></li><li><a href=#how-to-set-up-a-good-claudemd>How to Set Up a Good CLAUDE.md</a></li></ul></li><li><a href=#limitations-and-risks-of-sdd>Limitations and Risks of SDD</a></li><li><a href=#conclusions>Conclusions</a></li></ul></nav></div></div><div class=content id=content><h2 id=intro>Intro</h2><p>A few months ago I had to work on a complex application on AWS: a React frontend on Amplify, several Lambda functions, Bedrock with AgentCore, Knowledge Bases, and Prompt Management. I was in a hurry, and the temptation was overwhelming: open Claude Code, throw in a generic prompt, and hope it would &ldquo;figure it out.&rdquo; Instead, I did something different â€” I wrote specifications, reviewed them, spent an entire day on it â€” and that day it felt like I hadn&rsquo;t accomplished anything. Two days later I had a working application. If I had improvised, I&rsquo;d probably still be debugging.</p><p>This experience changed my perspective on what it truly means to use AI for software development. It&rsquo;s not about &ldquo;vibe coding&rdquo; â€” writing a vague prompt and hoping for the best â€” but something far more structured, and paradoxically more demanding. But before diving into the details, let&rsquo;s look around: the signs of a radical transformation are already everywhere.</p><ul><li>Last December, Boris Cherny, an Anthropic engineer and creator of Claude Code (essentially the company&rsquo;s flagship product), <a href=https://x.com/bcherny/status/2004887829252317325 target=_blank rel="noopener noreffer">stated</a> that in the previous 30 days, 100% of the work on the Claude Code repository had been done by Claude Code itself</li><li>The sharp slowdown in stock prices for some SaaS companies suggests that <a href="https://www.bloomberg.com/news/articles/2026-02-04/what-s-behind-the-saaspocalypse-plunge-in-software-stocks?embedded-checkout=true" target=_blank rel="noopener noreffer">the market has already priced in</a> the tendency for companies to build software in-house rather than buying it from the usual big players</li><li>Spotify <a href=https://techcrunch.com/2026/02/12/spotify-says-its-best-developers-havent-written-a-line-of-code-since-december-thanks-to-ai/ target=_blank rel="noopener noreffer">declared</a> that since December 2025 their best developers haven&rsquo;t written a single line of code: they send instructions via Slack to their internal system &ldquo;Honk&rdquo; (based on Claude Code), which implements the changes, while the engineers focus on review and architecture</li></ul><hr><p>To tackle this discussion, however, we need to leave behind the &ldquo;Vibe Coding&rdquo; hype and understand from the outset that we&rsquo;re talking about a different way of conceiving the developer&rsquo;s profession and the software assembly line.
This approach requires method and discipline, and might even be hard to swallow for some, because it risks compressing certain &ldquo;creative&rdquo; phases of the work â€” which can sometimes be the most rewarding.</p><h2 id=is-software-development-a-dead-profession>Is Software Development a Dead Profession?</h2><p>According to many analysts, we&rsquo;re looking at a &ldquo;<em>transformation</em>,&rdquo; so in a sense the answer is no. However, I believe the transformation will be so radical that within 5 to 10 years, none of us will see a job posting that simply says &ldquo;Developer.&rdquo;
The software developer of tomorrow requires highly varied expertise (architectures, networks, processes, languages, data, &mldr;). I don&rsquo;t know what this role will be called in the future, but for simplicity I&rsquo;ll call it the &ldquo;<strong>DESIGNER</strong>&rdquo; (in the sense of system designer/architect).</p><p>The same &ldquo;Designer&rdquo; pattern is already being applied in other less common domains, such as writing and journalism.
To give you an extreme example, a few months ago Luciano Floridi, one of the leading figures in the philosophy of information and the digital age, published a book titled <a href=https://www.rivista.ai/wp-content/uploads/2025/04/ssrn-5232088.pdf target=_blank rel="noopener noreffer">Distant Writing: Literary Production in the Age of Artificial Intelligence.</a> In this work, Floridi pursues an ambitious project of interweaving stories of minor characters (mentioned but secondary) from classic English novels, from Jane Austen to Virginia Woolf, into short stories (1,500â€“2,000 words each) where they meet in narrative chains that are plausible given the era, location, and social status.
In interviews he has given, Floridi stated that he essentially &ldquo;designed&rdquo; the book and had it in a drawer for many years, but was able to realize it only through the use of LLMs to expand and write the individual stories, and to ensure that characters would encounter one another in a way consistent with their characteristics and the overall plot.</p><h2 id=prerequisites>Prerequisites</h2><p>To prepare for this transformation, I see mainly 2 prerequisites â€” one technical and one mental. Neither is optional: without the right skills you can&rsquo;t produce quality specifications; without the right mindset you won&rsquo;t have the patience to write them.</p><h3 id=skills>Skills</h3><p>Software specifications have existed forever â€” they&rsquo;re certainly not a 2026 novelty. Yet it&rsquo;s surprising to note how the tech world is refocusing on the importance of this concept after having invented the transformer, cleared forests, and haunted stock markets with potential AI bubbles.</p><p>Spec-Driven Development techniques are obviously based on the concept of &ldquo;Specification,&rdquo; which can be understood at various levels of abstraction (e.g., user story, technical specification, code template, &mldr;).
The Designer must therefore be able to read and write specifications across the entire stack and must have a methodical and rigorous approach to industrialize the work.</p><p>But how do I write specifications for a solution with frontend components, backend, a message broker, various containers, and the need to deploy it on one hyperscaler rather than another?</p><p>In the past, you needed to know the basics of computing, CPUs, memory, data modeling, and telecommunications networks.
Now, you need to raise the level of abstraction and broaden the perspective. This means knowing data platforms, hyperscalers, authentication patterns, deployment models and containerization, automation pipelines, and managing software across dozens or potentially hundreds of branches.</p><p>To evolve from &ldquo;Developer&rdquo; of 2020 to &ldquo;Designer&rdquo; of 2026, you need:</p><ul><li>knowledge of basic DevOps practices</li><li>foundational competencies in Solution Design and the ability to navigate the most common development and deployment patterns (microservices, message brokers, containers, transport and application protocols, Security, IaC, &mldr;)</li><li>strong technical expertise in a specific area (e.g., frontend, data engineering, &mldr;)</li><li>understanding the basics of LLMs, particularly the role of context and context engineering techniques</li></ul><h3 id=mindset>Mindset</h3><p>For many people, development is a passion as well as a job, as demonstrated by the countless open-source development communities.
We need to get used to the idea that the Designer&rsquo;s work might be far less fun than today&rsquo;s Developer&rsquo;s work. This shift might be an unacceptable effort for everyone, but it&rsquo;s very likely that this is exactly where the battle over skills valued by the job market will be fought: the ability to read and write specifications will be fundamental.</p><p>We also need to fight the impulse to have &ldquo;everything right now&rdquo;: we can&rsquo;t expect to write a prompt and have the software ready. We truly need to apply a certain level of effort and genuinely use the skills we mentioned above. As I described in the introduction, the day &ldquo;wasted&rdquo; writing specifications saved me about two weeks of work. But the initial feeling was exactly that: of wasting time. It&rsquo;s a counterintuitive investment, and the right mindset consists precisely in accepting it.</p><h2 id=core-concepts>Core Concepts</h2><h3 id=context-window>Context Window</h3><p>Most people think: &ldquo;the more I put into the context, the better.&rdquo; This is an idea that can lead you astray, and understanding why requires a minimum understanding of how models work.</p><p>LLMs are autoregressive models based on the Transformer architecture. The heart of this architecture is the <strong>self-attention</strong> mechanism: for each generated token, the model calculates an &ldquo;attention&rdquo; score against <em>all</em> previous tokens in the context. This has two important practical implications:</p><ol><li><p><strong>Quadratic complexity</strong>: the computational cost of attention grows as O(n^2) relative to context length. Doubling the context quadruples the cost. This is not just a latency and cost issue (which are also significant), but it degrades the quality of the output itself.</p></li><li><p><strong>&ldquo;Lost in the middle&rdquo;</strong>: several studies (including the well-known paper by Liu et al., 2023) have shown that LLMs tend to pay more attention to information at the beginning and end of the context, &ldquo;forgetting&rdquo; what&rsquo;s in the middle. In practice, if the crucial specification of your API is in the middle of an 80,000-token conversation, the model might simply not take it into account.</p></li></ol><p>Although the LLM interface presents itself as a chat, we should always evaluate each interaction as if it were an <strong>isolated task</strong>, carrying along a conversational history that is often useless, pollutes the context window, and leads the model astray. This phenomenon is called <em>Context Bloat</em>.</p><h3 id=context-engineering>Context Engineering</h3><p>The term &ldquo;Context Engineering&rdquo; is often confused with prompt engineering, but they are distinct concepts. Prompt engineering concerns the formulation of a single request to the LLM. Context Engineering is something broader: it&rsquo;s the systematic control of <strong>everything that enters the model&rsquo;s context window</strong> â€” system prompt, persistent instructions (like <code>CLAUDE.md</code>), tool results, loaded code files, memory of previous interactions, and only lastly the user&rsquo;s prompt.</p><p>Think of the context as a <strong>program</strong>: every element you insert is an instruction that the model will execute (or attempt to execute). The more contradictory or irrelevant instructions you insert, the more unpredictable the &ldquo;program&rdquo; becomes.</p><p>With this perspective, SDD techniques are essentially Context Engineering techniques: they maximize the effectiveness of the context window by making development modular (SPEC -> PLAN -> CLARIFY -> IMPLEMENTATION) and above all by minimizing noise. Each phase operates in a clean, dedicated context, with only the information relevant to that specific task.</p><h3 id=divide-and-conquer>Divide and Conquer</h3><p>In the realm of software development, many people (including many of today&rsquo;s <strong>developers</strong>) think that the LLM is only useful for writing code, while SDD techniques are based on the assumption that the Designer uses the LLM <strong>across the entire pipeline</strong> of software work.</p><table><thead><tr><th>Phase</th><th>Objective</th><th>LLM Usage</th></tr></thead><tbody><tr><td>Ideation</td><td>Exploration of the <strong>solution space</strong></td><td>For a given problem, there are potentially infinite solutions, and LLMs are a formidable tool for exploring them</td></tr><tr><td>Specifications</td><td>Detailed definition of user requirements</td><td>Beyond defining detailed specifications, this phase also identifies any gaps and areas of ambiguity</td></tr><tr><td>Design</td><td>Having a solid baseline to write code without &ldquo;improvising&rdquo;</td><td>Research, expansion, deep-dive, and selection of software components to create/modify, plus the development plan and testing approach</td></tr><tr><td>Implementation</td><td>Translating the design into code</td><td>Writing code and tests</td></tr><tr><td>Testing</td><td>Software verification</td><td>Running tests and identifying bugs</td></tr></tbody></table><div class="callout callout-tip"><div class=callout-title>ðŸ’¡ Tip</div><div class=callout-content><ul><li>For each phase, it&rsquo;s worth evaluating the most suitable LLM on a case-by-case basis. For example, at the time of writing, Claude Opus 4.6 is among the top performers in pure coding, but models like the latest versions of ChatGPT, Gemini 3, or Kimi k2.5 can be more effective and creative in the solution exploration phases.</li><li>Reusing the same context for an entire development cycle is strongly discouraged, even if the model supports millions of tokens. The reason is the Context Bloat discussed above: the architectural decisions from the Planning phase, the user story details from the Specification phase, and the code from the Implementation phase all compete for the model&rsquo;s attention. The result is a progressive degradation in quality across <em>all</em> phases, not just the last one.</li></ul></div></div><style>.callout{border-left:4px solid;padding:1rem;margin:1.5rem 0;border-radius:4px;background-color:var(--callout-bg)}.callout-title{font-weight:700;margin-bottom:.5rem}.callout-note{border-color:#0969da;background-color:#ddf4ff}.callout-tip{border-color:#1a7f37;background-color:#dcffe4}.callout-important{border-color:#8250df;background-color:#fbefff}.callout-warning{border-color:#9a6700;background-color:#fff8c5}.callout-caution{border-color:#cf222e;background-color:#ffebe9}[data-theme=dark] .callout-note,.dark .callout-note{background-color:#0969da1a;color:#e6edf3}[data-theme=dark] .callout-tip,.dark .callout-tip{background-color:#1a7f371a;color:#e6edf3}[data-theme=dark] .callout-important,.dark .callout-important{background-color:#8250df1a;color:#e6edf3}[data-theme=dark] .callout-warning,.dark .callout-warning{background-color:#9a67001a;color:#e6edf3}[data-theme=dark] .callout-caution,.dark .callout-caution{background-color:#cf222e1a;color:#e6edf3}</style><h2 id=what-is-sdd>What Is SDD</h2><p><strong>Spec-Driven Development</strong> (SDD) is a paradigm that treats <strong>specifications as the primary source of truth</strong> for a software system. Code becomes a secondary artifact, generated or verified against the specification. Instead of the classic approach &ldquo;write the code first, document later,&rdquo; SDD inverts the flow: you write clear, structured specifications of the expected behavior and then generate, implement, or verify the code against them.</p><p>In other words: <strong>the specification is the product, the code is a byproduct</strong>.</p><p>This concept is not entirely new. API-first development with OpenAPI, BDD (Behavior-Driven Development), and contract-driven testing have existed for years. What changes today is that LLMs make it possible to <strong>automate the entire flow</strong>: from specification to technical plan, from plan to tasks, from tasks to code, from code to tests. The specification becomes a true <em>control plane</em> that orchestrates AI agents and human developers.</p><p>A <a href=https://www.arxiv.org/pdf/2602.00180.pdf target=_blank rel="noopener noreffer">recent paper on arXiv</a> formalizes SDD as follows: <em>&ldquo;Specifications are the source of truth; code derives from them. The specification is the authoritative description that humans and machines use to understand, build, and evolve the system.&rdquo;</em></p><h3 id=levels-of-sdd>Levels of SDD</h3><p>There isn&rsquo;t a single way to apply SDD. Three levels of rigor can be identified:</p><ul><li><strong>Spec-first</strong>: the specification is written before implementation and guides initial development. Ideal for new services, APIs, or features with multiple consumers.</li><li><strong>Spec-anchored</strong>: specification and code evolve together, kept in sync through tests and validation. This is the most practical level for most teams in production.</li><li><strong>Spec-as-source</strong>: humans only edit specifications; code is generated from them. Suitable for highly regulated or structured domains where traceability from requirement to code must be rigorous.</li></ul><p>Most teams will find <strong>spec-anchored</strong> to be the right compromise between rigor and agility.</p><h3 id=overview-of-key-frameworks>Overview of Key Frameworks</h3><p>The SDD tooling ecosystem is developing rapidly. Here are the three most relevant frameworks:</p><h4 id=spec-kit-github>Spec Kit (GitHub)</h4><p><a href=https://github.com/github/spec-kit target=_blank rel="noopener noreffer">Spec Kit</a> is GitHub&rsquo;s open-source toolkit for SDD. It proposes a multi-phase workflow (<code>Specify -> Plan -> Tasks -> Implement</code>) and generates versioned Markdown artifacts in the repository. It&rsquo;s compatible with GitHub Copilot, Claude Code, Cursor, and Gemini CLI. We&rsquo;ll dive deeper into Spec Kit in the next chapter.</p><h4 id=openspec-fission-ai>OpenSpec (Fission AI)</h4><p><a href=https://openspec.pro/ target=_blank rel="noopener noreffer">OpenSpec</a> is a lightweight, open-source framework (TypeScript) designed to bring determinism to AI development. Its distinctive features:</p><ul><li><strong>Delta Specs</strong>: captures incremental changes in requirements, rather than rewriting the entire specification</li><li><strong>Brownfield-first</strong>: designed to evolve existing codebases, not just greenfield projects</li><li><strong>No API key or complex installation</strong>: specifications live in the repository alongside the code</li><li>Supports over 20 tools, including Claude Code, Cursor, and GitHub Copilot</li></ul><h4 id=bmad-method>BMAD Method</h4><p>The <a href=https://github.com/bmad-code-org/BMAD-METHOD target=_blank rel="noopener noreffer">BMAD Method</a> (Breakthrough Method for Agile AI-Driven Development) is a more ambitious open-source framework, with:</p><ul><li><strong>21 specialized AI agents</strong> (Analyst, Product Manager, Architect, Developer, QA, Scrum Master, &mldr;) each with defined roles and responsibilities</li><li><strong>50+ guided workflows</strong> for different project types and phases</li><li><strong>Multi-agent architecture</strong>: agents collaborate from ideation to implementation</li><li>Compatible with Claude Code, Cursor, Windsurf, and other AI IDEs</li></ul><p>Here&rsquo;s a quick guide to help you choose:</p><table><thead><tr><th>Criterion</th><th>Spec Kit</th><th>OpenSpec</th><th>BMAD</th></tr></thead><tbody><tr><td>Setup complexity</td><td>Low (CLI + Markdown)</td><td>Very low (files in repo)</td><td>Medium-high (21 agents to configure)</td></tr><tr><td>Ideal for</td><td>Greenfield projects with GitHub</td><td>Evolving existing codebases</td><td>Enterprise projects with structured teams</td></tr><tr><td>Learning curve</td><td>~1 hour</td><td>~30 minutes</td><td>~1 day</td></tr><tr><td>Lock-in</td><td>Low (Markdown + Git)</td><td>None (files in repo)</td><td>Medium (framework dependency)</td></tr><tr><td>Brownfield support</td><td>Limited</td><td>Excellent (Delta Specs)</td><td>Good</td></tr></tbody></table><p>In general: start with <strong>Spec Kit</strong> if you use GitHub and want a structured but lightweight workflow. Choose <strong>OpenSpec</strong> if you need to evolve an existing codebase without disrupting your workflow. Consider <strong>BMAD</strong> only if your project requires multi-role coordination and you have the time budget to configure the entire orchestra of agents.</p><h3 id=deep-dive-into-spec-kit>Deep Dive into Spec Kit</h3><p>Spec Kit deserves a deeper look because it represents the state of the art in SDD applied to coding agents and is directly backed by GitHub and Microsoft.</p><p>The Spec Kit workflow is organized into well-defined steps, each with a dedicated command:</p><p><strong>1. Project Constitution (<code>/speckit.constitution</code>)</strong></p><p>You define the non-negotiable principles of the project: coding standards, testing requirements, security rules, UX principles, performance targets. The <em>constitution</em> is automatically consulted at every subsequent phase as a constraint.</p><p><strong>2. Functional Specification (<code>/speckit.specify</code>)</strong></p><p>An idea is transformed into a structured functional specification: user stories, functional requirements, acceptance criteria. No technical details here â€” only the <em>what</em> and the <em>why</em>. Spec Kit automatically creates a dedicated Git branch for the feature.</p><p><strong>3. Clarification (<code>/speckit.clarify</code>)</strong></p><p>The AI agent asks structured questions to eliminate ambiguities from the specification: edge cases, constraints, error handling, permissions. This phase is critical: an ambiguous specification produces ambiguous code.</p><p><strong>4. Technical Plan (<code>/speckit.plan</code>)</strong></p><p>The validated specification is translated into a detailed technical plan: architectural decisions, data models, APIs, integrations. This is where you choose the stack, patterns, and interfaces. Generated artifacts include <code>plan.md</code>, <code>data-model.md</code>, and a <code>contracts/</code> folder with API specifications.</p><p><strong>5. Validation (<code>/speckit.checklist</code>, <code>/speckit.analyze</code>)</strong></p><p>Quality control and consistency checking across all artifacts before writing code. Inconsistencies, gaps, and quality issues are identified.</p><p><strong>6. Task Decomposition (<code>/speckit.tasks</code>)</strong></p><p>The plan is decomposed into small, reviewable work units: each task has explicit inputs, outputs, and success criteria tied to the specification. Tasks are ordered by dependencies, and parallelizable ones are marked.</p><p><strong>7. Implementation (<code>/speckit.implement</code>)</strong></p><p>The AI agent executes the tasks, generating and modifying code, tests, and configurations according to the plan. Code is produced in small diffs, easily reviewable.</p><h3 id=a-practical-example>A Practical Example</h3><p>Let&rsquo;s imagine we want to develop a simple API for managing a book library. Here&rsquo;s how the flow would unfold with Spec Kit:</p><p><strong>Phase 1 - Constitution:</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-text"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>/speckit.constitution
</span></span><span class=line><span class=cl>The project follows an API-first approach. We use Python with FastAPI.
</span></span><span class=line><span class=cl>Every endpoint must have unit tests. Security: JWT authentication.
</span></span><span class=line><span class=cl>PostgreSQL database with Alembic for migrations.</span></span></code></pre></div></div><p><strong>Phase 2 - Specify:</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-text"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>/speckit.specify
</span></span><span class=line><span class=cl>Build a REST API to manage a book library.
</span></span><span class=line><span class=cl>Users can search books by title, author, or ISBN.
</span></span><span class=line><span class=cl>Administrators can add, modify, and remove books.
</span></span><span class=line><span class=cl>Each book has: title, author, ISBN, publication year, genre.
</span></span><span class=line><span class=cl>Include user stories and acceptance criteria.</span></span></code></pre></div></div><p>At this point, Spec Kit generates a structured <code>spec.md</code> file with user stories like:</p><ul><li><em>As a user, I want to search books by title, so I can quickly find the book I&rsquo;m interested in</em></li><li><em>As an administrator, I want to add a new book to the catalog, specifying all metadata</em></li></ul><p><strong>Phase 3 - Clarify:</strong> The agent asks, for example: &ldquo;Are there limits on the number of results per page? What happens if someone tries to insert a duplicate ISBN? Which fields are required?&rdquo;</p><p><strong>Phase 4 - Plan:</strong> A technical plan is generated. Here&rsquo;s a realistic excerpt from the generated <code>plan.md</code>:</p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-markdown"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gh># Technical Plan - Library API
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Architecture
</span></span></span><span class=line><span class=cl><span class=k>-</span> Framework: FastAPI with Pydantic v2 for validation
</span></span><span class=line><span class=cl><span class=k>-</span> Database: PostgreSQL 16 with SQLAlchemy 2.0 (async)
</span></span><span class=line><span class=cl><span class=k>-</span> Migrations: Alembic with autogenerate
</span></span><span class=line><span class=cl><span class=k>-</span> Auth: JWT (access token 15min + refresh token 7d)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Data Model
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>### Book
</span></span></span><span class=line><span class=cl>| Field        | Type         | Constraints                 |
</span></span><span class=line><span class=cl>|-------------|-------------|---------------------------|
</span></span><span class=line><span class=cl>| id          | UUID        | PK, auto-generated         |
</span></span><span class=line><span class=cl>| title       | VARCHAR(255)| NOT NULL, INDEX            |
</span></span><span class=line><span class=cl>| author      | VARCHAR(255)| NOT NULL, INDEX            |
</span></span><span class=line><span class=cl>| isbn        | VARCHAR(13) | UNIQUE, NOT NULL           |
</span></span><span class=line><span class=cl>| year        | INTEGER     | CHECK (year &gt;= 1450)       |
</span></span><span class=line><span class=cl>| genre       | VARCHAR(100)| NULL                       |
</span></span><span class=line><span class=cl>| created_at  | TIMESTAMP   | DEFAULT now()              |
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## REST Endpoints
</span></span></span><span class=line><span class=cl><span class=k>-</span> <span class=sb>`GET /books?title=&amp;author=&amp;isbn=&amp;page=1&amp;size=20`</span> -&gt; 200 + pagination
</span></span><span class=line><span class=cl><span class=k>-</span> <span class=sb>`GET /books/{id}`</span> -&gt; 200 | 404
</span></span><span class=line><span class=cl><span class=k>-</span> <span class=sb>`POST /books`</span> -&gt; 201 | 400 (validation) | 409 (duplicate ISBN)
</span></span><span class=line><span class=cl><span class=k>-</span> <span class=sb>`PUT /books/{id}`</span> -&gt; 200 | 404
</span></span><span class=line><span class=cl><span class=k>-</span> <span class=sb>`DELETE /books/{id}`</span> -&gt; 204 | 404
</span></span><span class=line><span class=cl>- All POST/PUT/DELETE methods require header <span class=sb>`Authorization: Bearer &lt;token&gt;`</span></span></span></code></pre></div></div><p>Note the level of detail: types, constraints, response codes, authentication rules. There&rsquo;s no ambiguity, and the AI agent receiving this plan won&rsquo;t have to &ldquo;guess&rdquo; anything.</p><p><strong>Phase 5-6 - Checklist & Tasks:</strong> Tasks are generated such as:</p><ol><li>Create SQLAlchemy models (Book, User)</li><li>Configure Alembic and create the initial migration</li><li>Implement the <code>GET /books</code> endpoint with filters and pagination</li><li>Implement the <code>POST /books</code> endpoint with validation</li><li>Add JWT authentication</li><li>Write tests for each endpoint</li></ol><p>Each task has explicit inputs, outputs, and success criteria. Parallelizable tasks are marked with <code>[P]</code>, sequential ones are ordered by dependencies.</p><p><strong>Phase 7 - Implement:</strong> The agent executes each task, producing verifiable code and tests.</p><p>The key point is that every phase produces versioned Markdown artifacts in the repository, creating complete traceability from idea to code. If six months from now someone asks &ldquo;why does this API work this way?&rdquo;, the answer is in the specification.</p><h2 id=coding-agents>Coding Agents</h2><p>SDD is the methodology, but putting it into practice requires the right tools. <strong>Coding agents</strong> are the operational component of this new paradigm: AI agents that go beyond auto-completion â€” they plan tasks, modify codebases, run tests, and collaborate through existing DevOps workflows.</p><h3 id=how-a-coding-agent-works-under-the-hood>How a Coding Agent Works (Under the Hood)</h3><p>Before surveying the tools, it&rsquo;s worth understanding what distinguishes an &ldquo;agent&rdquo; from a simple chatbot. A coding agent operates according to a continuous <strong>agentic loop</strong>, which in pseudocode can be represented as:</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-python"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>while</span> <span class=n>task</span> <span class=ow>is</span> <span class=ow>not</span> <span class=n>complete</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>context</span>  <span class=o>=</span> <span class=n>gather</span><span class=p>(</span><span class=n>specs</span><span class=p>,</span> <span class=n>code</span><span class=p>,</span> <span class=n>test_results</span><span class=p>,</span> <span class=n>errors</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>plan</span>     <span class=o>=</span> <span class=n>reason</span><span class=p>(</span><span class=n>context</span><span class=p>)</span>           <span class=c1># the LLM decides what to do</span>
</span></span><span class=line><span class=cl>    <span class=n>action</span>   <span class=o>=</span> <span class=n>select_tool</span><span class=p>(</span><span class=n>plan</span><span class=p>)</span>         <span class=c1># tool selection: edit, bash, search...</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span>   <span class=o>=</span> <span class=n>execute</span><span class=p>(</span><span class=n>action</span><span class=p>)</span>           <span class=c1># real execution on filesystem/terminal</span>
</span></span><span class=line><span class=cl>    <span class=n>feedback</span> <span class=o>=</span> <span class=n>verify</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>            <span class=c1># test, lint, command output</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>feedback</span><span class=o>.</span><span class=n>has_errors</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>context</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>feedback</span><span class=p>)</span>         <span class=c1># the error becomes input for the next cycle</span></span></span></code></pre></div></div><p>The key mechanism is <strong>tool use</strong> (or function calling): the LLM doesn&rsquo;t just generate text â€” it emits structured calls to external tools: file editors, bash terminal, browser, APIs. This allows it to interact with the real world: read a file, modify it, run tests, and react to results.</p><p>The fundamental difference between the various agents on the market lies in <em>which tools</em> they have available and in <em>which environment</em> they operate:</p><ul><li><strong>Agents with direct filesystem access</strong> (Claude Code, Cursor): operate on your machine, with full access to terminal and files. Maximum flexibility, but require supervision.</li><li><strong>Agents in isolated sandbox</strong> (Devin, GitHub Copilot coding agent): operate in a dedicated cloud environment. Safer for full autonomy, but less flexible for custom workflows.</li></ul><p>The coding agent landscape has evolved rapidly, and today we can distinguish several categories:</p><h3 id=ecosystem-integrated-agents>Ecosystem-Integrated Agents</h3><ul><li><strong>GitHub Copilot coding agent</strong>: works directly within the Pull Request workflow. You can assign an issue to <code>@copilot</code> and the agent plans, modifies code, runs tests, and opens a PR autonomously. It&rsquo;s the native target for Spec Kit.</li><li><strong>Amazon Q Developer</strong>: AWS&rsquo;s AI assistant, particularly strong for cloud-native development, IaC, and application transformations (e.g., Java 8->17 migration).</li><li><strong>Google Gemini Code Assist</strong>: strong integration with Google Cloud services (BigQuery, Firebase, Apigee). Explicitly supported by Spec Kit as an SDD target.</li></ul><h3 id=editor-first-agents>Editor-First Agents</h3><ul><li><strong>Cursor</strong>: a fork of VS Code that&rsquo;s natively AI-first. The Agentic + Composer mode allows planning multi-step tasks, modifying multiple files, executing terminal commands, and iterating until tests pass.</li><li><strong>JetBrains AI Assistant & Junie</strong>: integrated across all JetBrains IDEs, Junie offers agentic programming for implementing fixes, refactoring, and tests.</li></ul><h3 id=agent-platforms>Agent Platforms</h3><ul><li><strong>Claude Code / Claude Agent SDK</strong>: Anthropic&rsquo;s platform based on the principle &ldquo;give the agent a computer.&rdquo; Claude Code has access to terminal and file system and operates with a continuous cycle: <em>gather context -> act -> verify -> repeat</em>. The Agent SDK allows building custom agents.</li><li><strong>Devin (Cognition)</strong>: a fully autonomous agent with its own integrated development environment (shell, editor, browser). Still experimental and not very &ldquo;enterprise-ready.&rdquo;</li></ul><h3 id=which-agent-should-you-choose>Which Agent Should You Choose?</h3><p>For a company looking to adopt SDD today, a pragmatic approach is:</p><ul><li><strong>GitHub Copilot</strong> or <strong>Amazon Q</strong> for issue/PR-driven work on core services</li><li><strong>Gemini Code Assist</strong> for SDD workflows on analytics and GCP integrations</li><li><strong>Cursor</strong> or <strong>JetBrains</strong> in the IDE for high-fidelity implementation from specifications</li><li><strong>Claude Code / Agent SDK</strong> for custom SDD pipelines where standard tools are too rigid</li></ul><h3 id=the-added-value-of-instruction-files-claudemd>The Added Value of Instruction Files: CLAUDE.md</h3><p>One of the most powerful concepts to emerge with coding agents is that of <strong>persistent instruction files</strong>: Markdown files that the agent reads automatically at the start of every session to understand the project context. Each agent has its own format (<code>.github/copilot-instructions.md</code> for Copilot, <code>.cursorrules</code> for Cursor, etc.), but the most well-known and mature is Claude Code&rsquo;s <code>CLAUDE.md</code>.</p><h3 id=what-is-claudemd>What Is CLAUDE.md</h3><p><code>CLAUDE.md</code> is a project-specific instruction file that Claude Code reads automatically when starting in a directory. Its purpose is to:</p><ul><li>Give Claude the <strong>minimum context</strong> it cannot infer from the code</li><li>Codify <strong>critical rules and caveats</strong> that must be respected in every task</li><li>Improve reliability and speed by avoiding repeated explanations</li></ul><p>Think of it as a <strong>carefully curated system prompt</strong>, not a wiki. It&rsquo;s a <strong>living contract</strong> between the codebase and the AI agents.</p><h3 id=how-to-set-up-a-good-claudemd>How to Set Up a Good CLAUDE.md</h3><p>Best practices, confirmed by both Anthropic documentation and empirical community experience, converge on several key principles.
These principles are not specific to Claude Code but derive from the general characteristics of LLMs, and therefore apply to any assistant or coding agent, even if the specific format may vary depending on the tool.</p><p><strong>1. Less is more</strong></p><p>Every additional line can <em>reduce</em> the overall quality of instruction adherence. LLMs can follow only a limited number of distinct instructions with high fidelity. When there are too many, adherence to <em>all</em> rules degrades â€” it&rsquo;s not that the last ones are ignored; all of them get worse.</p><p><strong>2. High signal, low noise</strong></p><p>Only include information that is:</p><ul><li>Hard for Claude to infer by reading the code</li><li>Relevant to the vast majority of daily tasks</li></ul><p><strong>3. The minimum effective structure</strong></p><p>A good <code>CLAUDE.md</code> typically contains three blocks:</p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-markdown"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gh># CLAUDE.md
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Project
</span></span></span><span class=line><span class=cl>This is a Next.js + TypeScript e-commerce portal that communicates
</span></span><span class=line><span class=cl>with our internal payment and catalog APIs.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Key Commands
</span></span></span><span class=line><span class=cl><span class=k>-</span> Install dependencies: <span class=sb>`pnpm install`</span>
</span></span><span class=line><span class=cl><span class=k>-</span> Dev server: <span class=sb>`pnpm dev`</span>
</span></span><span class=line><span class=cl><span class=k>-</span> Build: <span class=sb>`pnpm build`</span>
</span></span><span class=line><span class=cl><span class=k>-</span> Test: <span class=sb>`pnpm test`</span>
</span></span><span class=line><span class=cl><span class=k>-</span> Lint: <span class=sb>`pnpm lint`</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## IMPORTANT Caveats
</span></span></span><span class=line><span class=cl><span class=k>-</span> IMPORTANT: Do not modify <span class=sb>`prisma/schema.prisma`</span> directly.
</span></span><span class=line><span class=cl>  Use <span class=sb>`pnpm db:migrate`</span> and <span class=sb>`pnpm db:generate`</span>.
</span></span><span class=line><span class=cl><span class=k>-</span> IMPORTANT: The <span class=sb>`/api/webhooks/stripe`</span> endpoint expects the raw
</span></span><span class=line><span class=cl>  request body. DO NOT use a body parser.
</span></span><span class=line><span class=cl><span class=k>-</span> Images in <span class=sb>`public/`</span> must be optimized before committing;
</span></span><span class=line><span class=cl>  files &gt; 200KB will fail CI.</span></span></code></pre></div></div><p><strong>4. Don&rsquo;t include style rules</strong></p><p>Rules like &ldquo;use two spaces for indentation&rdquo; or &ldquo;use single quotes&rdquo; are a waste of instructions: Claude infers them from existing code, and linters and formatters handle them better anyway.</p><p><strong>5. Progressive disclosure</strong></p><p>For detailed but rarely needed information, don&rsquo;t weigh down the main file. Instead:</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-markdown"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gu>## Additional Documentation
</span></span></span><span class=line><span class=cl><span class=k>-</span> Database schema and migrations: read <span class=sb>`docs/schema.md`</span> when
</span></span><span class=line><span class=cl>  modifying models.</span></span></code></pre></div></div><p>Claude will open <code>docs/schema.md</code> only when necessary, instead of loading it on every task.</p><p><strong>6. Path-specific rules with <code>.claude/rules/</code></strong></p><p>Claude Code supports path-specific instruction files:</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-markdown"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gh># .claude/rules/tests.md
</span></span></span><span class=line><span class=cl>paths: [&#34;**/*.spec.ts&#34;, &#34;**/*.test.ts&#34;]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=gu>## Testing Rules
</span></span></span><span class=line><span class=cl><span class=k>-</span> Use Vitest, not Jest.
</span></span><span class=line><span class=cl>- Use the helpers in <span class=sb>`test-utils/`</span> for component rendering.</span></span></code></pre></div></div><p>This file is loaded only when Claude works on test files, keeping the global <code>CLAUDE.md</code> leaner.</p><p><strong>7. Continuous maintenance</strong></p><p>Treat <code>CLAUDE.md</code> as a living document: update it when you notice Claude repeating avoidable mistakes, remove obsolete instructions, reorder by importance. The most important rules should always be <strong>at the top of the file</strong>.</p><h2 id=limitations-and-risks-of-sdd>Limitations and Risks of SDD</h2><p>It would be dishonest to present SDD as a solution without issues. There are concrete limitations worth knowing before adopting it:</p><ul><li><strong>Non-determinism.</strong> LLMs are not deterministic: the same specification, given to the same model at two different times, can produce structurally different code. This means SDD doesn&rsquo;t guarantee reproducibility. The specification drastically reduces variance compared to a generic prompt, but doesn&rsquo;t eliminate it. That&rsquo;s why contract tests and automated validation are indispensable â€” they&rsquo;re the &ldquo;deterministic guardrail&rdquo; that compensates for the probabilistic nature of the model.
At the same time, though, it&rsquo;s worth reflecting on the fact that, in general, the same concept applies to humans as well: the same developer, reading the same specification at two different times, can write different code.</li><li><strong>Garbage in, garbage out (shifted up a level).</strong> If I use an LLM to generate the specifications themselves, who validates them? The risk is automating the production of plausible but incorrect specifications â€” for example, a data model that seems reasonable but violates an unstated business rule. Human review of specifications is not optional: it&rsquo;s the critical control point of the entire workflow.</li><li><strong>Scalability.</strong> The book library example works well, but what happens with a distributed system of 200 microservices? SDD scales well as long as specifications remain modularizable â€” one service at a time, one feature at a time. When cross-service dependencies become too intricate, the specifications themselves risk becoming a maintenance problem. This isn&rsquo;t a reason not to adopt SDD, but it is a reason not to think of it as a magic wand.</li><li><strong>Costs.</strong> A complete SDD workflow (specify -> clarify -> plan -> tasks -> implement) consumes significantly more tokens than a single prompt. Each phase involves one or more calls to the LLM, each with its own context. On top-tier models like Claude Opus or GPT-4, a complete cycle for a medium-complexity feature can cost between 5 and 20 dollars in tokens. It&rsquo;s an investment that pays for itself amply in terms of time saved, but it needs to be planned â€” especially for teams working on dozens of features in parallel.</li><li><strong>Overhead for simple projects.</strong> A complete SDD workflow for a 50-line script is over-engineering. SDD performs best on features with medium-to-high complexity, where ambiguities are the real cost. For trivial tasks, a good direct prompt remains the best choice.</li></ul><p>All these limitations are, however, manageable through a disciplined and aware approach. In other words, a naive &ldquo;vibe-coding&rdquo; approach may work fine for a small prototype, but as project complexity increases, it becomes necessary to apply SDD techniques with ever-greater rigor to avoid running into these problems.</p><h2 id=conclusions>Conclusions</h2><p>Spec-Driven Development is neither a passing fad nor an academic exercise.</p><p>It is a methodological and disciplined approach to software development through AI Agents, leveraging the capabilities of agents across the entire development stack â€” from exploring the solution space, to writing detailed specifications, to technical planning, through to implementation and testing.</p><p>But as we&rsquo;ve seen, it&rsquo;s not without limitations: the non-determinism of LLMs, the risk of incorrect specifications, token costs, and overhead for simple projects are all factors to consider. SDD works best when applied with judgment, not as dogma.</p><p>For those working in software development today, the message is clear:</p><ol><li><strong>Invest in cross-cutting skills</strong>: architecture, DevOps, data models, security. The Designer of the future isn&rsquo;t the one who writes the fastest code, but the one who writes the most precise specifications.</li><li><strong>Adopt gradually</strong>: start with API-first and contract tests. Then add an SDD framework like Spec Kit on a new feature. Measure the results.</li><li><strong>Abandon Vibe Coding</strong>: writing vague prompts and hoping for the best doesn&rsquo;t scale. Investing a day in specifications to save two weeks of work isn&rsquo;t &ldquo;wasting time&rdquo; â€” it&rsquo;s the Designer&rsquo;s craft.</li><li><strong>Prepare for the mindset shift</strong>: it will be less &ldquo;fun&rdquo; in the traditional sense, but the satisfaction of orchestrating a complex system through specifications that produce working software is, in its own way, equally rewarding.</li></ol><p>The future of software development isn&rsquo;t writing code. It&rsquo;s designing systems and letting the code write itself â€” but under the rigorous control of someone who knows what they want to achieve.</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on February 14, 2026</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on X" data-sharer=x data-url=https://c-daniele.github.io/en/posts/2026-02-14-intro-spec-driven-development/ data-title="The Developer --> Designer switch" data-hashtags=GenAI,Agents,Coding><i class="fab fa-x-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Threads" data-sharer=threads data-url=https://c-daniele.github.io/en/posts/2026-02-14-intro-spec-driven-development/ data-title="The Developer --> Designer switch"><i class="fab fa-threads fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://c-daniele.github.io/en/posts/2026-02-14-intro-spec-driven-development/ data-hashtag=GenAI><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://c-daniele.github.io/en/posts/2026-02-14-intro-spec-driven-development/ data-title="The Developer --> Designer switch"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://c-daniele.github.io/en/posts/2026-02-14-intro-spec-driven-development/ data-title="The Developer --> Designer switch"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@15.14.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on å¾®åš" data-sharer=weibo data-url=https://c-daniele.github.io/en/posts/2026-02-14-intro-spec-driven-development/ data-title="The Developer --> Designer switch"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Diaspora" data-sharer=diaspora data-url=https://c-daniele.github.io/en/posts/2026-02-14-intro-spec-driven-development/ data-title="The Developer --> Designer switch" data-description><i class="fab fa-diaspora fa-fw" aria-hidden=true></i></a><a href="https://t.me/share/url?url=https%3a%2f%2fc-daniele.github.io%2fen%2fposts%2f2026-02-14-intro-spec-driven-development%2f&amp;text=The%20Developer%20--%3e%20Designer%20switch" target=_blank title="Share on Telegram"><i class="fab fa-telegram fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/en/tags/genai/>GenAI</a>,&nbsp;<a href=/en/tags/agents/>Agents</a>,&nbsp;<a href=/en/tags/coding/>Coding</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/en/>Home</a></span></section></div><div class=post-nav><a href=/en/posts/2025-11-10-genai-frameworks-update/ class=prev rel=prev title="Why LangChain Is Still the Best Framework for GenAI"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Why LangChain Is Still the Best Framework for GenAI</a></div></div></article></div></main></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i></a></div><div id=fixed-buttons-hidden><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.2/sharer.min.js></script><script>window.config={comment:{},search:{highlightTag:"em",lunrIndexURL:"/en/index.json",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"lunr"}}</script><script src=/js/theme.min.js></script><script>var dnt,doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-8NZQZ3Z1RN")}</script><script src="https://www.googletagmanager.com/gtag/js?id=G-8NZQZ3Z1RN" async></script></body></html>