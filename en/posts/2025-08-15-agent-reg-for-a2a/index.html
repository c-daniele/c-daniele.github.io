<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Agent-Reg: Building an Open Agent Registry for A2A Protocol | Cdani's Blog</title><meta name=keywords content="ai,agent,A2A"><meta name=description content="Introduction During these scorching August days, I took the opportunity to thoroughly read Google&rsquo;s A2A protocol specification and try to understand how to use its concepts to design an enterprise Agent architecture, possibly free from technological or platform constraints.
What is A2A? The Agent2Agent (A2A) Protocol is an open standard designed and publicly shared by Google to facilitate communication and collaboration among AI agents. The standardization of AI interoperability model is a topic that has been discussed since the very first moments when we started talking about Agents, and there are several reasons for this:"><meta name=author content="Me"><link rel=canonical href=https://c-daniele.github.io/en/posts/2025-08-15-agent-reg-for-a2a/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.3598bbf45621a4ad34d093926efeb15d6df27175e085d2f069483f14ad39d7fa.css integrity="sha256-NZi79FYhpK000JOSbv6xXW3ycXXghdLwaUg/FK051/o=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://c-daniele.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://c-daniele.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://c-daniele.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://c-daniele.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://c-daniele.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=it href=https://c-daniele.github.io/it/posts/2025-08-15-agent-reg-for-a2a/><link rel=alternate hreflang=en href=https://c-daniele.github.io/en/posts/2025-08-15-agent-reg-for-a2a/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0,theme:"default",securityLevel:"loose"})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-8NZQZ3Z1RN"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-8NZQZ3Z1RN",{anonymize_ip:!1})}</script><meta property="og:title" content="Agent-Reg: Building an Open Agent Registry for A2A Protocol"><meta property="og:description" content="Introduction During these scorching August days, I took the opportunity to thoroughly read Google&rsquo;s A2A protocol specification and try to understand how to use its concepts to design an enterprise Agent architecture, possibly free from technological or platform constraints.
What is A2A? The Agent2Agent (A2A) Protocol is an open standard designed and publicly shared by Google to facilitate communication and collaboration among AI agents. The standardization of AI interoperability model is a topic that has been discussed since the very first moments when we started talking about Agents, and there are several reasons for this:"><meta property="og:type" content="article"><meta property="og:url" content="https://c-daniele.github.io/en/posts/2025-08-15-agent-reg-for-a2a/"><meta property="og:image" content="https://c-daniele.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-15T00:00:00+02:00"><meta property="article:modified_time" content="2025-08-15T00:00:00+02:00"><meta property="og:site_name" content="Cdani's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://c-daniele.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Agent-Reg: Building an Open Agent Registry for A2A Protocol"><meta name=twitter:description content="Introduction During these scorching August days, I took the opportunity to thoroughly read Google&rsquo;s A2A protocol specification and try to understand how to use its concepts to design an enterprise Agent architecture, possibly free from technological or platform constraints.
What is A2A? The Agent2Agent (A2A) Protocol is an open standard designed and publicly shared by Google to facilitate communication and collaboration among AI agents. The standardization of AI interoperability model is a topic that has been discussed since the very first moments when we started talking about Agents, and there are several reasons for this:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"Agent-Reg: Building an Open Agent Registry for A2A Protocol","item":"https://c-daniele.github.io/en/posts/2025-08-15-agent-reg-for-a2a/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Agent-Reg: Building an Open Agent Registry for A2A Protocol","name":"Agent-Reg: Building an Open Agent Registry for A2A Protocol","description":"Introduction During these scorching August days, I took the opportunity to thoroughly read Google\u0026rsquo;s A2A protocol specification and try to understand how to use its concepts to design an enterprise Agent architecture, possibly free from technological or platform constraints.\nWhat is A2A? The Agent2Agent (A2A) Protocol is an open standard designed and publicly shared by Google to facilitate communication and collaboration among AI agents. The standardization of AI interoperability model is a topic that has been discussed since the very first moments when we started talking about Agents, and there are several reasons for this:","keywords":["ai","agent","A2A"],"articleBody":"Introduction During these scorching August days, I took the opportunity to thoroughly read Google’s A2A protocol specification and try to understand how to use its concepts to design an enterprise Agent architecture, possibly free from technological or platform constraints.\nWhat is A2A? The Agent2Agent (A2A) Protocol is an open standard designed and publicly shared by Google to facilitate communication and collaboration among AI agents. The standardization of AI interoperability model is a topic that has been discussed since the very first moments when we started talking about Agents, and there are several reasons for this:\nextreme heterogeneity, both in terms of implementation, functionalities, and task execution models the trend towards specialization means that executing complex tasks will increasingly require collaboration between Agents many companies have already developed their first agent solutions, but to scale and extend them to new contexts, it’s essential to have a future-proof and open interoperability model. In the absence of a shared and stable standard, there’s a concrete risk of lock-in. A2A identifies 5 fundamental elements to solve these problems:\nThe transport protocol A2A provides 3 alternative transport protocols, all based on HTTPS, and establishes that an A2A-compliant agent must necessarily implement at least one of them\nJSON-RPC 2.0 gRPC HTTP+JSON/REST The Agent Cards This is the main tool for sharing the technical and functional features of agents according to a standard schema defined through the JSON language. The “Agent Cards” are like a sort of interface agreement exposed by the agent that, in addition to defining endpoints and technicalities for authentication and interoperability, also descriptively defines the agent’s purpose and capabilities (e.g., streaming support or push notifications). A2A requires that each agent must always expose its Agent Card so that it can be easily discovered and used by other agents and clients.\nIn a multi-agent context, a specific organization must therefore do 2 things:\ndefine a way to expose these “Agent Cards” (as we’ll see, A2A suggests using a Well-known URI according to the RFC 8615 standard) know at all times which AgentCards are available to the organization, where to find them, and possibly also their health status (healthy/inactive) These 2 points can be synthesized through the concept of Discovery which, in my opinion, is not addressed exhaustively and it’s the focus of this article.\nThe task lifecycle A2A classifies task types and defines their lifecycle. For example, a task could be completed with a single response message (stateless) or, more frequently, be a stateful object that transitions through different states. Clients can therefore refer to a task through a taskId returned by the agent throughout the lifecycle, which can also be long-lasting or require multiple interactions. Similarly, A2A provides that in the first response message, the agent also provides a contextId to manage the reference to the underlying LLM model context. The interesting thing is that the contextId can also go beyond the lifecycle of a single task. In this way, clients have the possibility to autonomously decompose some complex processes into simpler and self-consistent tasks referring to the same context known and stored by the agent.\nData exchange A2A makes a distinction between:\nMessages: represent a single interaction or contextual information between a client and an agent. Messages always indicate the sender’s role (user or agent). They are mainly used for instructions, prompts, responses, and status updates. Artifacts: represent the actual output of the task and are therefore generated at the end of execution Both messages and artifacts are composed of atomic units called parts, each of which can be of type TextPart, FilePart, or DataPart and can also contain metadata that helps describe their content.\nSecurity and asynchronous interaction management Agents must authenticate all requests, in compliance with the specifications defined in the SecurityScheme of their AgentCard. A2A provides that servers can implement authentication through the most common methods such as:\nOAuth 2.0 API Key OpenAI HTTP Basic Auth Mutual TLS (mTLS) The security theme is also important regarding Push Notifications, which is the mechanism that allows agents to send updates to clients proactively, through the setup of a dedicated Webhook by clients. A2A provides a Webhook validation process to prevent SSRF-type attacks.\nAgent Discovery Approaches for Agent Discovery provided in A2A As mentioned before, according to A2A, each agent must produce an Agent Card according to the specifications indicated by the protocol itself. This document is therefore a foundational element for the Agent Discovery phase, which can be implemented in at least one of these 3 ways (but A2A also leaves room for other alternatives):\nUse of Well-Known URI: Follows the principles of RFC 8615 according to which a particular path (\".well-known\") is reserved within URIs for sharing metadata about a specific web resource. In other words, starting from a domain (e.g., www.example.com) and from a resource exposed within such domain (e.g., “my_resource”), the RFC 8615 standard defines the concept of “Well Known URI” for the resource equal to http://www.example.com/.well-known/my_resource. According to the A2A protocol, AgentCards could therefore be exposed natively by Agent Servers through URIs like: https://{server_domain}/.well-known/agent-card.json (see Section 5.3). Agent Registry: Querying a centralized catalog of agents, which can be public or private. Direct configuration: Client applications can be pre-configured with all the information present in the Agent Card of the Agent Servers they need access to (for example with direct mapping of the AgentCard information in the application code). Brief comparison Referring to the 3 methods above, the third seems like brutal hard-coding of point-to-point configurations and is certainly not elegant and not scalable. Solution 1 is a mere technicality that simply refers to a standard for integration between systems on the WEB and by itself does not solve the problem at all, because client applications do not know a priori which are the resources (i.e., the Agents) to search for and towards which to direct HTTP calls to the “well-known” paths. In my opinion, the only real solution is number 2, which is the use of a centralized registry, which allows:\nto Agents: to be shared and made available to the organization to clients: to know which agents are available and their interface characteristics From my point of view, alongside these 2 basic macro-requirements, the Agent Registry could also provide some auxiliary functionalities to make the entire A2A ecosystem work, such as:\na healthcheck mechanism, to know the agent’s health status a search engine for skills, but also for capabilities, tags, description, or provider name, … authorization rules for consultation and access to agents direct purchase for access to “premium” agents (Agent Marketplace) However, A2A doesn’t define anything more about how these Agent Registries should be made and the specifications they should have. In fact, in the protocol specification it’s clearly written\nThe A2A protocol does not currently define a standard API for such registries, though this is an area of potential future exploration and community standardization.\nOpen solutions for Agent Registry As I wanted to design an agnostic and possibly “open” architecture, I did some research to identify any market tool that offer this type of functionality and, surprisingly, I found nothing. Even in the leading market platforms that promote the development of multi-agent architectures and enterprise-level agent applications, it seems to me (but I could be wrong) that at the moment there are a very few signs of openness towards this part of the A2A protocol. On the other hand, it seems natural that in this transition phase, the big players in the sector (hyperscalers and big tech) are trying to create a closed ecosystem, where each customer develops, publishes, and runs their own agents. In this scenario, it’s easy to imagine that there’s some resistance to standardizing and opening access to truly open and interoperable Agent Registries.\nGiven these considerations, I thought: “Okay, I’ll put in some effort and moreover, a bit of vibe-coding, and I’ll just build it by myself” 🛠️\nIntroduction to Agent-Reg What is Agent-Reg? Agent-Reg is a minimal and open-source implementation of an Agent Registry, in compliance with A2A specifications. It provides a centralized solution for the discovery and maintenance of A2A-compliant agents in a simple and interoperable way. You can find the code here: Agent-Reg GitHub Repository\nThe solution can be deployed anywhere and has been designed maintaining complete openness and platform independence. At its core, Agent-Reg solves the Discovery problem through:\nUniversal Agent Discovery: A searchable catalog of all available agents A2A Protocol Compliance: Support for the Agent2Agent specification and complete validation during registration Health Monitoring: Real-time tracking of agent availability and status (heartbeat) Advanced Search: Multi-criteria search for skills, capabilities, ownership, and other descriptive attributes Architecture Overview The architecture is extremely simple and, although some implementation choices are not yet optimized for scalability (for example, the usage of SQLite), it provides a starting point on which to build your own customizations.\ngraph TB subgraph \"Client Layer\" UI[React Frontend] CLI[CLI Tools] EXT[External Clients] end subgraph \"API Layer\" GATEWAY[FastAPI Gateway] CORS[CORS Middleware] VALID[Schema Validator] end subgraph \"Business Layer\" REG[Agent Registry Service] HEART[Heartbeat Manager] SEARCH[Search \u0026 Filter Engine] end subgraph \"Data Layer\" DB[(SQLite with JSON)] SCHEMA[A2A JSON Schema] end UI --\u003e GATEWAY CLI --\u003e GATEWAY EXT --\u003e GATEWAY GATEWAY --\u003e CORS CORS --\u003e VALID VALID --\u003e REG REG --\u003e HEART REG --\u003e SEARCH REG --\u003e DB VALID --\u003e SCHEMA Macro Components Backend The backend was developed using FastAPI, a modern Python framework that provides automatic API documentation, type validation, and excellent performance. Other notable features:\nSQLite with JSON Extension for Data Storage: a lightweight and battle-tested database with NoSQL support via JSON, requiring zero additional infrastructure configuration. This makes deployment simple and provides sufficient performance for at least a PoC or a working prototype capable of handling several thousand objects. Strict A2A Schema Validation: Each agent registration is validated against the official A2A JSON Schema to ensure protocol compliance RESTful API Design: Clean and intuitive endpoints that follow OpenAPI 3.0 specifications Frontend The web interface is built with React 18 and TypeScript, providing a modern and responsive experience for agent management:\nTailwind CSS: Simple and clean CSS framework Real-time Updates: Live monitoring of agent status and health Advanced Filtering: Intuitive search interface with multiple criteria How Agent Registration Works The agent registration process on Agent-Reg ensures that only valid agents compliant with A2A specifications can join the registry. Below is a sequence diagram illustrating the end-to-end registration flow:\nsequenceDiagram participant Client participant API participant Validator participant Registry participant Database Client-\u003e\u003eAPI: POST /agents/register API-\u003e\u003eValidator: Validate Agent Card Validator-\u003e\u003eValidator: Check A2A Schema Compliance alt Valid Agent Card Validator--\u003e\u003eAPI: Valid ✓ API-\u003e\u003eRegistry: Store Agent Registry-\u003e\u003eRegistry: Generate UUID Registry-\u003e\u003eRegistry: Add Timestamps Registry-\u003e\u003eDatabase: Insert Agent Document Database--\u003e\u003eRegistry: Confirmation Registry--\u003e\u003eAPI: Agent Record API--\u003e\u003eClient: 201 Created + Agent ID else Invalid Agent Card Validator--\u003e\u003eAPI: Validation Errors API--\u003e\u003eClient: 422 Unprocessable Entity end When an agent wants to register with Agent-Reg, it must provide its Agent Card. The platform performs Agent Card validation to ensure compliance, rejecting the request if protocol requirements are not met. If validation is successful, the agent is registered in the system and a unique identifier is returned, which the Agent can later use to perform operations on the registry (e.g., heartbeat).\nAt the frontend interface level, registration occurs by uploading an Agent Card or providing the network path to the /.well-known/agent-card.json descriptor\nSmart Agent Discovery Agent-Reg provides a very simple search engine that allows users to discover agents of interest based on various criteria. The following diagram illustrates the search engine architecture and applied filters:\ngraph LR subgraph \"Search Filters\" NAME[Name Filter] SKILL[Skill Filter] CAP[Capabilities Filter] OWNER[Owner Filter] ALIVE[Liveness Filter] end subgraph \"Search Engine\" FILTER[Filter Logic] HEART[Heartbeat Check] SORT[Result Sorting] end subgraph \"Results\" LIST[Agent List] META[Metadata] COUNT[Total Count] end NAME --\u003e FILTER SKILL --\u003e FILTER CAP --\u003e FILTER OWNER --\u003e FILTER ALIVE --\u003e HEART FILTER --\u003e SORT HEART --\u003e SORT SORT --\u003e LIST SORT --\u003e META SORT --\u003e COUNT Search Capabilities The search criteria are the following:\nBy Name: Simple textual search based on agent name By Skills: Find agents that declare specific skills (e.g., “route-planning”, “image-processing”, etc.) By Capabilities: Filter agents based on capabilities declared in the agent card according to the A2A protocol (streaming, push notifications, etc.) By Owner: Show agents managed by specific teams or organizations By Liveness: Show only agents that are currently active according to periodic heartbeat. Health Monitoring In a realistic scenario, agents will be a lot and potentially unstable due to their continuous evolution and maintenance (just think of a change in prompt or model), but also due to the complex network of dependencies. For example, an Agent can depend on external services or APIs but also on other Agents. Agent-Reg provides a heartbeat mechanism, where registered agents periodically notify the registry of their health status. This allows the registry to:\nProvide clients with real-time health status information Automatically filter unresponsive agents from search results Enable proactive monitoring and alerting for critical agents Data Model and A2A Compliance Agent-Reg adheres to the A2A protocol specification for agent card structure, but it’s obviously a simplified and extensible model. For example, it doesn’t include specific SecurityScheme definitions in their 5 variants. Below is a class diagram illustrating the logical data model:\nclassDiagram class AgentCard { +string name +string description +string version +string protocolVersion +string url +AgentSkill[] skills +AgentCapabilities capabilities +string[] defaultInputModes +string[] defaultOutputModes +string preferredTransport +AgentProvider provider +string documentationUrl +string iconUrl +AgentInterface[] additionalInterfaces +SecurityRequirement[] security +SecuritySchemes securitySchemes +AgentCardSignature[] signatures +boolean supportsAuthenticatedExtendedCard } class AgentSkill { +string id +string name +string description +string[] tags +string[] examples +string[] inputModes +string[] outputModes +SecurityRequirement[] security } class AgentCapabilities { +boolean streaming +boolean stateTransitionHistory +boolean pushNotifications +AgentExtension[] extensions } class AgentProvider { +string organization +string url } AgentCard \"1\" --\u003e \"0..*\" AgentSkill : contains AgentCard \"1\" --\u003e \"1\" AgentCapabilities : has AgentCard \"1\" --\u003e \"0..1\" AgentProvider : provided by Backend APIs Agent-Reg provides a complete REST API with some methods that implement the main operations:\nOperation Endpoint Description Agent Registration POST /agents/register Register a new A2A-compliant agent Agent Discovery GET /agents Search and filter agents with various criteria Agent Details GET /agents/{id} Retrieve complete information about a specific agent Health Check POST /agents/{id}/heartbeat Update agent liveness status Invocation Info GET /agents/{id}/invoke_url Get direct invocation details Real-World Usage Example Let’s see how Agent-Reg works in practice. Imagine you’re building a travel planning application that needs to find a route planning agent with real-time traffic capabilities:\n# Search for agents with route planning skills and streaming capability curl \"http://localhost:8000/agents?skill=route-optimizer-traffic\u0026capabilities=streaming\u0026only_alive=true\" The registry will return only active agents that match these criteria, complete with their invocation URLs, security requirements, and capability details.\nAt the user interface level, you can do the same thing through the search bar. Why Agent-Reg? Agent-Reg tries to solve the Discovery problem within an A2A-compliant agents ecosystem and can be potentially useful also for addressing security and governance issues in agent-based applications. I tried to summarize the main pillars on which I would like to make the tool evolve:\nInteroperability: heterogeneous agents that adhere to the standard can work together without the need for point-to-point connections or complex and redundant integrations Discovery: Organizations can maintain a complete and constantly updated catalog of their Agents Reliability: The heartbeat mechanism ensures that clients interact only with responsive agents Scalability: The architecture can handle thousands of agents without complex infrastructure requirements Openness: It’s an open-source solution that can be distributed anywhere, prevents vendor lock-in, and encourages innovation Getting Started Agent-Reg still lacks several functionalities and optimizations necessary before being able to actually use it in a production enviroment (e.g., authentication and authorization, error handling, logging, notifications, support for other NoSQL DBs, …), but it’s a foundation on which to build a small open and extensible ecosystem. Starting it’s very simple:\n# Backend setup cd backend/app pip install -r requirements.txt python src/main.py # Frontend setup cd frontend npm install npm start Conclusions In this period of strong acceleration about AI, the A2A protocol takes a very important step, because it brings together some basic concepts on which to build real standardization, but from this point of view, in my opinion, we are not yet in a maturity phase. The specifications themselves are not badly written, but they are quite generic (try yourself comparing them with other standards, like the HTTP/2 to understand what I mean…) and still leave many opportunities for extensions or integrations. One of the important points that seems to have been overlooked is Discovery, for which I’ve tried to imagine a centralized and open solution.\nI’m making it available to the community, hoping that some volunteer can help me by contributing to its development! 😊\n","wordCount":"2750","inLanguage":"en","datePublished":"2025-08-15T00:00:00+02:00","dateModified":"2025-08-15T00:00:00+02:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://c-daniele.github.io/en/posts/2025-08-15-agent-reg-for-a2a/"},"publisher":{"@type":"Organization","name":"Cdani's Blog","logo":{"@type":"ImageObject","url":"https://c-daniele.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://c-daniele.github.io/en/ accesskey=h title="Home (Alt + H)"><img src=https://c-daniele.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://c-daniele.github.io/it/ title=Italiano aria-label=Italiano>It</a></li></ul></div></div><ul id=menu><li><a href=https://c-daniele.github.io/en/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://c-daniele.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://c-daniele.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://c-daniele.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://c-daniele.github.io/en/>Home</a></div><h1 class=post-title>Agent-Reg: Building an Open Agent Registry for A2A Protocol</h1><div class=post-meta><span title='2025-08-15 00:00:00 +0200 +0200'>August 15, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;2750 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://c-daniele.github.io/it/posts/2025-08-15-agent-reg-for-a2a/>It</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#what-is-a2a>What is A2A?</a><ul><li><a href=#the-transport-protocol>The transport protocol</a></li><li><a href=#the-agent-cards>The <em>Agent Cards</em></a></li><li><a href=#the-task-lifecycle>The task lifecycle</a></li><li><a href=#data-exchange>Data exchange</a></li><li><a href=#security-and-asynchronous-interaction-management>Security and asynchronous interaction management</a></li></ul></li><li><a href=#agent-discovery>Agent Discovery</a><ul><li><a href=#approaches-for-agent-discovery-provided-in-a2a>Approaches for Agent Discovery provided in A2A</a></li><li><a href=#brief-comparison>Brief comparison</a></li></ul></li></ul><ul><li><a href=#what-is-agent-reg>What is Agent-Reg?</a></li><li><a href=#architecture-overview>Architecture Overview</a><ul><li><a href=#macro-components>Macro Components</a></li></ul></li><li><a href=#how-agent-registration-works>How Agent Registration Works</a></li><li><a href=#smart-agent-discovery>Smart Agent Discovery</a><ul><li><a href=#search-capabilities>Search Capabilities</a></li><li><a href=#health-monitoring>Health Monitoring</a></li></ul></li><li><a href=#data-model-and-a2a-compliance>Data Model and A2A Compliance</a></li><li><a href=#backend-apis>Backend APIs</a></li><li><a href=#real-world-usage-example>Real-World Usage Example</a></li><li><a href=#why-agent-reg>Why Agent-Reg?</a></li><li><a href=#getting-started>Getting Started</a></li></ul></nav></div></details></div><div class=post-content><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1><p>During these scorching August days, I took the opportunity to thoroughly read Google&rsquo;s A2A protocol specification and try to understand how to use its concepts to design an enterprise Agent architecture, possibly free from technological or platform constraints.</p><h2 id=what-is-a2a>What is A2A?<a hidden class=anchor aria-hidden=true href=#what-is-a2a>#</a></h2><p>The Agent2Agent (A2A) Protocol is an open standard designed and publicly shared by Google to facilitate communication and collaboration among AI agents. The standardization of AI interoperability model is a topic that has been discussed since the very first moments when we started talking about <em>Agents</em>, and there are several reasons for this:</p><ul><li>extreme heterogeneity, both in terms of implementation, functionalities, and task execution models</li><li>the trend towards specialization means that executing complex tasks will increasingly require collaboration between Agents</li><li>many companies have already developed their first agent solutions, but to scale and extend them to new contexts, it&rsquo;s essential to have a future-proof and open interoperability model. In the absence of a shared and stable standard, there&rsquo;s a concrete risk of lock-in.</li></ul><p>A2A identifies 5 fundamental elements to solve these problems:</p><h3 id=the-transport-protocol>The transport protocol<a hidden class=anchor aria-hidden=true href=#the-transport-protocol>#</a></h3><p>A2A provides 3 alternative transport protocols, all based on HTTPS, and establishes that an A2A-compliant agent must necessarily implement at least one of them</p><ol><li>JSON-RPC 2.0</li><li>gRPC</li><li>HTTP+JSON/REST</li></ol><h3 id=the-agent-cards>The <em>Agent Cards</em><a hidden class=anchor aria-hidden=true href=#the-agent-cards>#</a></h3><p>This is the main tool for sharing the technical and functional features of agents according to a standard schema defined through the JSON language.
The &ldquo;Agent Cards&rdquo; are like a sort of <em>interface agreement</em> exposed by the agent that, in addition to defining endpoints and technicalities for authentication and interoperability, also descriptively defines the agent&rsquo;s purpose and capabilities (e.g., streaming support or push notifications).
A2A requires that each agent must always expose its <strong>Agent Card</strong> so that it can be easily discovered and used by other agents and clients.</p><p>In a multi-agent context, a specific organization must therefore do 2 things:</p><ol><li>define a way to expose these &ldquo;Agent Cards&rdquo; (as we&rsquo;ll see, A2A suggests using a <em>Well-known URI</em> according to the <a href=https://datatracker.ietf.org/doc/html/rfc8615>RFC 8615</a> standard)</li><li>know at all times which AgentCards are available to the organization, where to find them, and possibly also their health status (healthy/inactive)</li></ol><p>These 2 points can be synthesized through the concept of <strong><a href=https://a2a-protocol.org/latest/topics/agent-discovery/#the-role-of-the-agent-card>Discovery</a></strong> which, in my opinion, is not addressed exhaustively and it&rsquo;s the focus of this article.</p><h3 id=the-task-lifecycle>The task lifecycle<a hidden class=anchor aria-hidden=true href=#the-task-lifecycle>#</a></h3><p>A2A classifies task types and defines their lifecycle. For example, a task could be completed with a single response message (stateless) or, more frequently, be a stateful object that transitions through different states. Clients can therefore refer to a task through a <strong>taskId</strong> returned by the agent throughout the lifecycle, which can also be long-lasting or require multiple interactions. Similarly, A2A provides that in the first response message, the agent also provides a <em>contextId</em> to manage the reference to the underlying LLM model context. The interesting thing is that the contextId can also go beyond the lifecycle of a single task. In this way, clients have the possibility to autonomously decompose some complex processes into simpler and self-consistent tasks referring to the same context known and stored by the agent.</p><h3 id=data-exchange>Data exchange<a hidden class=anchor aria-hidden=true href=#data-exchange>#</a></h3><p>A2A makes a distinction between:</p><ul><li><strong>Messages:</strong> represent a single interaction or contextual information between a client and an agent. Messages always indicate the sender&rsquo;s role (<em>user</em> or <em>agent</em>). They are mainly used for instructions, prompts, responses, and status updates.</li><li><strong>Artifacts:</strong> represent the actual output of the task and are therefore generated at the end of execution</li></ul><p>Both messages and artifacts are composed of atomic units called <em>parts</em>, each of which can be of type <em>TextPart</em>, <em>FilePart</em>, or <em>DataPart</em> and can also contain metadata that helps describe their content.</p><h3 id=security-and-asynchronous-interaction-management>Security and asynchronous interaction management<a hidden class=anchor aria-hidden=true href=#security-and-asynchronous-interaction-management>#</a></h3><p>Agents must authenticate all requests, in compliance with the specifications defined in the <em>SecurityScheme</em> of their AgentCard. A2A provides that servers can implement authentication through the most common methods such as:</p><ul><li>OAuth 2.0</li><li>API Key</li><li>OpenAI</li><li>HTTP Basic Auth</li><li>Mutual TLS (mTLS)</li></ul><p>The security theme is also important regarding <em>Push Notifications</em>, which is the mechanism that allows agents to send updates to clients proactively, through the setup of a dedicated Webhook by clients.
A2A provides a Webhook validation process to prevent SSRF-type attacks.</p><h2 id=agent-discovery>Agent Discovery<a hidden class=anchor aria-hidden=true href=#agent-discovery>#</a></h2><h3 id=approaches-for-agent-discovery-provided-in-a2a>Approaches for Agent Discovery provided in A2A<a hidden class=anchor aria-hidden=true href=#approaches-for-agent-discovery-provided-in-a2a>#</a></h3><p>As mentioned before, according to A2A, each agent <strong>must</strong> produce an Agent Card according to the specifications indicated by the protocol itself. This document is therefore a foundational element for the Agent Discovery phase, which can be implemented in at least one of these 3 ways (but A2A also leaves room for other alternatives):</p><ol><li>Use of <strong>Well-Known URI:</strong> Follows the principles of <a href=https://datatracker.ietf.org/doc/html/rfc8615>RFC 8615</a> according to which a particular path ("<em>.well-known</em>") is reserved within URIs for sharing metadata about a specific web resource. In other words, starting from a domain (e.g., <em><a href=https://www.example.com>www.example.com</a></em>) and from a resource exposed within such domain (e.g., &ldquo;<em>my_resource</em>&rdquo;), the RFC 8615 standard defines the concept of &ldquo;Well Known URI&rdquo; for the resource equal to <a href=http://www.example.com/.well-known/my_resource>http://www.example.com/.well-known/my_resource</a>. According to the A2A protocol, AgentCards could therefore be exposed natively by Agent Servers through URIs like: https://{server_domain}/.well-known/agent-card.json (see <a href=https://a2a-protocol.org/latest/specification/#53-recommended-location>Section 5.3</a>).</li><li><strong>Agent Registry:</strong> Querying a centralized catalog of agents, which can be public or private.</li><li><strong>Direct configuration:</strong> Client applications can be pre-configured with all the information present in the Agent Card of the Agent Servers they need access to (for example with direct mapping of the AgentCard information in the application code).</li></ol><h3 id=brief-comparison>Brief comparison<a hidden class=anchor aria-hidden=true href=#brief-comparison>#</a></h3><p>Referring to the 3 methods above, the third seems like brutal hard-coding of point-to-point configurations and is certainly not elegant and not scalable.
Solution 1 is a mere technicality that simply refers to a standard for integration between systems on the WEB and by itself does not solve the problem at all, because client applications do not know a priori which are the resources (i.e., the Agents) to search for and towards which to direct HTTP calls to the &ldquo;well-known&rdquo; paths. In my opinion, the only real solution is number 2, which is the use of a <strong>centralized registry</strong>, which allows:</p><ul><li><strong>to Agents</strong>: to be shared and made available to the organization</li><li><strong>to clients</strong>: to know which agents are available and their interface characteristics</li></ul><p>From my point of view, alongside these 2 basic macro-requirements, the Agent Registry could also provide some auxiliary functionalities to make the entire A2A ecosystem work, such as:</p><ul><li>a <strong>healthcheck</strong> mechanism, to know the agent&rsquo;s health status</li><li>a <strong>search engine</strong> for skills, but also for capabilities, tags, description, or provider name, &mldr;</li><li><strong>authorization</strong> rules for consultation and access to agents</li><li>direct purchase for access to &ldquo;premium&rdquo; agents (<strong>Agent Marketplace</strong>)</li></ul><p>However, A2A doesn&rsquo;t define anything more about how these Agent Registries should be made and the specifications they should have. In fact, in the protocol specification it&rsquo;s clearly written</p><blockquote><p>The A2A protocol does not currently define a standard API for such registries, though this is an area of potential future exploration and community standardization.</p></blockquote><h1 id=open-solutions-for-agent-registry>Open solutions for Agent Registry<a hidden class=anchor aria-hidden=true href=#open-solutions-for-agent-registry>#</a></h1><p>As I wanted to design an agnostic and possibly &ldquo;open&rdquo; architecture, I did some research to identify any market tool that offer this type of functionality and, surprisingly, <strong>I found nothing</strong>. Even in the leading market platforms that promote the development of multi-agent architectures and enterprise-level agent applications, it seems to me (but I could be wrong) that at the moment there are a very few signs of openness towards this part of the A2A protocol.
On the other hand, it seems natural that in this transition phase, the big players in the sector (hyperscalers and big tech) are trying to create a closed ecosystem, where each customer develops, publishes, and runs their own agents. In this scenario, it&rsquo;s easy to imagine that there&rsquo;s some resistance to standardizing and opening access to truly open and interoperable Agent Registries.</p><p>Given these considerations, I thought: &ldquo;Okay, I&rsquo;ll put in some effort and moreover, a bit of vibe-coding, and I&rsquo;ll just build it by myself&rdquo; 🛠️</p><h1 id=introduction-to-agent-reg>Introduction to Agent-Reg<a hidden class=anchor aria-hidden=true href=#introduction-to-agent-reg>#</a></h1><h2 id=what-is-agent-reg>What is Agent-Reg?<a hidden class=anchor aria-hidden=true href=#what-is-agent-reg>#</a></h2><p>Agent-Reg is a minimal and open-source implementation of an Agent Registry, in compliance with A2A specifications. It provides a centralized solution for the discovery and maintenance of A2A-compliant agents in a simple and interoperable way.
You can find the code here: <a href=https://github.com/your-repo/agent-reg>Agent-Reg GitHub Repository</a></p><p>The solution can be deployed anywhere and has been designed maintaining complete openness and platform independence. At its core, Agent-Reg solves the Discovery problem through:</p><ul><li><strong>Universal Agent Discovery</strong>: A searchable catalog of all available agents</li><li><strong>A2A Protocol Compliance</strong>: Support for the Agent2Agent specification and complete validation during registration</li><li><strong>Health Monitoring</strong>: Real-time tracking of agent availability and status (heartbeat)</li><li><strong>Advanced Search</strong>: Multi-criteria search for skills, capabilities, ownership, and other descriptive attributes</li></ul><h2 id=architecture-overview>Architecture Overview<a hidden class=anchor aria-hidden=true href=#architecture-overview>#</a></h2><p>The architecture is extremely simple and, although some implementation choices are not yet optimized for scalability (for example, the usage of SQLite), it provides a starting point on which to build your own customizations.</p><div class=mermaid>graph TB
subgraph "Client Layer"
UI[React Frontend]
CLI[CLI Tools]
EXT[External Clients]
end
subgraph "API Layer"
GATEWAY[FastAPI Gateway]
CORS[CORS Middleware]
VALID[Schema Validator]
end
subgraph "Business Layer"
REG[Agent Registry Service]
HEART[Heartbeat Manager]
SEARCH[Search & Filter Engine]
    end
    
    subgraph "Data Layer"
DB[(SQLite with JSON)]
SCHEMA[A2A JSON Schema]
end
UI --> GATEWAY
CLI --> GATEWAY
EXT --> GATEWAY
GATEWAY --> CORS
CORS --> VALID
VALID --> REG
REG --> HEART
REG --> SEARCH
REG --> DB
VALID --> SCHEMA</div><h3 id=macro-components>Macro Components<a hidden class=anchor aria-hidden=true href=#macro-components>#</a></h3><h4 id=backend>Backend<a hidden class=anchor aria-hidden=true href=#backend>#</a></h4><p>The backend was developed using <strong>FastAPI</strong>, a modern Python framework that provides automatic API documentation, type validation, and excellent performance.
Other notable features:</p><ul><li><strong>SQLite with JSON Extension</strong> for Data Storage: a lightweight and battle-tested database with NoSQL support via JSON, requiring zero additional infrastructure configuration. This makes deployment simple and provides sufficient performance for at least a PoC or a working prototype capable of handling several thousand objects.</li><li><strong>Strict A2A Schema Validation</strong>: Each agent registration is validated against the official A2A JSON Schema to ensure protocol compliance</li><li><strong>RESTful API Design</strong>: Clean and intuitive endpoints that follow OpenAPI 3.0 specifications</li></ul><h4 id=frontend>Frontend<a hidden class=anchor aria-hidden=true href=#frontend>#</a></h4><p>The web interface is built with <strong>React 18</strong> and <strong>TypeScript</strong>, providing a modern and responsive experience for agent management:</p><ul><li><strong>Tailwind CSS</strong>: Simple and clean CSS framework</li><li><strong>Real-time Updates</strong>: Live monitoring of agent status and health</li><li><strong>Advanced Filtering</strong>: Intuitive search interface with multiple criteria</li></ul><p><a href=/images/2025/agent-registry-home.png><img src=/images/2025/agent-registry-home.png alt="Agent-Reg Homepage"></a></p><h2 id=how-agent-registration-works>How Agent Registration Works<a hidden class=anchor aria-hidden=true href=#how-agent-registration-works>#</a></h2><p>The agent registration process on Agent-Reg ensures that only valid agents compliant with A2A specifications can join the registry. Below is a sequence diagram illustrating the end-to-end registration flow:</p><div class=mermaid>sequenceDiagram
participant Client
participant API
participant Validator
participant Registry
participant Database
Client->>API: POST /agents/register
API->>Validator: Validate Agent Card
Validator->>Validator: Check A2A Schema Compliance
alt Valid Agent Card
Validator-->>API: Valid ✓
API->>Registry: Store Agent
Registry->>Registry: Generate UUID
Registry->>Registry: Add Timestamps
Registry->>Database: Insert Agent Document
Database-->>Registry: Confirmation
Registry-->>API: Agent Record
API-->>Client: 201 Created + Agent ID
else Invalid Agent Card
Validator-->>API: Validation Errors
API-->>Client: 422 Unprocessable Entity
end</div><p>When an agent wants to register with Agent-Reg, it must provide its <strong>Agent Card</strong>. The platform performs Agent Card validation to ensure compliance, rejecting the request if protocol requirements are not met.
If validation is successful, the agent is registered in the system and a unique identifier is returned, which the Agent can later use to perform operations on the registry (e.g., heartbeat).</p><p>At the frontend interface level, registration occurs by uploading an Agent Card or providing the network path to the <em>/.well-known/agent-card.json</em> descriptor</p><p><a href=/images/2025/agent-registry-add-agent.png><img src=/images/2025/agent-registry-add-agent.png alt="Add new Agent UI"></a></p><h2 id=smart-agent-discovery>Smart Agent Discovery<a hidden class=anchor aria-hidden=true href=#smart-agent-discovery>#</a></h2><p>Agent-Reg provides a very simple search engine that allows users to discover agents of interest based on various criteria. The following diagram illustrates the search engine architecture and applied filters:</p><div class=mermaid>graph LR
subgraph "Search Filters"
NAME[Name Filter]
SKILL[Skill Filter]
CAP[Capabilities Filter]
OWNER[Owner Filter]
ALIVE[Liveness Filter]
end
subgraph "Search Engine"
FILTER[Filter Logic]
HEART[Heartbeat Check]
SORT[Result Sorting]
end
subgraph "Results"
LIST[Agent List]
META[Metadata]
COUNT[Total Count]
end
NAME --> FILTER
SKILL --> FILTER
CAP --> FILTER
OWNER --> FILTER
ALIVE --> HEART
FILTER --> SORT
HEART --> SORT
SORT --> LIST
SORT --> META
SORT --> COUNT</div><h3 id=search-capabilities>Search Capabilities<a hidden class=anchor aria-hidden=true href=#search-capabilities>#</a></h3><p>The search criteria are the following:</p><ul><li><strong>By Name</strong>: Simple textual search based on agent name</li><li><strong>By Skills</strong>: Find agents that declare specific skills (e.g., &ldquo;route-planning&rdquo;, &ldquo;image-processing&rdquo;, etc.)</li><li><strong>By Capabilities</strong>: Filter agents based on capabilities declared in the agent card according to the A2A protocol (streaming, push notifications, etc.)</li><li><strong>By Owner</strong>: Show agents managed by specific teams or organizations</li><li><strong>By Liveness</strong>: Show only agents that are currently active according to periodic heartbeat.</li></ul><h3 id=health-monitoring>Health Monitoring<a hidden class=anchor aria-hidden=true href=#health-monitoring>#</a></h3><p>In a realistic scenario, agents will be a lot and potentially unstable due to their continuous evolution and maintenance (just think of a change in prompt or model), but also due to the complex network of dependencies. For example, an Agent can depend on external services or APIs but also on other Agents.
Agent-Reg provides a heartbeat mechanism, where registered agents periodically notify the registry of their health status. This allows the registry to:</p><ul><li>Provide clients with real-time health status information</li><li>Automatically filter unresponsive agents from search results</li><li>Enable proactive monitoring and alerting for critical agents</li></ul><h2 id=data-model-and-a2a-compliance>Data Model and A2A Compliance<a hidden class=anchor aria-hidden=true href=#data-model-and-a2a-compliance>#</a></h2><p>Agent-Reg adheres to the A2A protocol specification for agent card structure, but it&rsquo;s obviously a simplified and extensible model. For example, it doesn&rsquo;t include specific SecurityScheme definitions in their 5 variants.
Below is a class diagram illustrating the logical data model:</p><div class=mermaid>classDiagram
class AgentCard {
+string name
+string description
+string version
+string protocolVersion
+string url
+AgentSkill[] skills
+AgentCapabilities capabilities
+string[] defaultInputModes
+string[] defaultOutputModes
+string preferredTransport
+AgentProvider provider
+string documentationUrl
+string iconUrl
+AgentInterface[] additionalInterfaces
+SecurityRequirement[] security
+SecuritySchemes securitySchemes
+AgentCardSignature[] signatures
+boolean supportsAuthenticatedExtendedCard
}
class AgentSkill {
+string id
+string name
+string description
+string[] tags
+string[] examples
+string[] inputModes
+string[] outputModes
+SecurityRequirement[] security
}
class AgentCapabilities {
+boolean streaming
+boolean stateTransitionHistory
+boolean pushNotifications
+AgentExtension[] extensions
}
class AgentProvider {
+string organization
+string url
}
AgentCard "1" --> "0..*" AgentSkill : contains
AgentCard "1" --> "1" AgentCapabilities : has
AgentCard "1" --> "0..1" AgentProvider : provided by</div><h2 id=backend-apis>Backend APIs<a hidden class=anchor aria-hidden=true href=#backend-apis>#</a></h2><p>Agent-Reg provides a complete REST API with some methods that implement the main operations:</p><table><thead><tr><th>Operation</th><th>Endpoint</th><th>Description</th></tr></thead><tbody><tr><td>Agent Registration</td><td><code>POST /agents/register</code></td><td>Register a new A2A-compliant agent</td></tr><tr><td>Agent Discovery</td><td><code>GET /agents</code></td><td>Search and filter agents with various criteria</td></tr><tr><td>Agent Details</td><td><code>GET /agents/{id}</code></td><td>Retrieve complete information about a specific agent</td></tr><tr><td>Health Check</td><td><code>POST /agents/{id}/heartbeat</code></td><td>Update agent liveness status</td></tr><tr><td>Invocation Info</td><td><code>GET /agents/{id}/invoke_url</code></td><td>Get direct invocation details</td></tr></tbody></table><h2 id=real-world-usage-example>Real-World Usage Example<a hidden class=anchor aria-hidden=true href=#real-world-usage-example>#</a></h2><p>Let&rsquo;s see how Agent-Reg works in practice. Imagine you&rsquo;re building a travel planning application that needs to find a route planning agent with real-time traffic capabilities:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Search for agents with route planning skills and streaming capability</span>
</span></span><span class=line><span class=cl>curl <span class=s2>&#34;http://localhost:8000/agents?skill=route-optimizer-traffic&amp;capabilities=streaming&amp;only_alive=true&#34;</span>
</span></span></code></pre></div><p>The registry will return only active agents that match these criteria, complete with their invocation URLs, security requirements, and capability details.</p><p>At the user interface level, you can do the same thing through the search bar.
<a href=/images/2025/agent-registry-search.png><img src=/images/2025/agent-registry-search.png alt="Agent Registry Search"></a></p><h2 id=why-agent-reg>Why Agent-Reg?<a hidden class=anchor aria-hidden=true href=#why-agent-reg>#</a></h2><p>Agent-Reg tries to solve the Discovery problem within an A2A-compliant agents ecosystem and can be potentially useful also for addressing security and governance issues in agent-based applications.
I tried to summarize the main pillars on which I would like to make the tool evolve:</p><ol><li><strong>Interoperability</strong>: heterogeneous agents that adhere to the standard can work together without the need for point-to-point connections or complex and redundant integrations</li><li><strong>Discovery</strong>: Organizations can maintain a complete and constantly updated catalog of their Agents</li><li><strong>Reliability</strong>: The heartbeat mechanism ensures that clients interact only with responsive agents</li><li><strong>Scalability</strong>: The architecture can handle thousands of agents without complex infrastructure requirements</li><li><strong>Openness</strong>: It&rsquo;s an open-source solution that can be distributed anywhere, prevents vendor lock-in, and encourages innovation</li></ol><h2 id=getting-started>Getting Started<a hidden class=anchor aria-hidden=true href=#getting-started>#</a></h2><p>Agent-Reg still lacks several functionalities and optimizations necessary before being able to actually use it in a production enviroment (e.g., authentication and authorization, error handling, logging, notifications, support for other NoSQL DBs, &mldr;), but it&rsquo;s a foundation on which to build a small open and extensible ecosystem.
Starting it&rsquo;s very simple:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Backend setup</span>
</span></span><span class=line><span class=cl><span class=nb>cd</span> backend/app
</span></span><span class=line><span class=cl>pip install -r requirements.txt
</span></span><span class=line><span class=cl>python src/main.py
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Frontend setup</span>
</span></span><span class=line><span class=cl><span class=nb>cd</span> frontend
</span></span><span class=line><span class=cl>npm install
</span></span><span class=line><span class=cl>npm start
</span></span></code></pre></div><h1 id=conclusions>Conclusions<a hidden class=anchor aria-hidden=true href=#conclusions>#</a></h1><p>In this period of strong acceleration about AI, the A2A protocol takes a very important step, because it brings together some basic concepts on which to build real standardization, but from this point of view, in my opinion, we are not yet in a maturity phase. The specifications themselves are not badly written, but they are quite generic (try yourself comparing them with other standards, like the <a href=https://datatracker.ietf.org/doc/html/rfc7540>HTTP/2</a> to understand what I mean&mldr;) and still leave many opportunities for extensions or integrations.
One of the important points that seems to have been overlooked is Discovery, for which I&rsquo;ve tried to imagine a centralized and open solution.</p><p>I&rsquo;m making it available to the community, hoping that some volunteer can help me by contributing to its development! 😊</p><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://c-daniele.github.io/en/tags/ai/>ai</a></li><li><a href=https://c-daniele.github.io/en/tags/agent/>agent</a></li><li><a href=https://c-daniele.github.io/en/tags/a2a/>A2A</a></li></ul><nav class=paginav><a class=next href=https://c-daniele.github.io/en/posts/2025-07-05-advanced-tecnique-for-analyzing-excel-files-with-llms/><span class=title>Next »</span><br><span>Beyond RAG: How to Effectively Analyze an Excel File Using an LLM</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Agent-Reg: Building an Open Agent Registry for A2A Protocol on twitter" href="https://twitter.com/intent/tweet/?text=Agent-Reg%3a%20Building%20an%20Open%20Agent%20Registry%20for%20A2A%20Protocol&amp;url=https%3a%2f%2fc-daniele.github.io%2fen%2fposts%2f2025-08-15-agent-reg-for-a2a%2f&amp;hashtags=ai%2cagent%2cA2A"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Agent-Reg: Building an Open Agent Registry for A2A Protocol on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fc-daniele.github.io%2fen%2fposts%2f2025-08-15-agent-reg-for-a2a%2f&amp;title=Agent-Reg%3a%20Building%20an%20Open%20Agent%20Registry%20for%20A2A%20Protocol&amp;summary=Agent-Reg%3a%20Building%20an%20Open%20Agent%20Registry%20for%20A2A%20Protocol&amp;source=https%3a%2f%2fc-daniele.github.io%2fen%2fposts%2f2025-08-15-agent-reg-for-a2a%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Agent-Reg: Building an Open Agent Registry for A2A Protocol on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fc-daniele.github.io%2fen%2fposts%2f2025-08-15-agent-reg-for-a2a%2f&title=Agent-Reg%3a%20Building%20an%20Open%20Agent%20Registry%20for%20A2A%20Protocol"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Agent-Reg: Building an Open Agent Registry for A2A Protocol on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fc-daniele.github.io%2fen%2fposts%2f2025-08-15-agent-reg-for-a2a%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Agent-Reg: Building an Open Agent Registry for A2A Protocol on whatsapp" href="https://api.whatsapp.com/send?text=Agent-Reg%3a%20Building%20an%20Open%20Agent%20Registry%20for%20A2A%20Protocol%20-%20https%3a%2f%2fc-daniele.github.io%2fen%2fposts%2f2025-08-15-agent-reg-for-a2a%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Agent-Reg: Building an Open Agent Registry for A2A Protocol on telegram" href="https://telegram.me/share/url?text=Agent-Reg%3a%20Building%20an%20Open%20Agent%20Registry%20for%20A2A%20Protocol&amp;url=https%3a%2f%2fc-daniele.github.io%2fen%2fposts%2f2025-08-15-agent-reg-for-a2a%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Agent-Reg: Building an Open Agent Registry for A2A Protocol on ycombinator" href="https://news.ycombinator.com/submitlink?t=Agent-Reg%3a%20Building%20an%20Open%20Agent%20Registry%20for%20A2A%20Protocol&u=https%3a%2f%2fc-daniele.github.io%2fen%2fposts%2f2025-08-15-agent-reg-for-a2a%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://c-daniele.github.io/en/>Cdani's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>